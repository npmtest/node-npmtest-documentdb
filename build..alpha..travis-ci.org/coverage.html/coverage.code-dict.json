{"/home/travis/build/npmtest/node-npmtest-documentdb/test.js":"/* istanbul instrument in package npmtest_documentdb */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-documentdb/lib.npmtest_documentdb.js":"/* istanbul instrument in package npmtest_documentdb */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_documentdb = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_documentdb = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-documentdb/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-documentdb && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_documentdb */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_documentdb\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_documentdb.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_documentdb.rollup.js'] =\n            local.assetsDict['/assets.npmtest_documentdb.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_documentdb.__dirname + '/lib.npmtest_documentdb.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-documentdb/node_modules/documentdb/index.js":"/*\r\nThe MIT License (MIT)\r\nCopyright (c) 2014 Microsoft Corporation\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy\r\nof this software and associated documentation files (the \"Software\"), to deal\r\nin the Software without restriction, including without limitation the rights\r\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\ncopies of the Software, and to permit persons to whom the Software is\r\nfurnished to do so, subject to the following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included in all\r\ncopies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\nSOFTWARE.\r\n*/\r\n\r\nmodule.exports = require('./lib/');","/home/travis/build/npmtest/node-npmtest-documentdb/node_modules/documentdb/lib/index.js":"/*\r\nThe MIT License (MIT)\r\nCopyright (c) 2014 Microsoft Corporation\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy\r\nof this software and associated documentation files (the \"Software\"), to deal\r\nin the Software without restriction, including without limitation the rights\r\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\ncopies of the Software, and to permit persons to whom the Software is\r\nfurnished to do so, subject to the following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included in all\r\ncopies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\nSOFTWARE.\r\n*/\r\n\r\n\"use strict\";\r\n\r\nvar Client = require(\"./documentclient\")\r\n  , Hash = require(\"./hash/hashPartitionResolver\")\r\n  , Range = require(\"./range\");\r\n\r\nif (typeof exports !== \"undefined\") {\r\n    exports.DocumentClient = Client.DocumentClient;\r\n    exports.DocumentBase = Client.DocumentBase;\r\n    exports.Base = Client.Base;\r\n    exports.Constants = Client.Constants;\r\n    exports.RetryOptions = Client.RetryOptions;\r\n    exports.Range = Range.Range;\r\n    exports.RangePartitionResolver = Range.RangePartitionResolver;\r\n    exports.HashPartitionResolver = Hash.HashPartitionResolver;\r\n}","/home/travis/build/npmtest/node-npmtest-documentdb/node_modules/documentdb/lib/documentclient.js":"/*\r\nThe MIT License (MIT)\r\nCopyright (c) 2014 Microsoft Corporation\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy\r\nof this software and associated documentation files (the \"Software\"), to deal\r\nin the Software without restriction, including without limitation the rights\r\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\ncopies of the Software, and to permit persons to whom the Software is\r\nfurnished to do so, subject to the following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included in all\r\ncopies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\nSOFTWARE.\r\n*/\r\n\r\n\"use strict\";\r\n\r\nvar Base = require(\"./base\")\r\n  , AzureDocuments = require(\"./documents\")\r\n  , QueryIterator = require(\"./queryIterator\")\r\n  , RequestHandler = require(\"./request\")\r\n  , RetryOptions = require(\"./retryOptions\")\r\n  , GlobalEndpointManager = require(\"./globalEndpointManager\")\r\n  , Constants = require(\"./constants\");\r\n\r\n//SCRIPT START\r\nvar DocumentClient = Base.defineClass(\r\n    /**\r\n     * Provides a client-side logical representation of the Azure DocumentDB database account.\r\n     * This client is used to configure and execute requests in the Azure DocumentDB database service.\r\n     * @constructor DocumentClient\r\n     * @param {string} urlConnection           - The service endpoint to use to create the client.\r\n     * @param {object} auth                    - An object that is used for authenticating requests and must contains one of the options\r\n     * @param {string} [auth.masterKey]        - The authorization master key to use to create the client.\r\n     * @param {Object} [auth.resourceTokens]   - An object that contains resources tokens. Keys for the object are resource Ids and values are the resource tokens.\r\n     * @param {Array}  [auth.permissionFeed]   - An array of {@link Permission} objects.\r\n     * @param {object} [connectionPolicy]      - An instance of {@link ConnectionPolicy} class. This parameter is optional and the default connectionPolicy will be used if omitted.\r\n     * @param {string} [consistencyLevel]      - An optional parameter that represents the consistency level. It can take any value from {@link ConsistencyLevel}.\r\n    */\r\n    function DocumentClient(urlConnection, auth, connectionPolicy, consistencyLevel) {\r\n        this.urlConnection = urlConnection;\r\n        if (auth !== undefined) {\r\n            this.masterKey = auth.masterKey;\r\n            this.resourceTokens = auth.resourceTokens;\r\n            if (auth.permissionFeed) {\r\n                this.resourceTokens = {};\r\n                for (var i = 0; i < auth.permissionFeed.length; i++) {\r\n                    var resourceParts = auth.permissionFeed[i].resource.split(\"/\");\r\n                    var rid = resourceParts[resourceParts.length - 1];\r\n                    this.resourceTokens[rid] = auth.permissionFeed[i]._token;\r\n                }\r\n            }\r\n        }\r\n        \r\n        this.connectionPolicy = connectionPolicy || new AzureDocuments.ConnectionPolicy();\r\n        this.defaultHeaders = {};\r\n        this.defaultHeaders[Constants.HttpHeaders.CacheControl] = \"no-cache\";\r\n        this.defaultHeaders[Constants.HttpHeaders.Version] = Constants.CurrentVersion;\r\n        if (consistencyLevel !== undefined) {\r\n            this.defaultHeaders[Constants.HttpHeaders.ConsistencyLevel] = consistencyLevel;\r\n        }\r\n\r\n        this.defaultHeaders[Constants.HttpHeaders.UserAgent] = Base._getUserAgent();\r\n        \r\n        // overide this for default query params to be added to the url.\r\n        this.defaultUrlParams = \"\";\r\n        \r\n        // Query compatibility mode.\r\n        // Allows to specify compatibility mode used by client when making query requests. Should be removed when\r\n        // application/sql is no longer supported.\r\n        this.queryCompatibilityMode = AzureDocuments.QueryCompatibilityMode.Default;\r\n        this.partitionResolvers = {};\r\n        \r\n        this.partitionKeyDefinitionCache = {};\r\n\r\n        this._globalEndpointManager = new GlobalEndpointManager(this);\r\n    }, \r\n    {\r\n        /** Gets the curent write endpoint for a geo-replicated database account.\r\n         * @memberof DocumentClient\r\n         * @instance\r\n         * @param {function} callback        - The callback function which takes endpoint(string) as an argument.\r\n        */\r\n        getWriteEndpoint: function (callback) {\r\n            this._globalEndpointManager.getWriteEndpoint(function (writeEndpoint) {\r\n                callback(writeEndpoint);\r\n            });\r\n        },\r\n\r\n        /** Gets the curent read endpoint for a geo-replicated database account.\r\n         * @memberof DocumentClient\r\n         * @instance\r\n         * @param {function} callback        - The callback function which takes endpoint(string) as an argument.\r\n        */\r\n        getReadEndpoint: function (callback) {\r\n            this._globalEndpointManager.getReadEndpoint(function (readEndpoint) {\r\n                callback(readEndpoint);\r\n            });\r\n        },\r\n\r\n        /** Send a request for creating a database.\r\n         * <p>\r\n         *  A database manages users, permissions and a set of collections.  <br>\r\n         *  Each Azure DocumentDB Database Account is able to support multiple independent named databases, with the database being the logical container for data. <br>\r\n         *  Each Database consists of one or more collections, each of which in turn contain one or more documents. Since databases are an an administrative resource, the Service Master Key will be required in order to access and successfully complete any action using the User APIs. <br>\r\n         * </p>\r\n         * @memberof DocumentClient\r\n         * @instance\r\n         * @param {Object} body              - A json object that represents The database to be created.\r\n         * @param {string} body.id           - The id of the database.\r\n         * @param {RequestOptions} [options] - The request options.\r\n         * @param {RequestCallback} callback - The callback for the request.\r\n        */\r\n        createDatabase: function (body, options, callback) {\r\n            var optionsCallbackTuple = this.validateOptionsAndCallback(options, callback);\r\n            options = optionsCallbackTuple.options;\r\n            callback = optionsCallbackTuple.callback;\r\n            \r\n            var err = {};\r\n            if (!this.isResourceValid(body, err)) {\r\n                callback(err);\r\n                return;\r\n            }\r\n            \r\n            var path = \"/dbs\";\r\n            this.create(body, path, \"dbs\", undefined, undefined, options, callback);\r\n        },\r\n        \r\n        /**\r\n         * Creates a collection.\r\n         * <p>\r\n         * A collection is a named logical container for documents. <br>\r\n         * A database may contain zero or more named collections and each collection consists of zero or more JSON documents. <br>\r\n         * Being schema-free, the documents in a collection do not need to share the same structure or fields. <br>\r\n         * Since collections are application resources, they can be authorized using either the master key or resource keys. <br>\r\n         * </p>\r\n         * @memberof DocumentClient\r\n         * @instance\r\n         * @param {string} databaseLink                  - The self-link of the database.\r\n         * @param {object} body                          - Represents the body of the collection.\r\n         * @param {string} body.id                       - The id of the collection.\r\n         * @param {IndexingPolicy} body.indexingPolicy   - The indexing policy associated with the collection.\r\n         * @param {number} body.defaultTtl               - The default time to live in seconds for documents in a collection.\r\n         * @param {RequestOptions} [options]             - The request options.\r\n         * @param {RequestCallback} callback             - The callback for the request.\r\n         */\r\n        createCollection: function (databaseLink, body, options, callback) {\r\n            var optionsCallbackTuple = this.validateOptionsAndCallback(options, callback);\r\n            options = optionsCallbackTuple.options;\r\n            callback = optionsCallbackTuple.callback;\r\n            \r\n            var err = {};\r\n            if (!this.isResourceValid(body, err)) {\r\n                callback(err);\r\n                return;\r\n            }\r\n            \r\n            var isNameBased = Base.isLinkNameBased(databaseLink);\r\n            var path = this.getPathFromLink(databaseLink, \"colls\", isNameBased);\r\n            var id = this.getIdFromLink(databaseLink, isNameBased);\r\n            \r\n            this.create(body, path, \"colls\", id, undefined, options, callback);\r\n        },\r\n        \r\n        /**\r\n         * Create a document.\r\n         * <p>\r\n         * There is no set schema for JSON documents. They may contain any number of custom properties as well as an optional list of attachments. <br>\r\n         * A Document is an application resource and can be authorized using the master key or resource keys\r\n         * </p>\r\n         * @memberof DocumentClient\r\n         * @instance\r\n         * @param {string} documentsFeedOrDatabaseLink               - The collection link or database link if using a partition resolver\r\n         * @param {object} body                                      - Represents the body of the document. Can contain any number of user defined properties.\r\n         * @param {string} [body.id]                                 - The id of the document, MUST be unique for each document.\r\n         * @param {number} body.ttl                                  - The time to live in seconds of the document.\r\n         * @param {RequestOptions} [options]                         - The request options.\r\n         * @param {boolean} [options.disableAutomaticIdGeneration]   - Disables the automatic id generation. If id is missing in the body and this option is true, an error will be returned.\r\n         * @param {RequestCallback} callback                         - The callback for the request.\r\n         */\r\n        createDocument: function (documentsFeedOrDatabaseLink, body, options, callback) {\r\n            var partitionResolver = this.partitionResolvers[documentsFeedOrDatabaseLink];\r\n            \r\n            var collectionLink;\r\n            if (partitionResolver === undefined || partitionResolver === null) {\r\n                collectionLink = documentsFeedOrDatabaseLink;\r\n            } else {\r\n                collectionLink = this.resolveCollectionLinkForCreate(partitionResolver, body);\r\n            }\r\n            \r\n            this.createDocumentPrivate(collectionLink, body, options, callback);\r\n        },\r\n        \r\n        /**\r\n         * Create an attachment for the document object.\r\n         * <p>\r\n         * Each document may contain zero or more attachments. Attachments can be of any MIME type - text, image, binary data. <br>\r\n         * These are stored externally in Azure Blob storage. Attachments are automatically deleted when the parent document is deleted.\r\n         * </P>\r\n         * @memberof DocumentClient\r\n         * @instance\r\n         * @param {string} documentLink         - The self-link of the document.\r\n         * @param {Object} body                 - The metadata the defines the attachment media like media, contentType. It can include any other properties as part of the metedata.\r\n         * @param {string} body.contentType     - The MIME contentType of the attachment.\r\n         * @param {string} body.media           - Media link associated with the attachment content.\r\n         * @param {RequestOptions} options      - The request options.\r\n         * @param {RequestCallback} callback    - The callback for the request.\r\n        */\r\n        createAttachment: function (documentLink, body, options, callback) {\r\n            var optionsCallbackTuple = this.validateOptionsAndCallback(options, callback);\r\n            options = optionsCallbackTuple.options;\r\n            callback = optionsCallbackTuple.callback;\r\n            \r\n            var err = {};\r\n            if (!this.isResourceValid(body, err)) {\r\n                callback(err);\r\n                return;\r\n            }\r\n            \r\n            var isNameBased = Base.isLinkNameBased(documentLink);\r\n            var path = this.getPathFromLink(documentLink, \"attachments\", isNameBased);\r\n            var id = this.getIdFromLink(documentLink, isNameBased);\r\n            \r\n            this.create(body, path, \"attachments\", id, undefined, options, callback);\r\n        },\r\n        \r\n        /**\r\n         * Create a database user.\r\n         * @memberof DocumentClient\r\n         * @instance\r\n         * @param {string} databaseLink         - The self-link of the database.\r\n         * @param {object} body                 - Represents the body of the user.\r\n         * @param {string} body.id              - The id of the user.\r\n         * @param {RequestOptions} [options]    - The request options.\r\n         * @param {RequestCallback} callback    - The callback for the request.\r\n         */\r\n        createUser: function (databaseLink, body, options, callback) {\r\n            var optionsCallbackTuple = this.validateOptionsAndCallback(options, callback);\r\n            options = optionsCallbackTuple.options;\r\n            callback = optionsCallbackTuple.callback;\r\n            \r\n            var err = {};\r\n            if (!this.isResourceValid(body, err)) {\r\n                callback(err);\r\n                return;\r\n            }\r\n            \r\n            var isNameBased = Base.isLinkNameBased(databaseLink);\r\n            var path = this.getPathFromLink(databaseLink, \"users\", isNameBased);\r\n            var id = this.getIdFromLink(databaseLink, isNameBased);\r\n            \r\n            this.create(body, path, \"users\", id, undefined, options, callback);\r\n        },\r\n        \r\n        /**\r\n         * Create a permission.\r\n         * <p> A permission represents a per-User Permission to access a specific resource e.g. Document or Collection.  </p>\r\n         * @memberof DocumentClient\r\n         * @instance\r\n         * @param {string} userLink             - The self-link of the user.\r\n         * @param {object} body                 - Represents the body of the permission.\r\n         * @param {string} body.id              - The id of the permission\r\n         * @param {string} body.permissionMode  - The mode of the permission, must be a value of {@link PermissionMode}\r\n         * @param {string} body.resource        - The link of the resource that the permission will be applied to.\r\n         * @param {RequestOptions} [options]    - The request options.\r\n         * @param {RequestCallback} callback    - The callback for the request.\r\n         */\r\n        createPermission: function (userLink, body, options, callback) {\r\n            var optionsCallbackTuple = this.validateOptionsAndCallback(options, callback);\r\n            options = optionsCallbackTuple.options;\r\n            callback = optionsCallbackTuple.callback;\r\n            \r\n            var err = {};\r\n            if (!this.isResourceValid(body, err)) {\r\n                callback(err);\r\n                return;\r\n            }\r\n            \r\n            var isNameBased = Base.isLinkNameBased(userLink);\r\n            var path = this.getPathFromLink(userLink, \"permissions\", isNameBased);\r\n            var id = this.getIdFromLink(userLink, isNameBased);\r\n            \r\n            this.create(body, path, \"permissions\", id, undefined, options, callback);\r\n        },\r\n        \r\n        /**\r\n        * Create a trigger.\r\n        * <p>\r\n        * DocumentDB supports pre and post triggers defined in JavaScript to be executed on creates, updates and deletes. <br>\r\n        * For additional details, refer to the server-side JavaScript API documentation.\r\n        * </p>\r\n        * @memberof DocumentClient\r\n        * @instance\r\n        * @param {string} collectionLink           - The self-link of the collection.\r\n        * @param {object} trigger                  - Represents the body of the trigger.\r\n        * @param {string} trigger.id             - The id of the trigger.\r\n        * @param {string} trigger.triggerType      - The type of the trigger, should be one of the values of {@link TriggerType}.\r\n        * @param {string} trigger.triggerOperation - The trigger operation, should be one of the values of {@link TriggerOperation}.\r\n        * @param {function} trigger.serverScript   - The body of the trigger, it can be passed as stringified too.\r\n        * @param {RequestOptions} [options]        - The request options.\r\n        * @param {RequestCallback} callback        - The callback for the request.\r\n        */\r\n        createTrigger: function (collectionLink, trigger, options, callback) {\r\n            var optionsCallbackTuple = this.validateOptionsAndCallback(options, callback);\r\n            options = optionsCallbackTuple.options;\r\n            callback = optionsCallbackTuple.callback;\r\n            \r\n            if (trigger.serverScript) {\r\n                trigger.body = trigger.serverScript.toString();\r\n            } else if (trigger.body) {\r\n                trigger.body = trigger.body.toString();\r\n            }\r\n            \r\n            var err = {};\r\n            if (!this.isResourceValid(trigger, err)) {\r\n                callback(err);\r\n                return;\r\n            }\r\n            \r\n            var isNameBased = Base.isLinkNameBased(collectionLink);\r\n            var path = this.getPathFromLink(collectionLink, \"triggers\", isNameBased);\r\n            var id = this.getIdFromLink(collectionLink, isNameBased);\r\n            \r\n            this.create(trigger, path, \"triggers\", id, undefined, options, callback);\r\n        },\r\n        \r\n        /**\r\n         * Create a UserDefinedFunction.\r\n         * <p>\r\n         * DocumentDB supports JavaScript UDFs which can be used inside queries, stored procedures and triggers. <br>\r\n         * For additional details, refer to the server-side JavaScript API documentation.\r\n         * </p>\r\n         * @memberof DocumentClient\r\n         * @instance\r\n         * @param {string} collectionLink                - The self-link of the collection.\r\n         * @param {object} udf                           - Represents the body of the userDefinedFunction.\r\n         * @param {string} udf.id                      - The id of the udf.\r\n         * @param {string} udf.userDefinedFunctionType   - The type of the udf, it should be one of the values of {@link UserDefinedFunctionType}\r\n         * @param {function} udf.serverScript            - Represents the body of the udf, it can be passed as stringified too.\r\n         * @param {RequestOptions} [options]             - The request options.\r\n         * @param {RequestCallback} callback             - The callback for the request.\r\n         */\r\n        createUserDefinedFunction: function (collectionLink, udf, options, callback) {\r\n            var optionsCallbackTuple = this.validateOptionsAndCallback(options, callback);\r\n            options = optionsCallbackTuple.options;\r\n            callback = optionsCallbackTuple.callback;\r\n            \r\n            if (udf.serverScript) {\r\n                udf.body = udf.serverScript.toString();\r\n            } else if (udf.body) {\r\n                udf.body = udf.body.toString();\r\n            }\r\n            \r\n            var err = {};\r\n            if (!this.isResourceValid(udf, err)) {\r\n                callback(err);\r\n                return;\r\n            }\r\n            \r\n            var isNameBased = Base.isLinkNameBased(collectionLink);\r\n            var path = this.getPathFromLink(collectionLink, \"udfs\", isNameBased);\r\n            var id = this.getIdFromLink(collectionLink, isNameBased);\r\n            \r\n            this.create(udf, path, \"udfs\", id, undefined, options, callback);\r\n        },\r\n        \r\n        /**\r\n         * Create a StoredProcedure.\r\n         * <p>\r\n         * DocumentDB allows stored procedures to be executed in the storage tier, directly against a document collection. The script <br>\r\n         * gets executed under ACID transactions on the primary storage partition of the specified collection. For additional details, <br>\r\n         * refer to the server-side JavaScript API documentation.\r\n         * </p>\r\n         * @memberof DocumentClient\r\n         * @instance\r\n         * @param {string} collectionLink       - The self-link of the collection.\r\n         * @param {object} sproc                - Represents the body of the stored procedure.\r\n         * @param {string} sproc.id           - The id of the stored procedure.\r\n         * @param {function} sproc.serverScript - The body of the stored procedure, it can be passed as stringified too.\r\n         * @param {RequestOptions} [options]    - The request options.\r\n         * @param {RequestCallback} callback    - The callback for the request.\r\n         */\r\n        createStoredProcedure: function (collectionLink, sproc, options, callback) {\r\n            var optionsCallbackTuple = this.validateOptionsAndCallback(options, callback);\r\n            options = optionsCallbackTuple.options;\r\n            callback = optionsCallbackTuple.callback;\r\n            \r\n            if (sproc.serverScript) {\r\n                sproc.body = sproc.serverScript.toString();\r\n            } else if (sproc.body) {\r\n                sproc.body = sproc.body.toString();\r\n            }\r\n            \r\n            var err = {};\r\n            if (!this.isResourceValid(sproc, err)) {\r\n                callback(err);\r\n                return;\r\n            }\r\n            \r\n            var isNameBased = Base.isLinkNameBased(collectionLink);\r\n            var path = this.getPathFromLink(collectionLink, \"sprocs\", isNameBased);\r\n            var id = this.getIdFromLink(collectionLink, isNameBased);\r\n            \r\n            this.create(sproc, path, \"sprocs\", id, undefined, options, callback);\r\n        },\r\n        \r\n        /**\r\n         * Create an attachment for the document object.\r\n         * @memberof DocumentClient\r\n         * @instance\r\n         * @param {string} documentLink             - The self-link of the document.\r\n         * @param {stream.Readable} readableStream  - the stream that represents the media itself that needs to be uploaded.\r\n         * @param {MediaOptions} [options]          - The request options.\r\n         * @param {RequestCallback} callback        - The callback for the request.\r\n        */\r\n        createAttachmentAndUploadMedia: function (documentLink, readableStream, options, callback) {\r\n            var optionsCallbackTuple = this.validateOptionsAndCallback(options, callback);\r\n            options = optionsCallbackTuple.options;\r\n            callback = optionsCallbackTuple.callback;\r\n            \r\n            var initialHeaders = Base.extend({}, this.defaultHeaders);\r\n            \r\n            // Add required headers slug and content-type.\r\n            if (options.slug) {\r\n                initialHeaders[Constants.HttpHeaders.Slug] = options.slug;\r\n            }\r\n            \r\n            if (options.contentType) {\r\n                initialHeaders[Constants.HttpHeaders.ContentType] = options.contentType;\r\n            } else {\r\n                initialHeaders[Constants.HttpHeaders.ContentType] = Constants.MediaTypes.OctetStream;\r\n            }\r\n            \r\n            var isNameBased = Base.isLinkNameBased(documentLink);\r\n            var path = this.getPathFromLink(documentLink, \"attachments\", isNameBased);\r\n            var id = this.getIdFromLink(documentLink, isNameBased);\r\n            \r\n            this.create(readableStream, path, \"attachments\", id, initialHeaders, options, callback);\r\n        },\r\n        \r\n        /** Reads a database.\r\n         * @memberof DocumentClient\r\n         * @instance\r\n         * @param {string} databaseLink         - The self-link of the database.\r\n         * @param {RequestOptions} [options]    - The request options.\r\n         * @param {RequestCallback} callback    - The callback for the request.\r\n        */\r\n        readDatabase: function (databaseLink, options, callback) {\r\n            var optionsCallbackTuple = this.validateOptionsAndCallback(options, callback);\r\n            options = optionsCallbackTuple.options;\r\n            callback = optionsCallbackTuple.callback;\r\n            \r\n            var isNameBased = Base.isLinkNameBased(databaseLink);\r\n            var path = this.getPathFromLink(databaseLink, \"\", isNameBased);\r\n            var id = this.getIdFromLink(databaseLink, isNameBased);\r\n            \r\n            this.read(path, \"dbs\", id, undefined, options, callback);\r\n        },\r\n        \r\n        /**\r\n         * Reads a collection.\r\n         * @memberof DocumentClient\r\n         * @instance\r\n         * @param {string} collectionLink       - The self-link of the collection.\r\n         * @param {RequestOptions} [options]    - The request options.\r\n         * @param {RequestCallback} callback    - The callback for the request.\r\n         */\r\n        readCollection: function (collectionLink, options, callback) {\r\n            var optionsCallbackTuple = this.validateOptionsAndCallback(options, callback);\r\n            options = optionsCallbackTuple.options;\r\n            callback = optionsCallbackTuple.callback;\r\n            \r\n            var isNameBased = Base.isLinkNameBased(collectionLink);\r\n            var path = this.getPathFromLink(collectionLink, \"\", isNameBased);\r\n            var id = this.getIdFromLink(collectionLink, isNameBased);\r\n            \r\n            var that = this;\r\n            this.read(path, \"colls\", id, undefined, options, function (err, collection, headers) {\r\n                if (err) return callback(err, collection, headers);\r\n                that.partitionKeyDefinitionCache[collectionLink] = collection.partitionKey;\r\n                callback(err, collection, headers);\r\n            });\r\n        },\r\n        \r\n        /**\r\n         * Reads a document.\r\n         * @memberof DocumentClient\r\n         * @instance\r\n         * @param {string} documentLink         - The self-link of the document.\r\n         * @param {RequestOptions} [options]    - The request options.\r\n         * @param {RequestCallback} callback    - The callback for the request.\r\n         */\r\n        readDocument: function (documentLink, options, callback) {\r\n            var optionsCallbackTuple = this.validateOptionsAndCallback(options, callback);\r\n            options = optionsCallbackTuple.options;\r\n            callback = optionsCallbackTuple.callback;\r\n            \r\n            var isNameBased = Base.isLinkNameBased(documentLink);\r\n            var path = this.getPathFromLink(documentLink, \"\", isNameBased);\r\n            var id = this.getIdFromLink(documentLink, isNameBased);\r\n            \r\n            this.read(path, \"docs\", id, undefined, options, callback);\r\n        },\r\n        \r\n        /**\r\n         * Reads an Attachment object.\r\n         * @memberof DocumentClient\r\n         * @instance\r\n         * @param {string} attachmentLink    - The self-link of the attachment.\r\n         * @param {RequestOptions} [options] - The request options.\r\n         * @param {RequestCallback} callback - The callback for the request.\r\n        */\r\n        readAttachment: function (attachmentLink, options, callback) {\r\n            var optionsCallbackTuple = this.validateOptionsAndCallback(options, callback);\r\n            options = optionsCallbackTuple.options;\r\n            callback = optionsCallbackTuple.callback;\r\n            \r\n            var isNameBased = Base.isLinkNameBased(attachmentLink);\r\n            var path = this.getPathFromLink(attachmentLink, \"\", isNameBased);\r\n            var id = this.getIdFromLink(attachmentLink, isNameBased);\r\n            \r\n            this.read(path, \"attachments\", id, undefined, options, callback);\r\n        },\r\n        \r\n        /**\r\n         * Reads a user.\r\n         * @memberof DocumentClient\r\n         * @instance\r\n         * @param {string} userLink          - The self-link of the user.\r\n         * @param {RequestOptions} [options] - The request options.\r\n         * @param {RequestCallback} callback - The callback for the request.\r\n         */\r\n        readUser: function (userLink, options, callback) {\r\n            var optionsCallbackTuple = this.validateOptionsAndCallback(options, callback);\r\n            options = optionsCallbackTuple.options;\r\n            callback = optionsCallbackTuple.callback;\r\n            \r\n            var isNameBased = Base.isLinkNameBased(userLink);\r\n            var path = this.getPathFromLink(userLink, \"\", isNameBased);\r\n            var id = this.getIdFromLink(userLink, isNameBased);\r\n            \r\n            this.read(path, \"users\", id, undefined, options, callback);\r\n        },\r\n        \r\n        /**\r\n         * Reads a permission.\r\n         * @memberof DocumentClient\r\n         * @instance\r\n         * @param {string} permissionLink    - The self-link of the permission.\r\n         * @param {RequestOptions} [options] - The request options.\r\n         * @param {RequestCallback} callback - The callback for the request.\r\n         */\r\n        readPermission: function (permissionLink, options, callback) {\r\n            var optionsCallbackTuple = this.validateOptionsAndCallback(options, callback);\r\n            options = optionsCallbackTuple.options;\r\n            callback = optionsCallbackTuple.callback;\r\n            \r\n            var isNameBased = Base.isLinkNameBased(permissionLink);\r\n            var path = this.getPathFromLink(permissionLink, \"\", isNameBased);\r\n            var id = this.getIdFromLink(permissionLink, isNameBased);\r\n            \r\n            this.read(path, \"permissions\", id, undefined, options, callback);\r\n        },\r\n        \r\n        /**\r\n         * Reads a trigger object.\r\n         * @memberof DocumentClient\r\n         * @instance\r\n         * @param {string} triggerLink       - The self-link of the trigger.\r\n         * @param {RequestOptions} [options] - The request options.\r\n         * @param {RequestCallback} callback - The callback for the request.\r\n         */\r\n        readTrigger: function (triggerLink, options, callback) {\r\n            var optionsCallbackTuple = this.validateOptionsAndCallback(options, callback);\r\n            options = optionsCallbackTuple.options;\r\n            callback = optionsCallbackTuple.callback;\r\n            \r\n            var resourceInfo = Base.parseLink(triggerLink);\r\n            \r\n            var isNameBased = Base.isLinkNameBased(triggerLink);\r\n            var path = this.getPathFromLink(triggerLink, \"\", isNameBased);\r\n            var id = this.getIdFromLink(triggerLink, isNameBased);\r\n            \r\n            this.read(path, \"triggers\", id, undefined, options, callback);\r\n        },\r\n        \r\n        /**\r\n         * Reads a udf object.\r\n         * @memberof DocumentClient\r\n         * @instance\r\n         * @param {string} udfLink           - The self-link of the user defined function.\r\n         * @param {RequestOptions} [options] - The request options.\r\n         * @param {RequestCallback} callback - The callback for the request.\r\n         */\r\n        readUserDefinedFunction: function (udfLink, options, callback) {\r\n            var optionsCallbackTuple = this.validateOptionsAndCallback(options, callback);\r\n            options = optionsCallbackTuple.options;\r\n            callback = optionsCallbackTuple.callback;\r\n            \r\n            var isNameBased = Base.isLinkNameBased(udfLink);\r\n            var path = this.getPathFromLink(udfLink, \"\", isNameBased);\r\n            var id = this.getIdFromLink(udfLink, isNameBased);\r\n            \r\n            this.read(path, \"udfs\", id, undefined, options, callback);\r\n        },\r\n        \r\n        /**\r\n         * Reads a StoredProcedure object.\r\n         * @memberof DocumentClient\r\n         * @instance\r\n         * @param {string} sprocLink         - The self-link of the stored procedure.\r\n         * @param {RequestOptions} [options] - The request options.\r\n         * @param {RequestCallback} callback - The callback for the request.\r\n         */\r\n        readStoredProcedure: function (sprocLink, options, callback) {\r\n            var optionsCallbackTuple = this.validateOptionsAndCallback(options, callback);\r\n            options = optionsCallbackTuple.options;\r\n            callback = optionsCallbackTuple.callback;\r\n            \r\n            var isNameBased = Base.isLinkNameBased(sprocLink);\r\n            var path = this.getPathFromLink(sprocLink, \"\", isNameBased);\r\n            var id = this.getIdFromLink(sprocLink, isNameBased);\r\n            \r\n            this.read(path, \"sprocs\", id, undefined, options, callback);\r\n        },\r\n        \r\n        /**\r\n         * Reads a conflict.\r\n         * @memberof DocumentClient\r\n         * @instance\r\n         * @param {string} conflictLink      - The self-link of the conflict.\r\n         * @param {RequestOptions} [options] - The request options.\r\n         * @param {RequestCallback} callback - The callback for the request.\r\n         */\r\n        readConflict: function (conflictLink, options, callback) {\r\n            var optionsCallbackTuple = this.validateOptionsAndCallback(options, callback);\r\n            options = optionsCallbackTuple.options;\r\n            callback = optionsCallbackTuple.callback;\r\n            \r\n            var isNameBased = Base.isLinkNameBased(conflictLink);\r\n            var path = this.getPathFromLink(conflictLink, \"\", isNameBased);\r\n            var id = this.getIdFromLink(conflictLink, isNameBased);\r\n            \r\n            this.read(path, \"conflicts\", id, undefined, options, callback);\r\n        },\r\n        \r\n        /** Lists all databases.\r\n         * @memberof DocumentClient\r\n         * @instance\r\n         * @param {FeedOptions} [options] - The feed options.\r\n         * @returns {QueryIterator}       - An instance of queryIterator to handle reading feed.\r\n        */\r\n        readDatabases: function (options) {\r\n            return this.queryDatabases(undefined, options);\r\n        },\r\n        \r\n        /**\r\n         * Get all collections in this database.\r\n         * @memberof DocumentClient\r\n         * @instance\r\n         * @param {string} databaseLink   - The self-link of the database.\r\n         * @param {FeedOptions} [options] - The feed options.\r\n         * @returns {QueryIterator}       - An instance of queryIterator to handle reading feed.\r\n         */\r\n        readCollections: function (databaseLink, options) {\r\n            return this.queryCollections(databaseLink, undefined, options);\r\n        },\r\n        \r\n        /**\r\n         * Get all documents in this collection.\r\n         * @memberof DocumentClient\r\n         * @instance\r\n         * @param {string} collectionLink - The self-link of the collection.\r\n         * @param {FeedOptions} [options] - The feed options.\r\n         * @returns {QueryIterator}       - An instance of queryIterator to handle reading feed.\r\n         */\r\n        readDocuments: function (collectionLink, options) {\r\n            return this.queryDocuments(collectionLink, undefined, options);\r\n        },\r\n\r\n        /**\r\n         * Get all Partition key Ranges in this collection.\r\n         * @memberof DocumentClient\r\n         * @instance\r\n         * @param {string} collectionLink - The self-link of the collection.\r\n         * @param {FeedOptions} [options] - The feed options.\r\n         * @returns {QueryIterator}       - An instance of queryIterator to handle reading feed.\r\n         * @ignore\r\n         */\r\n        readPartitionKeyRanges: function (collectionLink, options) {\r\n            return this.queryPartitionKeyRanges(collectionLink, undefined, options);\r\n        },\r\n        \r\n        /**\r\n        * Get all attachments for this document.\r\n        * @memberof DocumentClient\r\n        * @instance\r\n        * @param {string} documentLink   - The self-link of the document.\r\n        * @param {FeedOptions} [options] - The feed options.\r\n        * @returns {QueryIterator}       - An instance of queryIterator to handle reading feed.\r\n       */\r\n        readAttachments: function (documentLink, options) {\r\n            return this.queryAttachments(documentLink, undefined, options);\r\n        },\r\n        \r\n        /**\r\n         * Get all users in this database.\r\n         * @memberof DocumentClient\r\n         * @instance\r\n         * @param {string} databaseLink       - The self-link of the database.\r\n         * @param {FeedOptions} [feedOptions] - The feed options.\r\n         * @returns {QueryIterator}           - An instance of queryIterator to handle reading feed.\r\n         */\r\n        readUsers: function (databaseLink, options) {\r\n            return this.queryUsers(databaseLink, undefined, options);\r\n        },\r\n        \r\n        /**\r\n         * Get all permissions for this user.\r\n         * @memberof DocumentClient\r\n         * @instance\r\n         * @param {string} userLink           - The self-link of the user.\r\n         * @param {FeedOptions} [feedOptions] - The feed options.\r\n         * @returns {QueryIterator}           - An instance of queryIterator to handle reading feed.\r\n         */\r\n        readPermissions: function (userLink, options) {\r\n            return this.queryPermissions(userLink, undefined, options);\r\n        },\r\n        \r\n        /**\r\n         * Get all triggers in this collection.\r\n         * @memberof DocumentClient\r\n         * @instance\r\n         * @param {string} collectionLink   - The self-link of the collection.\r\n         * @param {FeedOptions} [options]   - The feed options.\r\n         * @returns {QueryIterator}         - An instance of queryIterator to handle reading feed.\r\n         */\r\n        readTriggers: function (collectionLink, options) {\r\n            return this.queryTriggers(collectionLink, undefined, options);\r\n        },\r\n        \r\n        /**\r\n         * Get all UserDefinedFunctions in this collection.\r\n         * @memberof DocumentClient\r\n         * @instance\r\n         * @param {string} collectionLink - The self-link of the collection.\r\n         * @param {FeedOptions} [options] - The feed options.\r\n         * @returns {QueryIterator}       - An instance of queryIterator to handle reading feed.\r\n         */\r\n        readUserDefinedFunctions: function (collectionLink, options) {\r\n            return this.queryUserDefinedFunctions(collectionLink, undefined, options);\r\n        },\r\n        \r\n        /**\r\n         * Get all StoredProcedures in this collection.\r\n         * @memberof DocumentClient\r\n         * @instance\r\n         * @param {string} collectionLink - The self-link of the collection.\r\n         * @param {FeedOptions} [options] - The feed options.\r\n         * @returns {QueryIterator}       - An instance of queryIterator to handle reading feed.\r\n         */\r\n        readStoredProcedures: function (collectionLink, options) {\r\n            return this.queryStoredProcedures(collectionLink, undefined, options);\r\n        },\r\n        \r\n        /**\r\n         * Get all conflicts in this collection.\r\n         * @memberof DocumentClient\r\n         * @instance\r\n         * @param {string} collectionLink - The self-link of the collection.\r\n         * @param {FeedOptions} [options] - The feed options.\r\n         * @returns {QueryIterator}       - An instance of QueryIterator to handle reading feed.\r\n         */\r\n        readConflicts: function (collectionLink, options) {\r\n            return this.queryConflicts(collectionLink, undefined, options);\r\n        },\r\n        \r\n        /** Lists all databases that satisfy a query.\r\n         * @memberof DocumentClient\r\n         * @instance\r\n         * @param {SqlQuerySpec | string} query - A SQL query.\r\n         * @param {FeedOptions} [options]       - The feed options.\r\n         * @returns {QueryIterator}             - An instance of QueryIterator to handle reading feed.\r\n        */\r\n        queryDatabases: function (query, options) {\r\n            var that = this;\r\n            return new QueryIterator(this, query, options, function (options, callback) {\r\n                that.queryFeed.call(that,\r\n                        that,\r\n                        \"/dbs\",\r\n                        \"dbs\",\r\n                        \"\",\r\n                        function (result) { return result.Databases; },\r\n                        function (parent, body) { return body; },\r\n                        query,\r\n                        options,\r\n                        callback);\r\n            });\r\n        },\r\n        \r\n        /**\r\n         * Query the collections for the database.\r\n         * @memberof DocumentClient\r\n         * @instance\r\n         * @param {string} databaseLink           - The self-link of the database.\r\n         * @param {SqlQuerySpec | string} query   - A SQL query.\r\n         * @param {FeedOptions} [options]         - Represents the feed options.\r\n         * @returns {QueryIterator}               - An instance of queryIterator to handle reading feed.\r\n         */\r\n        queryCollections: function (databaseLink, query, options) {\r\n            var that = this;\r\n            \r\n            var isNameBased = Base.isLinkNameBased(databaseLink);\r\n            var path = this.getPathFromLink(databaseLink, \"colls\", isNameBased);\r\n            var id = this.getIdFromLink(databaseLink, isNameBased);\r\n            \r\n            return new QueryIterator(this, query, options, function (options, callback) {\r\n                that.queryFeed.call(that,\r\n                    that,\r\n                    path,\r\n                    \"colls\",\r\n                    id,\r\n                    function (result) { return result.DocumentCollections; },\r\n                    function (parent, body) { return body; },\r\n                    query,\r\n                    options,\r\n                    callback);\r\n            });\r\n        },\r\n        \r\n        /**\r\n         * Query the documents for the collection.\r\n         * @memberof DocumentClient\r\n         * @instance\r\n         * @param {string} documentsFeedOrDatabaseLink          - The collection link or database link if using a partition resolver\r\n         * @param {SqlQuerySpec | string} query                 - A SQL query.\r\n         * @param {FeedOptions} [options]                       - Represents the feed options.\r\n         * @param {object} [options.partitionKey]               - Optional partition key to be used with the partition resolver\r\n         * @returns {QueryIterator}                             - An instance of queryIterator to handle reading feed.\r\n         */\r\n        queryDocuments: function (documentsFeedOrDatabaseLink, query, options) {\r\n            var partitionResolver = this.partitionResolvers[documentsFeedOrDatabaseLink];\r\n            var collectionLinks;\r\n            if (partitionResolver === undefined || partitionResolver === null) {\r\n                collectionLinks = [documentsFeedOrDatabaseLink];\r\n            } else {\r\n                collectionLinks = partitionResolver.resolveForRead(options && options.partitionKey);\r\n            }\r\n            \r\n            return this.queryDocumentsPrivate(collectionLinks, query, options);\r\n        },\r\n\r\n        /**\r\n         * Query the partition key ranges\r\n         * @memberof DocumentClient\r\n         * @instance\r\n         * @param {string} databaseLink           - The self-link of the database.\r\n         * @param {SqlQuerySpec | string} query   - A SQL query.\r\n         * @param {FeedOptions} [options]         - Represents the feed options.\r\n         * @returns {QueryIterator}               - An instance of queryIterator to handle reading feed.\r\n         * @ignore\r\n         */\r\n        queryPartitionKeyRanges: function (collectionLink, query, options) {\r\n            var that = this;\r\n\r\n            var isNameBased = Base.isLinkNameBased(collectionLink);\r\n            var path = this.getPathFromLink(collectionLink, \"pkranges\", isNameBased);\r\n            var id = this.getIdFromLink(collectionLink, isNameBased);\r\n\r\n            return new QueryIterator(this, query, options, function (options, callback) {\r\n                that.queryFeed.call(that,\r\n                    that,\r\n                    path,\r\n                    \"pkranges\",\r\n                    id,\r\n                    function (result) { return result.PartitionKeyRanges; },\r\n                    function (parent, body) { return body; },\r\n                    query,\r\n                    options,\r\n                    callback);\r\n            });\r\n        },\r\n\r\n\r\n        /**\r\n         * Query the attachments for the document.\r\n         * @memberof DocumentClient\r\n         * @instance\r\n         * @param {string} documentLink           - The self-link of the document.\r\n         * @param {SqlQuerySpec | string} query   - A SQL query.\r\n         * @param {FeedOptions} [options]         - Represents the feed options.\r\n         * @returns {QueryIterator}               - An instance of queryIterator to handle reading feed.\r\n        */\r\n        queryAttachments: function (documentLink, query, options) {\r\n            var that = this;\r\n            \r\n            var isNameBased = Base.isLinkNameBased(documentLink);\r\n            var path = this.getPathFromLink(documentLink, \"attachments\", isNameBased);\r\n            var id = this.getIdFromLink(documentLink, isNameBased);\r\n            \r\n            return new QueryIterator(this, query, options, function (options, callback) {\r\n                that.queryFeed.call(that,\r\n                        that,\r\n                        path,\r\n                        \"attachments\",\r\n                        id,\r\n                        function (result) { return result.Attachments; },\r\n                        function (parent, body) { return body; },\r\n                        query,\r\n                        options,\r\n                        callback);\r\n            });\r\n        },\r\n        \r\n        /**\r\n         * Query the users for the database.\r\n         * @memberof DocumentClient\r\n         * @instance\r\n         * @param {string} databaseLink           - The self-link of the database.\r\n         * @param {SqlQuerySpec | string} query   - A SQL query.\r\n         * @param {FeedOptions} [options]         - Represents the feed options.\r\n         * @returns {QueryIterator}               - An instance of queryIterator to handle reading feed.\r\n         */\r\n        queryUsers: function (databaseLink, query, options) {\r\n            var that = this;\r\n            \r\n            var isNameBased = Base.isLinkNameBased(databaseLink);\r\n            var path = this.getPathFromLink(databaseLink, \"users\", isNameBased);\r\n            var id = this.getIdFromLink(databaseLink, isNameBased);\r\n            \r\n            return new QueryIterator(this, query, options, function (options, callback) {\r\n                that.queryFeed.call(that,\r\n                    that,\r\n                    path,\r\n                    \"users\",\r\n                    id,\r\n                    function (result) { return result.Users; },\r\n                    function (parent, body) { return body; },\r\n                    query,\r\n                    options,\r\n                    callback);\r\n            });\r\n        },\r\n        \r\n        /**\r\n         * Query the permission for the user.\r\n         * @memberof DocumentClient\r\n         * @instance\r\n         * @param {string} userLink               - The self-link of the user.\r\n         * @param {SqlQuerySpec | string} query   - A SQL query.\r\n         * @param {FeedOptions} [options]         - Represents the feed options.\r\n         * @returns {QueryIterator}               - An instance of queryIterator to handle reading feed.\r\n         */\r\n        queryPermissions: function (userLink, query, options) {\r\n            var that = this;\r\n            \r\n            var isNameBased = Base.isLinkNameBased(userLink);\r\n            var path = this.getPathFromLink(userLink, \"permissions\", isNameBased);\r\n            var id = this.getIdFromLink(userLink, isNameBased);\r\n            \r\n            return new QueryIterator(this, query, options, function (options, callback) {\r\n                that.queryFeed.call(that,\r\n                    that,\r\n                    path,\r\n                    \"permissions\",\r\n                    id,\r\n                    function (result) { return result.Permissions; },\r\n                    function (parent, body) { return body; },\r\n                    query,\r\n                    options,\r\n                    callback);\r\n            });\r\n        },\r\n        \r\n        /**\r\n         * Query the triggers for the collection.\r\n         * @memberof DocumentClient\r\n         * @instance\r\n         * @param {string} collectionLink         - The self-link of the collection.\r\n         * @param {SqlQuerySpec | string} query   - A SQL query.\r\n         * @param {FeedOptions} [options]         - Represents the feed options.\r\n         * @returns {QueryIterator}               - An instance of queryIterator to handle reading feed.\r\n         */\r\n        queryTriggers: function (collectionLink, query, options) {\r\n            var that = this;\r\n            \r\n            var isNameBased = Base.isLinkNameBased(collectionLink);\r\n            var path = this.getPathFromLink(collectionLink, \"triggers\", isNameBased);\r\n            var id = this.getIdFromLink(collectionLink, isNameBased);\r\n            \r\n            return new QueryIterator(this, query, options, function (options, callback) {\r\n                that.queryFeed.call(that,\r\n                    that,\r\n                    path,\r\n                    \"triggers\",\r\n                    id,\r\n                    function (result) { return result.Triggers; },\r\n                    function (parent, body) { return body; },\r\n                    query,\r\n                    options,\r\n                    callback);\r\n            });\r\n        },\r\n        \r\n        /**\r\n         * Query the user defined functions for the collection.\r\n         * @memberof DocumentClient\r\n         * @instance\r\n         * @param {string} collectionLink         - The self-link of the collection.\r\n         * @param {SqlQuerySpec | string} query   - A SQL query.\r\n         * @param {FeedOptions} [options]         - Represents the feed options.\r\n         * @returns {QueryIterator}               - An instance of queryIterator to handle reading feed.\r\n         */\r\n        queryUserDefinedFunctions: function (collectionLink, query, options) {\r\n            var that = this;\r\n            \r\n            var isNameBased = Base.isLinkNameBased(collectionLink);\r\n            var path = this.getPathFromLink(collectionLink, \"udfs\", isNameBased);\r\n            var id = this.getIdFromLink(collectionLink, isNameBased);\r\n            \r\n            return new QueryIterator(this, query, options, function (options, callback) {\r\n                that.queryFeed.call(that,\r\n                    that,\r\n                    path,\r\n                    \"udfs\",\r\n                    id,\r\n                    function (result) { return result.UserDefinedFunctions; },\r\n                    function (parent, body) { return body; },\r\n                    query,\r\n                    options,\r\n                    callback);\r\n            });\r\n        },\r\n        \r\n        /**\r\n         * Query the storedProcedures for the collection.\r\n         * @memberof DocumentClient\r\n         * @instance\r\n         * @param {string} collectionLink         - The self-link of the collection.\r\n         * @param {SqlQuerySpec | string} query   - A SQL query.\r\n         * @param {FeedOptions} [options]         - Represents the feed options.\r\n         * @returns {QueryIterator}               - An instance of queryIterator to handle reading feed.\r\n         */\r\n        queryStoredProcedures: function (collectionLink, query, options) {\r\n            var that = this;\r\n            \r\n            var isNameBased = Base.isLinkNameBased(collectionLink);\r\n            var path = this.getPathFromLink(collectionLink, \"sprocs\", isNameBased);\r\n            var id = this.getIdFromLink(collectionLink, isNameBased);\r\n            \r\n            return new QueryIterator(this, query, options, function (options, callback) {\r\n                that.queryFeed.call(that,\r\n                    that,\r\n                    path,\r\n                    \"sprocs\",\r\n                    id,\r\n                    function (result) { return result.StoredProcedures; },\r\n                    function (parent, body) { return body; },\r\n                    query,\r\n                    options,\r\n                    callback);\r\n            });\r\n        },\r\n        \r\n        /**\r\n         * Query the conflicts for the collection.\r\n         * @memberof DocumentClient\r\n         * @instance\r\n         * @param {string} collectionLink         - The self-link of the collection.\r\n         * @param {SqlQuerySpec | string} query   - A SQL query.\r\n         * @param {FeedOptions} [options]         - Represents the feed options.\r\n         * @returns {QueryIterator}               - An instance of queryIterator to handle reading feed.\r\n         */\r\n        queryConflicts: function (collectionLink, query, options) {\r\n            var that = this;\r\n            \r\n            var isNameBased = Base.isLinkNameBased(collectionLink);\r\n            var path = this.getPathFromLink(collectionLink, \"conflicts\", isNameBased);\r\n            var id = this.getIdFromLink(collectionLink, isNameBased);\r\n            \r\n            return new QueryIterator(this, query, options, function (options, callback) {\r\n                that.queryFeed.call(that,\r\n                    that,\r\n                    path,\r\n                    \"conflicts\",\r\n                    id,\r\n                    function (result) { return result.Conflicts; },\r\n                    function (parent, body) { return body; },\r\n                    query,\r\n                    options,\r\n                    callback);\r\n            });\r\n        },\r\n        \r\n        /**\r\n         * Delete the database object.\r\n         * @memberof DocumentClient\r\n         * @instance\r\n         * @param {string} databaseLink         - The self-link of the database.\r\n         * @param {RequestOptions} [options]    - The request options.\r\n         * @param {RequestCallback} callback    - The callback for the request.\r\n        */\r\n        deleteDatabase: function (databaseLink, options, callback) {\r\n            var optionsCallbackTuple = this.validateOptionsAndCallback(options, callback);\r\n            options = optionsCallbackTuple.options;\r\n            callback = optionsCallbackTuple.callback;\r\n            \r\n            var isNameBased = Base.isLinkNameBased(databaseLink);\r\n            var path = this.getPathFromLink(databaseLink, \"\", isNameBased);\r\n            var id = this.getIdFromLink(databaseLink, isNameBased);\r\n            this.deleteResource(path, \"dbs\", id, undefined, options, callback);\r\n        },\r\n        \r\n        /**\r\n         * Delete the collection object.\r\n         * @memberof DocumentClient\r\n         * @instance\r\n         * @param {string} collectionLink    - The self-link of the collection.\r\n         * @param {RequestOptions} [options] - The request options.\r\n         * @param {RequestCallback} callback - The callback for the request.\r\n        */\r\n        deleteCollection: function (collectionLink, options, callback) {\r\n            var optionsCallbackTuple = this.validateOptionsAndCallback(options, callback);\r\n            options = optionsCallbackTuple.options;\r\n            callback = optionsCallbackTuple.callback;\r\n            \r\n            var isNameBased = Base.isLinkNameBased(collectionLink);\r\n            var path = this.getPathFromLink(collectionLink, \"\", isNameBased);\r\n            var id = this.getIdFromLink(collectionLink, isNameBased);\r\n            \r\n            this.deleteResource(path, \"colls\", id, undefined, options, callback);\r\n        },\r\n        \r\n        /**\r\n         * Delete the document object.\r\n         * @memberof DocumentClient\r\n         * @instance\r\n         * @param {string} documentLink      - The self-link of the document.\r\n         * @param {RequestOptions} [options] - The request options.\r\n         * @param {RequestCallback} callback - The callback for the request.\r\n        */\r\n        deleteDocument: function (documentLink, options, callback) {\r\n            var optionsCallbackTuple = this.validateOptionsAndCallback(options, callback);\r\n            options = optionsCallbackTuple.options;\r\n            callback = optionsCallbackTuple.callback;\r\n            \r\n            var isNameBased = Base.isLinkNameBased(documentLink);\r\n            var path = this.getPathFromLink(documentLink, \"\", isNameBased);\r\n            var id = this.getIdFromLink(documentLink, isNameBased);\r\n            \r\n            this.deleteResource(path, \"docs\", id, undefined, options, callback);\r\n        },\r\n        \r\n        /**\r\n         * Delete the attachment object.\r\n         * @memberof DocumentClient\r\n         * @instance\r\n         * @param {string} attachmentLink    - The self-link of the attachment.\r\n         * @param {RequestOptions} [options] - The request options.\r\n         * @param {RequestCallback} callback - The callback for the request.\r\n         */\r\n        deleteAttachment: function (attachmentLink, options, callback) {\r\n            var optionsCallbackTuple = this.validateOptionsAndCallback(options, callback);\r\n            options = optionsCallbackTuple.options;\r\n            callback = optionsCallbackTuple.callback;\r\n            \r\n            var isNameBased = Base.isLinkNameBased(attachmentLink);\r\n            var path = this.getPathFromLink(attachmentLink, \"\", isNameBased);\r\n            var id = this.getIdFromLink(attachmentLink, isNameBased);\r\n            \r\n            this.deleteResource(path, \"attachments\", id, undefined, options, callback);\r\n        },\r\n        \r\n        /**\r\n         * Delete the user object.\r\n         * @memberof DocumentClient\r\n         * @instance\r\n         * @param {string} userLink          - The self-link of the user.\r\n         * @param {RequestOptions} [options] - The request options.\r\n         * @param {RequestCallback} callback - The callback for the request.\r\n        */\r\n        deleteUser: function (userLink, options, callback) {\r\n            var optionsCallbackTuple = this.validateOptionsAndCallback(options, callback);\r\n            options = optionsCallbackTuple.options;\r\n            callback = optionsCallbackTuple.callback;\r\n            \r\n            var isNameBased = Base.isLinkNameBased(userLink);\r\n            var path = this.getPathFromLink(userLink, \"\", isNameBased);\r\n            var id = this.getIdFromLink(userLink, isNameBased);\r\n            \r\n            this.deleteResource(path, \"users\", id, undefined, options, callback);\r\n        },\r\n        \r\n        /**\r\n         * Delete the permission object.\r\n         * @memberof DocumentClient\r\n         * @instance\r\n         * @param {string} permissionLink    - The self-link of the permission.\r\n         * @param {RequestOptions} [options] - The request options.\r\n         * @param {RequestCallback} callback - The callback for the request.\r\n        */\r\n        deletePermission: function (permissionLink, options, callback) {\r\n            var optionsCallbackTuple = this.validateOptionsAndCallback(options, callback);\r\n            options = optionsCallbackTuple.options;\r\n            callback = optionsCallbackTuple.callback;\r\n            \r\n            var isNameBased = Base.isLinkNameBased(permissionLink);\r\n            var path = this.getPathFromLink(permissionLink, \"\", isNameBased);\r\n            var id = this.getIdFromLink(permissionLink, isNameBased);\r\n            \r\n            this.deleteResource(path, \"permissions\", id, undefined, options, callback);\r\n        },\r\n        \r\n        /**\r\n         * Delete the trigger object.\r\n         * @memberof DocumentClient\r\n         * @instance\r\n         * @param {string} triggerLink       - The self-link of the trigger.\r\n         * @param {RequestOptions} [options] - The request options.\r\n         * @param {RequestCallback} callback - The callback for the request.\r\n        */\r\n        deleteTrigger: function (triggerLink, options, callback) {\r\n            var optionsCallbackTuple = this.validateOptionsAndCallback(options, callback);\r\n            options = optionsCallbackTuple.options;\r\n            callback = optionsCallbackTuple.callback;\r\n            \r\n            var isNameBased = Base.isLinkNameBased(triggerLink);\r\n            var path = this.getPathFromLink(triggerLink, \"\", isNameBased);\r\n            var id = this.getIdFromLink(triggerLink, isNameBased);\r\n            \r\n            this.deleteResource(path, \"triggers\", id, undefined, options, callback);\r\n        },\r\n        \r\n        /**\r\n         * Delete the UserDefinedFunction object.\r\n         * @memberof DocumentClient\r\n         * @instance\r\n         * @param {string} udfLink           - The self-link of the user defined function.\r\n         * @param {RequestOptions} [options] - The request options.\r\n         * @param {RequestCallback} callback - The callback for the request.\r\n        */\r\n        deleteUserDefinedFunction: function (udfLink, options, callback) {\r\n            var optionsCallbackTuple = this.validateOptionsAndCallback(options, callback);\r\n            options = optionsCallbackTuple.options;\r\n            callback = optionsCallbackTuple.callback;\r\n            \r\n            var isNameBased = Base.isLinkNameBased(udfLink);\r\n            var path = this.getPathFromLink(udfLink, \"\", isNameBased);\r\n            var id = this.getIdFromLink(udfLink, isNameBased);\r\n            \r\n            this.deleteResource(path, \"udfs\", id, undefined, options, callback);\r\n        },\r\n        \r\n        /**\r\n         * Delete the StoredProcedure object.\r\n         * @memberof DocumentClient\r\n         * @instance\r\n         * @param {string} sprocLink         - The self-link of the stored procedure.\r\n         * @param {RequestOptions} [options] - The request options.\r\n         * @param {RequestCallback} callback - The callback for the request.\r\n        */\r\n        deleteStoredProcedure: function (sprocLink, options, callback) {\r\n            var optionsCallbackTuple = this.validateOptionsAndCallback(options, callback);\r\n            options = optionsCallbackTuple.options;\r\n            callback = optionsCallbackTuple.callback;\r\n            \r\n            var isNameBased = Base.isLinkNameBased(sprocLink);\r\n            var path = this.getPathFromLink(sprocLink, \"\", isNameBased);\r\n            var id = this.getIdFromLink(sprocLink, isNameBased);\r\n            \r\n            this.deleteResource(path, \"sprocs\", id, undefined, options, callback);\r\n        },\r\n        \r\n        /**\r\n         * Delete the conflict object.\r\n         * @memberof DocumentClient\r\n         * @instance\r\n         * @param {string} conflictLink      - The self-link of the conflict.\r\n         * @param {RequestOptions} [options] - The request options.\r\n         * @param {RequestCallback} callback - The callback for the request.\r\n        */\r\n        deleteConflict: function (conflictLink, options, callback) {\r\n            var optionsCallbackTuple = this.validateOptionsAndCallback(options, callback);\r\n            options = optionsCallbackTuple.options;\r\n            callback = optionsCallbackTuple.callback;\r\n            \r\n            var isNameBased = Base.isLinkNameBased(conflictLink);\r\n            var path = this.getPathFromLink(conflictLink, \"\", isNameBased);\r\n            var id = this.getIdFromLink(conflictLink, isNameBased);\r\n            \r\n            this.deleteResource(path, \"conflicts\", id, undefined, options, callback);\r\n        },\r\n        \r\n        /**\r\n         * Replace the document collection.\r\n         * @memberof DocumentClient\r\n         * @instance\r\n         * @param {string} collectionLink    - The self-link of the document collection.\r\n         * @param {object} collection        - Represent the new document collection body.\r\n         * @param {RequestOptions} [options] - The request options.\r\n         * @param {RequestCallback} callback - The callback for the request.\r\n        */\r\n        replaceCollection: function (collectionLink, collection, options, callback) {\r\n            var optionsCallbackTuple = this.validateOptionsAndCallback(options, callback);\r\n            options = optionsCallbackTuple.options;\r\n            callback = optionsCallbackTuple.callback;\r\n            \r\n            var err = {};\r\n            if (!this.isResourceValid(collection, err)) {\r\n                callback(err);\r\n                return;\r\n            }\r\n            \r\n            var isNameBased = Base.isLinkNameBased(collectionLink);\r\n            var path = this.getPathFromLink(collectionLink, \"\", isNameBased);\r\n            var id = this.getIdFromLink(collectionLink, isNameBased);\r\n            \r\n            this.replace(collection, path, \"colls\", id, undefined, options, callback);\r\n        },\r\n        \r\n        /**\r\n         * Replace the document object.\r\n         * @memberof DocumentClient\r\n         * @instance\r\n         * @param {string} documentLink      - The self-link of the document.\r\n         * @param {object} document          - Represent the new document body.\r\n         * @param {RequestOptions} [options] - The request options.\r\n         * @param {RequestCallback} callback - The callback for the request.\r\n        */\r\n        replaceDocument: function (documentLink, newDocument, options, callback) {\r\n            var optionsCallbackTuple = this.validateOptionsAndCallback(options, callback);\r\n            options = optionsCallbackTuple.options;\r\n            callback = optionsCallbackTuple.callback;\r\n            \r\n            var that = this;\r\n            \r\n            var task = function () {\r\n                var err = {};\r\n                if (!that.isResourceValid(newDocument, err)) {\r\n                    callback(err);\r\n                    return;\r\n                }\r\n                \r\n                var isNameBased = Base.isLinkNameBased(documentLink);\r\n                var path = that.getPathFromLink(documentLink, \"\", isNameBased);\r\n                var id = that.getIdFromLink(documentLink, isNameBased);\r\n                \r\n                that.replace(newDocument, path, \"docs\", id, undefined, options, callback);\r\n            };\r\n            \r\n            if (options.partitionKey === undefined) {\r\n                this.getPartitionKeyDefinition(Base.getCollectionLink(documentLink), function (err, partitionKeyDefinition, response, headers) {\r\n                    if (err) return callback(err, response, headers);\r\n                    options.partitionKey = that.extractPartitionKey(newDocument, partitionKeyDefinition);\r\n                    \r\n                    task();\r\n                });\r\n            }\r\n            else {\r\n                task();\r\n            }\r\n        },\r\n        \r\n        /**\r\n         * Replace the attachment object.\r\n         * @memberof DocumentClient\r\n         * @instance\r\n         * @param {string} attachmentLink    - The self-link of the attachment.\r\n         * @param {object} attachment        - Represent the new attachment body.\r\n         * @param {RequestOptions} [options] - The request options.\r\n         * @param {RequestCallback} callback - The callback for the request.\r\n         */\r\n        replaceAttachment: function (attachmentLink, attachment, options, callback) {\r\n            var optionsCallbackTuple = this.validateOptionsAndCallback(options, callback);\r\n            options = optionsCallbackTuple.options;\r\n            callback = optionsCallbackTuple.callback;\r\n            \r\n            var err = {};\r\n            if (!this.isResourceValid(attachment, err)) {\r\n                callback(err);\r\n                return;\r\n            }\r\n            \r\n            var isNameBased = Base.isLinkNameBased(attachmentLink);\r\n            var path = this.getPathFromLink(attachmentLink, \"\", isNameBased);\r\n            var id = this.getIdFromLink(attachmentLink, isNameBased);\r\n            \r\n            this.replace(attachment, path, \"attachments\", id, undefined, options, callback);\r\n        },\r\n        \r\n        /**\r\n         * Replace the user object.\r\n         * @memberof DocumentClient\r\n         * @instance\r\n         * @param {string} userLink          - The self-link of the user.\r\n         * @param {object} user              - Represent the new user body.\r\n         * @param {RequestOptions} [options] - The request options.\r\n         * @param {RequestCallback} callback - The callback for the request.\r\n        */\r\n        replaceUser: function (userLink, user, options, callback) {\r\n            var optionsCallbackTuple = this.validateOptionsAndCallback(options, callback);\r\n            options = optionsCallbackTuple.options;\r\n            callback = optionsCallbackTuple.callback;\r\n            \r\n            var err = {};\r\n            if (!this.isResourceValid(user, err)) {\r\n                callback(err);\r\n                return;\r\n            }\r\n            \r\n            var isNameBased = Base.isLinkNameBased(userLink);\r\n            var path = this.getPathFromLink(userLink, \"\", isNameBased);\r\n            var id = this.getIdFromLink(userLink, isNameBased);\r\n            \r\n            this.replace(user, path, \"users\", id, undefined, options, callback);\r\n        },\r\n        \r\n        /**\r\n         * Replace the permission object.\r\n         * @memberof DocumentClient\r\n         * @instance\r\n         * @param {string} permissionLink    - The self-link of the permission.\r\n         * @param {object} permission        - Represent the new permission body.\r\n         * @param {RequestOptions} [options] - The request options.\r\n         * @param {RequestCallback} callback - The callback for the request.\r\n        */\r\n        replacePermission: function (permissionLink, permission, options, callback) {\r\n            var optionsCallbackTuple = this.validateOptionsAndCallback(options, callback);\r\n            options = optionsCallbackTuple.options;\r\n            callback = optionsCallbackTuple.callback;\r\n            \r\n            var err = {};\r\n            if (!this.isResourceValid(permission, err)) {\r\n                callback(err);\r\n                return;\r\n            }\r\n            \r\n            var isNameBased = Base.isLinkNameBased(permissionLink);\r\n            var path = this.getPathFromLink(permissionLink, \"\", isNameBased);\r\n            var id = this.getIdFromLink(permissionLink, isNameBased);\r\n            \r\n            this.replace(permission, path, \"permissions\", id, undefined, options, callback);\r\n        },\r\n        \r\n        /**\r\n         * Replace the trigger object.\r\n         * @memberof DocumentClient\r\n         * @instance\r\n         * @param {string} triggerLink       - The self-link of the trigger.\r\n         * @param {object} trigger           - Represent the new trigger body.\r\n         * @param {RequestOptions} [options] - The request options.\r\n         * @param {RequestCallback} callback - The callback for the request.\r\n        */\r\n        replaceTrigger: function (triggerLink, trigger, options, callback) {\r\n            var optionsCallbackTuple = this.validateOptionsAndCallback(options, callback);\r\n            options = optionsCallbackTuple.options;\r\n            callback = optionsCallbackTuple.callback;\r\n            \r\n            if (trigger.serverScript) {\r\n                trigger.body = trigger.serverScript.toString();\r\n            } else if (trigger.body) {\r\n                trigger.body = trigger.body.toString();\r\n            }\r\n            \r\n            var err = {};\r\n            if (!this.isResourceValid(trigger, err)) {\r\n                callback(err);\r\n                return;\r\n            }\r\n            \r\n            var isNameBased = Base.isLinkNameBased(triggerLink);\r\n            var path = this.getPathFromLink(triggerLink, \"\", isNameBased);\r\n            var id = this.getIdFromLink(triggerLink, isNameBased);\r\n            \r\n            this.replace(trigger, path, \"triggers\", id, undefined, options, callback);\r\n        },\r\n        \r\n        /**\r\n         * Replace the UserDefinedFunction object.\r\n         * @memberof DocumentClient\r\n         * @instance\r\n         * @param {string} udfLink           - The self-link of the user defined function.\r\n         * @param {object} udf               - Represent the new udf body.\r\n         * @param {RequestOptions} [options] - The request options.\r\n         * @param {RequestCallback} callback - The callback for the request.\r\n        */\r\n        replaceUserDefinedFunction: function (udfLink, udf, options, callback) {\r\n            var optionsCallbackTuple = this.validateOptionsAndCallback(options, callback);\r\n            options = optionsCallbackTuple.options;\r\n            callback = optionsCallbackTuple.callback;\r\n            \r\n            if (udf.serverScript) {\r\n                udf.body = udf.serverScript.toString();\r\n            } else if (udf.body) {\r\n                udf.body = udf.body.toString();\r\n            }\r\n            \r\n            var err = {};\r\n            if (!this.isResourceValid(udf, err)) {\r\n                callback(err);\r\n                return;\r\n            }\r\n            \r\n            var isNameBased = Base.isLinkNameBased(udfLink);\r\n            var path = this.getPathFromLink(udfLink, \"\", isNameBased);\r\n            var id = this.getIdFromLink(udfLink, isNameBased);\r\n            \r\n            this.replace(udf, path, \"udfs\", id, undefined, options, callback);\r\n        },\r\n        \r\n        /**\r\n         * Replace the StoredProcedure object.\r\n         * @memberof DocumentClient\r\n         * @instance\r\n         * @param {string} sprocLink         - The self-link of the stored procedure.\r\n         * @param {object} sproc             - Represent the new sproc body.\r\n         * @param {RequestOptions} [options] - The request options.\r\n         * @param {RequestCallback} callback - The callback for the request.\r\n        */\r\n        replaceStoredProcedure: function (sprocLink, sproc, options, callback) {\r\n            var optionsCallbackTuple = this.validateOptionsAndCallback(options, callback);\r\n            options = optionsCallbackTuple.options;\r\n            callback = optionsCallbackTuple.callback;\r\n            \r\n            if (sproc.serverScript) {\r\n                sproc.body = sproc.serverScript.toString();\r\n            } else if (sproc.body) {\r\n                sproc.body = sproc.body.toString();\r\n            }\r\n            \r\n            var err = {};\r\n            if (!this.isResourceValid(sproc, err)) {\r\n                callback(err);\r\n                return;\r\n            }\r\n            \r\n            var isNameBased = Base.isLinkNameBased(sprocLink);\r\n            var path = this.getPathFromLink(sprocLink, \"\", isNameBased);\r\n            var id = this.getIdFromLink(sprocLink, isNameBased);\r\n            \r\n            this.replace(sproc, path, \"sprocs\", id, undefined, options, callback);\r\n        },\r\n        \r\n        /**\r\n         * Upsert a document.\r\n         * <p>\r\n         * There is no set schema for JSON documents. They may contain any number of custom properties as well as an optional list of attachments. <br>\r\n         * A Document is an application resource and can be authorized using the master key or resource keys\r\n         * </p>\r\n         * @memberof DocumentClient\r\n         * @instance\r\n         * @param {string} documentsFeedOrDatabaseLink               - The collection link or database link if using a partition resolver\r\n         * @param {object} body                                      - Represents the body of the document. Can contain any number of user defined properties.\r\n         * @param {string} [body.id]                                 - The id of the document, MUST be unique for each document.\r\n         * @param {number} body.ttl                                  - The time to live in seconds of the document.\r\n         * @param {RequestOptions} [options]                         - The request options.\r\n         * @param {boolean} [options.disableAutomaticIdGeneration]   - Disables the automatic id generation. If id is missing in the body and this option is true, an error will be returned.\r\n         * @param {RequestCallback} callback                         - The callback for the request.\r\n         */\r\n        upsertDocument: function (documentsFeedOrDatabaseLink, body, options, callback) {\r\n            var partitionResolver = this.partitionResolvers[documentsFeedOrDatabaseLink];\r\n            \r\n            var collectionLink;\r\n            if (partitionResolver === undefined || partitionResolver === null) {\r\n                collectionLink = documentsFeedOrDatabaseLink;\r\n            } else {\r\n                collectionLink = this.resolveCollectionLinkForCreate(partitionResolver, body);\r\n            }\r\n            \r\n            this.upsertDocumentPrivate(collectionLink, body, options, callback);\r\n        },\r\n        \r\n        /**\r\n         * Upsert an attachment for the document object.\r\n         * <p>\r\n         * Each document may contain zero or more attachments. Attachments can be of any MIME type - text, image, binary data. <br>\r\n         * These are stored externally in Azure Blob storage. Attachments are automatically deleted when the parent document is deleted.\r\n         * </P>\r\n         * @memberof DocumentClient\r\n         * @instance\r\n         * @param {string} documentLink         - The self-link of the document.\r\n         * @param {Object} body                 - The metadata the defines the attachment media like media, contentType. It can include any other properties as part of the metedata.\r\n         * @param {string} body.contentType     - The MIME contentType of the attachment.\r\n         * @param {string} body.media           - Media link associated with the attachment content.\r\n         * @param {RequestOptions} options      - The request options.\r\n         * @param {RequestCallback} callback    - The callback for the request.\r\n        */\r\n        upsertAttachment: function (documentLink, body, options, callback) {\r\n            var optionsCallbackTuple = this.validateOptionsAndCallback(options, callback);\r\n            options = optionsCallbackTuple.options;\r\n            callback = optionsCallbackTuple.callback;\r\n            \r\n            var err = {};\r\n            if (!this.isResourceValid(body, err)) {\r\n                callback(err);\r\n                return;\r\n            }\r\n            \r\n            var isNameBased = Base.isLinkNameBased(documentLink);\r\n            var path = this.getPathFromLink(documentLink, \"attachments\", isNameBased);\r\n            var id = this.getIdFromLink(documentLink, isNameBased);\r\n            \r\n            this.upsert(body, path, \"attachments\", id, undefined, options, callback);\r\n        },\r\n        \r\n        /**\r\n         * Upsert a database user.\r\n         * @memberof DocumentClient\r\n         * @instance\r\n         * @param {string} databaseLink         - The self-link of the database.\r\n         * @param {object} body                 - Represents the body of the user.\r\n         * @param {string} body.id              - The id of the user.\r\n         * @param {RequestOptions} [options]    - The request options.\r\n         * @param {RequestCallback} callback    - The callback for the request.\r\n         */\r\n        upsertUser: function (databaseLink, body, options, callback) {\r\n            var optionsCallbackTuple = this.validateOptionsAndCallback(options, callback);\r\n            options = optionsCallbackTuple.options;\r\n            callback = optionsCallbackTuple.callback;\r\n            \r\n            var err = {};\r\n            if (!this.isResourceValid(body, err)) {\r\n                callback(err);\r\n                return;\r\n            }\r\n            \r\n            var isNameBased = Base.isLinkNameBased(databaseLink);\r\n            var path = this.getPathFromLink(databaseLink, \"users\", isNameBased);\r\n            var id = this.getIdFromLink(databaseLink, isNameBased);\r\n            \r\n            this.upsert(body, path, \"users\", id, undefined, options, callback);\r\n        },\r\n        \r\n        /**\r\n         * Upsert a permission.\r\n         * <p> A permission represents a per-User Permission to access a specific resource e.g. Document or Collection.  </p>\r\n         * @memberof DocumentClient\r\n         * @instance\r\n         * @param {string} userLink             - The self-link of the user.\r\n         * @param {object} body                 - Represents the body of the permission.\r\n         * @param {string} body.id              - The id of the permission\r\n         * @param {string} body.permissionMode  - The mode of the permission, must be a value of {@link PermissionMode}\r\n         * @param {string} body.resource        - The link of the resource that the permission will be applied to.\r\n         * @param {RequestOptions} [options]    - The request options.\r\n         * @param {RequestCallback} callback    - The callback for the request.\r\n         */\r\n        upsertPermission: function (userLink, body, options, callback) {\r\n            var optionsCallbackTuple = this.validateOptionsAndCallback(options, callback);\r\n            options = optionsCallbackTuple.options;\r\n            callback = optionsCallbackTuple.callback;\r\n            \r\n            var err = {};\r\n            if (!this.isResourceValid(body, err)) {\r\n                callback(err);\r\n                return;\r\n            }\r\n            \r\n            var isNameBased = Base.isLinkNameBased(userLink);\r\n            var path = this.getPathFromLink(userLink, \"permissions\", isNameBased);\r\n            var id = this.getIdFromLink(userLink, isNameBased);\r\n            \r\n            this.upsert(body, path, \"permissions\", id, undefined, options, callback);\r\n        },\r\n        \r\n        /**\r\n        * Upsert a trigger.\r\n        * <p>\r\n        * DocumentDB supports pre and post triggers defined in JavaScript to be executed on creates, updates and deletes. <br>\r\n        * For additional details, refer to the server-side JavaScript API documentation.\r\n        * </p>\r\n        * @memberof DocumentClient\r\n        * @instance\r\n        * @param {string} collectionLink           - The self-link of the collection.\r\n        * @param {object} trigger                  - Represents the body of the trigger.\r\n        * @param {string} trigger.id             - The id of the trigger.\r\n        * @param {string} trigger.triggerType      - The type of the trigger, should be one of the values of {@link TriggerType}.\r\n        * @param {string} trigger.triggerOperation - The trigger operation, should be one of the values of {@link TriggerOperation}.\r\n        * @param {function} trigger.serverScript   - The body of the trigger, it can be passed as stringified too.\r\n        * @param {RequestOptions} [options]        - The request options.\r\n        * @param {RequestCallback} callback        - The callback for the request.\r\n        */\r\n        upsertTrigger: function (collectionLink, trigger, options, callback) {\r\n            var optionsCallbackTuple = this.validateOptionsAndCallback(options, callback);\r\n            options = optionsCallbackTuple.options;\r\n            callback = optionsCallbackTuple.callback;\r\n            \r\n            if (trigger.serverScript) {\r\n                trigger.body = trigger.serverScript.toString();\r\n            } else if (trigger.body) {\r\n                trigger.body = trigger.body.toString();\r\n            }\r\n            \r\n            var err = {};\r\n            if (!this.isResourceValid(trigger, err)) {\r\n                callback(err);\r\n                return;\r\n            }\r\n            \r\n            var isNameBased = Base.isLinkNameBased(collectionLink);\r\n            var path = this.getPathFromLink(collectionLink, \"triggers\", isNameBased);\r\n            var id = this.getIdFromLink(collectionLink, isNameBased);\r\n            \r\n            this.upsert(trigger, path, \"triggers\", id, undefined, options, callback);\r\n        },\r\n        \r\n        /**\r\n         * Upsert a UserDefinedFunction.\r\n         * <p>\r\n         * DocumentDB supports JavaScript UDFs which can be used inside queries, stored procedures and triggers. <br>\r\n         * For additional details, refer to the server-side JavaScript API documentation.\r\n         * </p>\r\n         * @memberof DocumentClient\r\n         * @instance\r\n         * @param {string} collectionLink                - The self-link of the collection.\r\n         * @param {object} udf                           - Represents the body of the userDefinedFunction.\r\n         * @param {string} udf.id                      - The id of the udf.\r\n         * @param {string} udf.userDefinedFunctionType   - The type of the udf, it should be one of the values of {@link UserDefinedFunctionType}\r\n         * @param {function} udf.serverScript            - Represents the body of the udf, it can be passed as stringified too.\r\n         * @param {RequestOptions} [options]             - The request options.\r\n         * @param {RequestCallback} callback             - The callback for the request.\r\n         */\r\n        upsertUserDefinedFunction: function (collectionLink, udf, options, callback) {\r\n            var optionsCallbackTuple = this.validateOptionsAndCallback(options, callback);\r\n            options = optionsCallbackTuple.options;\r\n            callback = optionsCallbackTuple.callback;\r\n            \r\n            if (udf.serverScript) {\r\n                udf.body = udf.serverScript.toString();\r\n            } else if (udf.body) {\r\n                udf.body = udf.body.toString();\r\n            }\r\n            \r\n            var err = {};\r\n            if (!this.isResourceValid(udf, err)) {\r\n                callback(err);\r\n                return;\r\n            }\r\n            \r\n            var isNameBased = Base.isLinkNameBased(collectionLink);\r\n            var path = this.getPathFromLink(collectionLink, \"udfs\", isNameBased);\r\n            var id = this.getIdFromLink(collectionLink, isNameBased);\r\n            \r\n            this.upsert(udf, path, \"udfs\", id, undefined, options, callback);\r\n        },\r\n        \r\n        /**\r\n         * Upsert a StoredProcedure.\r\n         * <p>\r\n         * DocumentDB allows stored procedures to be executed in the storage tier, directly against a document collection. The script <br>\r\n         * gets executed under ACID transactions on the primary storage partition of the specified collection. For additional details, <br>\r\n         * refer to the server-side JavaScript API documentation.\r\n         * </p>\r\n         * @memberof DocumentClient\r\n         * @instance\r\n         * @param {string} collectionLink       - The self-link of the collection.\r\n         * @param {object} sproc                - Represents the body of the stored procedure.\r\n         * @param {string} sproc.id           - The id of the stored procedure.\r\n         * @param {function} sproc.serverScript - The body of the stored procedure, it can be passed as stringified too.\r\n         * @param {RequestOptions} [options]    - The request options.\r\n         * @param {RequestCallback} callback    - The callback for the request.\r\n         */\r\n        upsertStoredProcedure: function (collectionLink, sproc, options, callback) {\r\n            var optionsCallbackTuple = this.validateOptionsAndCallback(options, callback);\r\n            options = optionsCallbackTuple.options;\r\n            callback = optionsCallbackTuple.callback;\r\n            \r\n            if (sproc.serverScript) {\r\n                sproc.body = sproc.serverScript.toString();\r\n            } else if (sproc.body) {\r\n                sproc.body = sproc.body.toString();\r\n            }\r\n            \r\n            var err = {};\r\n            if (!this.isResourceValid(sproc, err)) {\r\n                callback(err);\r\n                return;\r\n            }\r\n            \r\n            var isNameBased = Base.isLinkNameBased(collectionLink);\r\n            var path = this.getPathFromLink(collectionLink, \"sprocs\", isNameBased);\r\n            var id = this.getIdFromLink(collectionLink, isNameBased);\r\n            \r\n            this.upsert(sproc, path, \"sprocs\", id, undefined, options, callback);\r\n        },\r\n        \r\n        /**\r\n         * Upsert an attachment for the document object.\r\n         * @memberof DocumentClient\r\n         * @instance\r\n         * @param {string} documentLink             - The self-link of the document.\r\n         * @param {stream.Readable} readableStream  - the stream that represents the media itself that needs to be uploaded.\r\n         * @param {MediaOptions} [options]          - The request options.\r\n         * @param {RequestCallback} callback        - The callback for the request.\r\n        */\r\n        upsertAttachmentAndUploadMedia: function (documentLink, readableStream, options, callback) {\r\n            var optionsCallbackTuple = this.validateOptionsAndCallback(options, callback);\r\n            options = optionsCallbackTuple.options;\r\n            callback = optionsCallbackTuple.callback;\r\n            \r\n            var initialHeaders = Base.extend({}, this.defaultHeaders);\r\n            \r\n            // Add required headers slug and content-type.\r\n            if (options.slug) {\r\n                initialHeaders[Constants.HttpHeaders.Slug] = options.slug;\r\n            }\r\n            \r\n            if (options.contentType) {\r\n                initialHeaders[Constants.HttpHeaders.ContentType] = options.contentType;\r\n            } else {\r\n                initialHeaders[Constants.HttpHeaders.ContentType] = Constants.MediaTypes.OctetStream;\r\n            }\r\n            \r\n            var isNameBased = Base.isLinkNameBased(documentLink);\r\n            var path = this.getPathFromLink(documentLink, \"attachments\", isNameBased);\r\n            var id = this.getIdFromLink(documentLink, isNameBased);\r\n            \r\n            this.upsert(readableStream, path, \"attachments\", id, initialHeaders, options, callback);\r\n        },\r\n        \r\n        /**\r\n          * Read the media for the attachment object.\r\n          * @memberof DocumentClient\r\n          * @instance\r\n          * @param {string} mediaLink         - The media link of the media in the attachment.\r\n          * @param {RequestCallback} callback - The callback for the request, the result parameter can be a buffer or a stream\r\n          *                                     depending on the value of {@link MediaReadMode}.\r\n          */\r\n        readMedia: function (mediaLink, callback) {\r\n            var resourceInfo = Base.parseLink(mediaLink);\r\n            var path = \"/\" + mediaLink;\r\n            var initialHeaders = Base.extend({}, this.defaultHeaders);\r\n            initialHeaders[Constants.HttpHeaders.Accept] = Constants.MediaTypes.Any;\r\n            var attachmentId = Base.getAttachmentIdFromMediaId(resourceInfo.objectBody.id).toLowerCase();\r\n\r\n            var headers = Base.getHeaders(this, initialHeaders, \"get\", path, attachmentId, \"media\", {});\r\n            \r\n            var that = this;\r\n            // readMedia will always use WriteEndpoint since it's not replicated in readable Geo regions\r\n            this._globalEndpointManager.getWriteEndpoint(function (writeEndpoint) {\r\n                that.get(writeEndpoint, path, headers, callback);\r\n            });\r\n        },\r\n        \r\n        /**\r\n         * Update media for the attachment\r\n         * @memberof DocumentClient\r\n         * @instance\r\n         * @param {string} mediaLink                - The media link of the media in the attachment.\r\n         * @param {stream.Readable} readableStream  - The stream that represents the media itself that needs to be uploaded.\r\n         * @param {MediaOptions} [options]          - options for the media\r\n         * @param {RequestCallback} callback        - The callback for the request.\r\n         */\r\n        updateMedia: function (mediaLink, readableStream, options, callback) {\r\n            var optionsCallbackTuple = this.validateOptionsAndCallback(options, callback);\r\n            options = optionsCallbackTuple.options;\r\n            callback = optionsCallbackTuple.callback;\r\n            \r\n            var defaultHeaders = this.defaultHeaders;\r\n            var initialHeaders = Base.extend({}, defaultHeaders);\r\n            \r\n            // Add required headers slug and content-type in case the body is a stream\r\n            if (options.slug) {\r\n                initialHeaders[Constants.HttpHeaders.Slug] = options.slug;\r\n            }\r\n            \r\n            if (options.contentType) {\r\n                initialHeaders[Constants.HttpHeaders.ContentType] = options.contentType;\r\n            } else {\r\n                initialHeaders[Constants.HttpHeaders.ContentType] = Constants.MediaTypes.OctetStream;\r\n            }\r\n            \r\n            initialHeaders[Constants.HttpHeaders.Accept] = Constants.MediaTypes.Any;\r\n            \r\n            var resourceInfo = Base.parseLink(mediaLink);\r\n            var path = \"/\" + mediaLink;\r\n            var attachmentId = Base.getAttachmentIdFromMediaId(resourceInfo.objectBody.id).toLowerCase();\r\n            var headers = Base.getHeaders(this, initialHeaders, \"put\", path, attachmentId, \"media\", options);\r\n\r\n            // updateMedia will use WriteEndpoint since it uses PUT operation\r\n            var that = this;\r\n            this._globalEndpointManager.getWriteEndpoint(function (writeEndpoint) {\r\n                that.put(writeEndpoint, path, readableStream, headers, callback);\r\n            });\r\n        },\r\n        \r\n        /**\r\n         * Execute the StoredProcedure represented by the object with partition key.\r\n         * @memberof DocumentClient\r\n         * @instance\r\n         * @param {string} sprocLink            - The self-link of the stored procedure.\r\n         * @param {Array} [params]              - represent the parameters of the stored procedure.\r\n         * @param {Object} [options]            - partition key\r\n         * @param {RequestCallback} callback    - The callback for the request.\r\n        */\r\n        executeStoredProcedure: function (sprocLink, params, options, callback) {\r\n            if (!callback && !options) {\r\n                callback = params;\r\n                params = null;\r\n                options = {}\r\n            }\r\n            else if(!callback) {\r\n                callback = options;\r\n                options = {};\r\n            }\r\n            \r\n            var defaultHeaders = this.defaultHeaders;\r\n            var initialHeaders = {};\r\n            initialHeaders = Base.extend(initialHeaders, defaultHeaders);\r\n            \r\n            // Accept a single parameter or an array of parameters.\r\n            if (params !== null && params !== undefined && params.constructor !== Array) {\r\n                params = [params];\r\n            }\r\n            \r\n            var isNameBased = Base.isLinkNameBased(sprocLink);\r\n            var path = this.getPathFromLink(sprocLink, \"\", isNameBased);\r\n            var id = this.getIdFromLink(sprocLink, isNameBased);\r\n            \r\n            var headers = Base.getHeaders(this, initialHeaders, \"post\", path, id, \"sprocs\", options);\r\n            \r\n            // executeStoredProcedure will use WriteEndpoint since it uses POST operation\r\n            var that = this;\r\n            this._globalEndpointManager.getWriteEndpoint(function (writeEndpoint) {\r\n                that.post(writeEndpoint, path, params, headers, callback);\r\n            });\r\n        },\r\n        \r\n        /**\r\n         * Replace the offer object.\r\n         * @memberof DocumentClient\r\n         * @instance\r\n         * @param {string} offerLink         - The self-link of the offer.\r\n         * @param {object} offer             - Represent the new offer body.\r\n         * @param {RequestCallback} callback - The callback for the request.\r\n         */\r\n        replaceOffer: function (offerLink, offer, callback) {\r\n            var err = {};\r\n            if (!this.isResourceValid(offer, err)) {\r\n                callback(err);\r\n                return;\r\n            }\r\n            \r\n            var path = \"/\" + offerLink;\r\n            var id = Base.parseLink(offerLink).objectBody.id.toLowerCase();\r\n            this.replace(offer, path, \"offers\", id, undefined, {}, callback);\r\n        },\r\n        \r\n        /** Reads an offer.\r\n         * @memberof DocumentClient\r\n         * @instance\r\n         * @param {string} offerLink         - The self-link of the offer.\r\n         * @param {RequestCallback} callback    - The callback for the request.\r\n        */\r\n        readOffer: function (offerLink, callback) {\r\n            var path = \"/\" + offerLink;\r\n            var id = Base.parseLink(offerLink).objectBody.id.toLowerCase();\r\n            this.read(path, \"offers\", id, undefined, {}, callback);\r\n        },\r\n        \r\n        /** Lists all offers.\r\n         * @memberof DocumentClient\r\n         * @instance\r\n         * @param {FeedOptions} [options] - The feed options.\r\n         * @returns {QueryIterator}       - An instance of queryIterator to handle reading feed.\r\n        */\r\n        readOffers: function (options) {\r\n            return this.queryOffers(undefined, options);\r\n        },\r\n        \r\n        /** Lists all offers that satisfy a query.\r\n         * @memberof DocumentClient\r\n         * @instance\r\n         * @param {SqlQuerySpec | string} query - A SQL query.\r\n         * @param {FeedOptions} [options]       - The feed options.\r\n         * @returns {QueryIterator}             - An instance of QueryIterator to handle reading feed.\r\n        */\r\n        queryOffers: function (query, options) {\r\n            var that = this;\r\n            return new QueryIterator(this, query, options, function (options, callback) {\r\n                that.queryFeed.call(that,\r\n                        that,\r\n                        \"/offers\",\r\n                        \"offers\",\r\n                        \"\",\r\n                        function (result) { return result.Offers; },\r\n                        function (parent, body) { return body; },\r\n                        query,\r\n                        options,\r\n                        callback);\r\n            });\r\n        },\r\n        \r\n        /** Gets the Database account information.\r\n       * @memberof DocumentClient\r\n       * @instance\r\n       * @param {string} [options.urlConnection]   - The endpoint url whose database account needs to be retrieved. If not present, current client's url will be used.\r\n       * @param {RequestCallback} callback         - The callback for the request. The second parameter of the callback will be of type {@link DatabaseAccount}.\r\n       */\r\n        getDatabaseAccount: function (options, callback) {\r\n            var optionsCallbackTuple = this.validateOptionsAndCallback(options, callback);\r\n            options = optionsCallbackTuple.options;\r\n            callback = optionsCallbackTuple.callback;\r\n\r\n            var urlConnection = options.urlConnection || this.urlConnection;\r\n\r\n            var headers = Base.getHeaders(this, this.defaultHeaders, \"get\", \"\", \"\", \"\", {});\r\n            this.get(urlConnection, \"\", headers, function (err, result, headers) {\r\n                if (err) return callback(err);\r\n                \r\n                var databaseAccount = new AzureDocuments.DatabaseAccount();\r\n                databaseAccount.DatabasesLink = \"/dbs/\";\r\n                databaseAccount.MediaLink = \"/media/\";\r\n                databaseAccount.MaxMediaStorageUsageInMB = headers[Constants.HttpHeaders.MaxMediaStorageUsageInMB];\r\n                databaseAccount.CurrentMediaStorageUsageInMB = headers[Constants.HttpHeaders.CurrentMediaStorageUsageInMB];\r\n                databaseAccount.ConsistencyPolicy = result.userConsistencyPolicy;\r\n                \r\n                // WritableLocations and ReadableLocations properties will be available only for geo-replicated database accounts\r\n                if (Constants.WritableLocations in result) {\r\n                    databaseAccount._writableLocations = result[Constants.WritableLocations];\r\n                }\r\n                if (Constants.ReadableLocations in result) {\r\n                    databaseAccount._readableLocations = result[Constants.ReadableLocations];\r\n                }\r\n                \r\n                callback(undefined, databaseAccount, headers);\r\n            });\r\n        },\r\n        \r\n        /** @ignore */\r\n        createDocumentPrivate: function (collectionLink, body, options, callback) {\r\n            var optionsCallbackTuple = this.validateOptionsAndCallback(options, callback);\r\n            options = optionsCallbackTuple.options;\r\n            callback = optionsCallbackTuple.callback;\r\n            \r\n            var that = this;\r\n            \r\n            var task = function () {\r\n                // Generate random document id if the id is missing in the payload and options.disableAutomaticIdGeneration != true\r\n                if ((body.id === undefined || body.id === \"\") && !options.disableAutomaticIdGeneration) {\r\n                    body.id = Base.generateGuidId();\r\n                }\r\n                \r\n                var err = {};\r\n                if (!that.isResourceValid(body, err)) {\r\n                    callback(err);\r\n                    return;\r\n                }\r\n                \r\n                var isNameBased = Base.isLinkNameBased(collectionLink);\r\n                var path = that.getPathFromLink(collectionLink, \"docs\", isNameBased);\r\n                var id = that.getIdFromLink(collectionLink, isNameBased);\r\n                \r\n                that.create(body, path, \"docs\", id, undefined, options, callback);\r\n            };\r\n            \r\n            if (options.partitionKey === undefined) {\r\n                this.getPartitionKeyDefinition(collectionLink, function (err, partitionKeyDefinition, response, headers) {\r\n                    if (err) return callback(err, response, headers);\r\n                    options.partitionKey = that.extractPartitionKey(body, partitionKeyDefinition);\r\n                    \r\n                    task();\r\n                });\r\n            }\r\n            else {\r\n                task();\r\n            }\r\n        },\r\n        \r\n        /** @ignore */\r\n        upsertDocumentPrivate: function (collectionLink, body, options, callback) {\r\n            var optionsCallbackTuple = this.validateOptionsAndCallback(options, callback);\r\n            options = optionsCallbackTuple.options;\r\n            callback = optionsCallbackTuple.callback;\r\n            \r\n            var that = this;\r\n            \r\n            var task = function () {\r\n                // Generate random document id if the id is missing in the payload and options.disableAutomaticIdGeneration != true\r\n                if ((body.id === undefined || body.id === \"\") && !options.disableAutomaticIdGeneration) {\r\n                    body.id = Base.generateGuidId();\r\n                }\r\n                \r\n                var err = {};\r\n                if (!that.isResourceValid(body, err)) {\r\n                    callback(err);\r\n                    return;\r\n                }\r\n                \r\n                var isNameBased = Base.isLinkNameBased(collectionLink);\r\n                var path = that.getPathFromLink(collectionLink, \"docs\", isNameBased);\r\n                var id = that.getIdFromLink(collectionLink, isNameBased);\r\n                \r\n                that.upsert(body, path, \"docs\", id, undefined, options, callback);\r\n            };\r\n            \r\n            if (options.partitionKey === undefined) {\r\n                this.getPartitionKeyDefinition(collectionLink, function (err, partitionKeyDefinition, response, headers) {\r\n                    if (err) return callback(err, response, headers);\r\n                    options.partitionKey = that.extractPartitionKey(body, partitionKeyDefinition);\r\n                    \r\n                    task();\r\n                });\r\n            }\r\n            else {\r\n                task();\r\n            }\r\n        },\r\n        \r\n        /** @ignore */\r\n        queryDocumentsPrivate: function (collectionLinks, query, options) {\r\n            var that = this;\r\n            \r\n            var fetchFunctions = Base.map(collectionLinks, function (collectionLink) {\r\n                var isNameBased = Base.isLinkNameBased(collectionLink);\r\n                var path = that.getPathFromLink(collectionLink, \"docs\", isNameBased);\r\n                var id = that.getIdFromLink(collectionLink, isNameBased);\r\n                \r\n                return function (options, callback) {\r\n                    that.queryFeed.call(that,\r\n                    that,\r\n                    path,\r\n                    \"docs\",\r\n                    id,\r\n                    function (result) { return result.Documents; },\r\n                    function (parent, body) { return body; },\r\n                    query,\r\n                    options,\r\n                    callback);\r\n                };\r\n            });\r\n            \r\n            return new QueryIterator(this, query, options, fetchFunctions, collectionLinks);\r\n        },\r\n        \r\n        /** @ignore */\r\n        create: function (body, path, type, id, initialHeaders, options, callback) {\r\n            initialHeaders = initialHeaders || this.defaultHeaders;\r\n            var headers = Base.getHeaders(this, initialHeaders, \"post\", path, id, type, options);\r\n\r\n            var that = this;\r\n            // create will use WriteEndpoint since it uses POST operation\r\n            this._globalEndpointManager.getWriteEndpoint(function (writeEndpoint) {\r\n                that.post(writeEndpoint, path, body, headers, callback);\r\n            });\r\n        },\r\n        \r\n        /** @ignore */\r\n        upsert: function (body, path, type, id, initialHeaders, options, callback) {\r\n            initialHeaders = initialHeaders || this.defaultHeaders;\r\n            var headers = Base.getHeaders(this, initialHeaders, \"post\", path, id, type, options);\r\n            this.setIsUpsertHeader(headers);\r\n\r\n            var that = this;\r\n            // upsert will use WriteEndpoint since it uses POST operation\r\n            this._globalEndpointManager.getWriteEndpoint(function (writeEndpoint) {\r\n                that.post(writeEndpoint, path, body, headers, callback);\r\n            });\r\n        },\r\n        \r\n        /** @ignore */\r\n        replace: function (resource, path, type, id, initialHeaders, options, callback) {\r\n            initialHeaders = initialHeaders || this.defaultHeaders;\r\n            var headers = Base.getHeaders(this, initialHeaders, \"put\", path, id, type, options);\r\n            \r\n            var that = this;\r\n            // replace will use WriteEndpoint since it uses PUT operation\r\n            this._globalEndpointManager.getWriteEndpoint(function (writeEndpoint) {\r\n                that.put(writeEndpoint, path, resource, headers, callback);\r\n            });\r\n        },\r\n        \r\n        /** @ignore */\r\n        read: function (path, type, id, initialHeaders, options, callback) {\r\n            initialHeaders = initialHeaders || this.defaultHeaders;\r\n            var headers = Base.getHeaders(this, initialHeaders, \"get\", path, id, type, options);\r\n\r\n            var that = this;\r\n            // read will use ReadEndpoint since it uses GET operation\r\n            this._globalEndpointManager.getReadEndpoint(function (readEndpoint) {\r\n                that.get(readEndpoint, path, headers, callback);\r\n            });\r\n        },\r\n        \r\n        /** @ignore */\r\n        deleteResource: function (path, type, id, initialHeaders, options, callback) {\r\n            initialHeaders = initialHeaders || this.defaultHeaders;\r\n            var headers = Base.getHeaders(this, initialHeaders, \"delete\", path, id, type, options);\r\n\r\n            var that = this;\r\n            // deleteResource will use WriteEndpoint since it uses DELETE operation\r\n            this._globalEndpointManager.getWriteEndpoint(function (writeEndpoint) {\r\n                that.delete(writeEndpoint, path, headers, callback);\r\n            });\r\n        },\r\n        \r\n        /** @ignore */\r\n        get: function (url, path, headers, callback) {\r\n            return RequestHandler.request(this._globalEndpointManager, this.connectionPolicy, \"GET\", url, path, undefined, this.defaultUrlParams, headers, callback);\r\n        },\r\n        \r\n        /** @ignore */\r\n        post: function (url, path, body, headers, callback) {\r\n            return RequestHandler.request(this._globalEndpointManager, this.connectionPolicy, \"POST\", url, path, body, this.defaultUrlParams, headers, callback);\r\n        },\r\n        \r\n        /** @ignore */\r\n        put: function (url, path, body, headers, callback) {\r\n            return RequestHandler.request(this._globalEndpointManager, this.connectionPolicy, \"PUT\", url, path, body, this.defaultUrlParams, headers, callback);\r\n        },\r\n        \r\n        /** @ignore */\r\n        head: function (url, path, headers, callback) {\r\n            return RequestHandler.request(this._globalEndpointManager, this.connectionPolicy, \"HEAD\", url, path, undefined, this.defaultUrlParams, headers, callback);\r\n        },\r\n        \r\n        /** @ignore */\r\n        delete: function (url, path, headers, callback) {\r\n            return RequestHandler.request(this._globalEndpointManager, this.connectionPolicy, \"DELETE\", url, path, undefined, this.defaultUrlParams, headers, callback);\r\n        },\r\n        \r\n        /** Gets the partition key definition first by looking into the cache otherwise by reading the collection.\r\n        * @ignore\r\n        * @param {string} collectionLink   - Link to the collection whose partition key needs to be extracted.\r\n        * @param {function} callback       - The arguments to the callback are(in order): error, partitionKeyDefinition, response object and response headers\r\n        */\r\n        getPartitionKeyDefinition: function (collectionLink, callback) {\r\n            // $ISSUE-felixfan-2016-03-17: Make name based path and link based path use the same key\r\n            // $ISSUE-felixfan-2016-03-17: Refresh partitionKeyDefinitionCache when necessary\r\n            if (collectionLink in this.partitionKeyDefinitionCache) {\r\n                return callback(undefined, this.partitionKeyDefinitionCache[collectionLink]);\r\n            }\r\n            \r\n            var that = this;\r\n            \r\n            this.readCollection(collectionLink, function (err, collection, headers) {\r\n                if (err) return callback(err, undefined, collection, headers);\r\n                callback(err, that.partitionKeyDefinitionCache[collectionLink], collection, headers);\r\n            });\r\n        },\r\n        \r\n        extractPartitionKey: function (document, partitionKeyDefinition) {\r\n            if (partitionKeyDefinition && partitionKeyDefinition.paths && partitionKeyDefinition.paths.length > 0) {\r\n                var partitionKey = [];\r\n                partitionKeyDefinition.paths.forEach(function (path) {\r\n                    var pathParts = Base.parsePath(path);\r\n                    \r\n                    var obj = document;\r\n                    for (var i = 0; i < pathParts.length; ++i) {\r\n                        if (!(pathParts[i] in obj)) {\r\n                            obj = {};\r\n                            break;\r\n                        }\r\n                        \r\n                        obj = obj[pathParts[i]];\r\n                    }\r\n                    \r\n                    partitionKey.push(obj);\r\n                });\r\n                \r\n                return partitionKey;\r\n            }\r\n            \r\n            return undefined;\r\n        },\r\n        \r\n        /** @ignore */\r\n        queryFeed: function (documentclient, path, type, id, resultFn, createFn, query, options, callback, partitionKeyRangeId) {\r\n            var that = this;\r\n            \r\n            var optionsCallbackTuple = this.validateOptionsAndCallback(options, callback);\r\n            options = optionsCallbackTuple.options;\r\n            callback = optionsCallbackTuple.callback;\r\n            \r\n            var successCallback = function (err, result, responseHeaders) {\r\n                if (err) return callback(err, undefined, responseHeaders);\r\n                var bodies;\r\n                if (query) {\r\n                    bodies = resultFn(result);\r\n                }\r\n                else {\r\n                    bodies = Base.map(resultFn(result), function (body) {\r\n                        return createFn(that, body);\r\n                    });\r\n                }\r\n                \r\n                callback(undefined, bodies, responseHeaders);\r\n            };\r\n            \r\n            // Query operations will use ReadEndpoint even though it uses GET(for queryFeed) and POST(for regular query operations)\r\n            this._globalEndpointManager.getReadEndpoint(function (readEndpoint) {\r\n                var initialHeaders = Base.extend({}, documentclient.defaultHeaders);\r\n                if (query === undefined) {\r\n                    var headers = Base.getHeaders(documentclient, initialHeaders, \"get\", path, id, type, options, partitionKeyRangeId);\r\n\r\n                    documentclient.get(readEndpoint, path, headers, successCallback);\r\n                } else {\r\n                    initialHeaders[Constants.HttpHeaders.IsQuery] = \"true\";\r\n                    switch (that.queryCompatibilityMode) {\r\n                        case AzureDocuments.QueryCompatibilityMode.SqlQuery:\r\n                            initialHeaders[Constants.HttpHeaders.ContentType] = Constants.MediaTypes.SQL;\r\n                            break;\r\n                        case AzureDocuments.QueryCompatibilityMode.Query:\r\n                        case AzureDocuments.QueryCompatibilityMode.Default:\r\n                        default:\r\n                            if (typeof query === \"string\") {\r\n                                query = { query: query };  // Converts query text to query object.\r\n                            }\r\n                            initialHeaders[Constants.HttpHeaders.ContentType] = Constants.MediaTypes.QueryJson;\r\n                            break;\r\n                    }\r\n                    \r\n                    var headers = Base.getHeaders(documentclient, initialHeaders, \"post\", path, id, type, options, partitionKeyRangeId);\r\n                    documentclient.post(readEndpoint, path, query, headers, successCallback);\r\n                }\r\n            });\r\n        },\r\n        \r\n        /** @ignore */\r\n        isResourceValid: function (resource, err) {\r\n            if (resource.id) {\r\n                if (typeof resource.id !== \"string\") {\r\n                    err.message = \"Id must be a string.\";\r\n                    return false;\r\n                }\r\n\r\n                if (resource.id.indexOf(\"/\") !== -1 || resource.id.indexOf(\"\\\\\") !== -1 || resource.id.indexOf(\"?\") !== -1 || resource.id.indexOf(\"#\") !== -1) {\r\n                    err.message = \"Id contains illegal chars.\";\r\n                    return false;\r\n                }\r\n                if (resource.id[resource.id.length - 1] === \" \") {\r\n                    err.message = \"Id ends with a space.\";\r\n                    return false;\r\n                }\r\n            }\r\n            return true;\r\n        },\r\n        \r\n        /** @ignore */\r\n        resolveCollectionLinkForCreate: function (partitionResolver, document) {\r\n            var validation = this.isPartitionResolverValid(partitionResolver);\r\n            if (!validation.valid) {\r\n                throw validation.error;\r\n            }\r\n            \r\n            var partitionKey = partitionResolver.getPartitionKey(document);\r\n            return partitionResolver.resolveForCreate(partitionKey);\r\n        },\r\n        \r\n        /** @ignore */\r\n        isPartitionResolverValid: function (partionResolver) {\r\n            if (partionResolver === null || partionResolver === undefined) {\r\n                return {\r\n                    valid: false,\r\n                    error: new Error(\"The partition resolver is null or undefined\")\r\n                };\r\n            }\r\n            \r\n            var validation = this.isPartitionResolveFunctionDefined(partionResolver, \"getPartitionKey\");\r\n            if (!validation.valid) {\r\n                return validation;\r\n            }\r\n            validation = this.isPartitionResolveFunctionDefined(partionResolver, \"resolveForCreate\");\r\n            if (!validation.valid) {\r\n                return validation;\r\n            }\r\n            validation = this.isPartitionResolveFunctionDefined(partionResolver, \"resolveForRead\");\r\n            return validation;\r\n        },\r\n        \r\n        /** @ignore */\r\n        isPartitionResolveFunctionDefined: function (partionResolver, functionName) {\r\n            if (partionResolver === null || partionResolver === undefined) {\r\n                return {\r\n                    valid: false,\r\n                    error: new Error(\"The partition resolver is null or undefined\")\r\n                };\r\n            }\r\n            \r\n            if (typeof partionResolver[functionName] === \"function\") {\r\n                return {\r\n                    valid: true\r\n                };\r\n            } else {\r\n                return {\r\n                    valid: false,\r\n                    error: new Error(this.sprintf(\"The partition resolver does not implement method %s. The type of %s is \\\"%s\\\"\", functionName, functionName, typeof partionResolver[functionName]))\r\n                };\r\n            }\r\n        },\r\n        \r\n        /** @ignore */\r\n        getIdFromLink: function (resourceLink, isNameBased) {\r\n            if (isNameBased) {\r\n                return resourceLink;\r\n            } else {\r\n                return Base.parseLink(resourceLink).objectBody.id.toLowerCase();\r\n            }\r\n        },\r\n        \r\n        /** @ignore */\r\n        getPathFromLink: function (resourceLink, resourceType, isNameBased) {\r\n            if (isNameBased) {\r\n                if (resourceType) {\r\n                    return \"/\" + encodeURI(resourceLink) + \"/\" + resourceType;\r\n                } else {\r\n                    return \"/\" + encodeURI(resourceLink);\r\n                }\r\n            } else {\r\n                if (resourceType) {\r\n                    return \"/\" + resourceLink + resourceType + \"/\";\r\n                } else {\r\n                    return \"/\" + resourceLink;\r\n                }\r\n            }\r\n        },\r\n        \r\n        /** @ignore */\r\n        setIsUpsertHeader: function (headers) {\r\n            if (headers === undefined || headers === null) {\r\n                throw new Error('The \"headers\" parameter must not be null or undefined');\r\n            }\r\n            \r\n            if (!(headers instanceof Object)) {\r\n                throw new Error(this.sprintf('The \"headers\" parameter must be an instance of \"Object\". Actual type is: \"%s\".', typeof headers));\r\n            }\r\n            \r\n            headers[Constants.HttpHeaders.IsUpsert] = true;\r\n        },\r\n        \r\n        /** @ignore */\r\n        validateOptionsAndCallback: function (optionsIn, callbackIn) {\r\n            var options, callback;\r\n            \r\n            // options\r\n            if (optionsIn === undefined) {\r\n                options = new Object();\r\n            } else if (callbackIn === undefined && typeof optionsIn === 'function') {\r\n                callback = optionsIn;\r\n                options = new Object();\r\n            } else if (typeof optionsIn !== 'object') {\r\n                throw new Error(this.sprintf('The \"options\" parameter must be of type \"object\". Actual type is: \"%s\".', typeof optionsIn));\r\n            } else {\r\n                options = optionsIn;\r\n            }\r\n            \r\n            // callback\r\n            if (callbackIn !== undefined && typeof callbackIn !== 'function') {\r\n                throw new Error(this.sprintf('The \"callback\" parameter must be of type \"function\". Actual type is: \"%s\".', typeof callbackIn));\r\n            } else if (typeof callbackIn === 'function') {\r\n                callback = callbackIn\r\n            }\r\n            \r\n            return { options: options, callback: callback };\r\n        },\r\n        \r\n        /** @ignore */\r\n        // Like C sprintf, currently only works for %s and %%.\r\n        sprintf: function (format) {\r\n            var args = arguments;\r\n            var i = 1;\r\n            return format.replace(/%((%)|s)/g, function (matchStr, subMatch1, subMatch2) {\r\n                // In case of %% subMatch2 would be '%'.\r\n                return subMatch2 || args[i++];\r\n            });\r\n        }\r\n    }\r\n);\r\n//SCRIPT END\r\n\r\n/**\r\n * The request options\r\n * @typedef {Object} RequestOptions               -         Options that can be specified for a requested issued to the DocumentDB servers.\r\n * @property {string} [preTriggerInclude]         -         Indicates what is the pre trigger to be invoked before the operation.\r\n * @property {string} [postTriggerInclude]        -         Indicates what is the post trigger to be invoked after the operation.\r\n * @property {object} [accessCondition]           -         Conditions Associated with the request.\r\n * @property {string} accessCondition.type        -         Conditional HTTP method header type (IfMatch or IfNoneMatch).\r\n * @property {string} accessCondition.condition   -         Conditional HTTP method header value (the _etag field from the last version you read).\r\n * @property {string} [indexingDirective]         -         Specifies indexing directives (index, do not index .. etc).\r\n * @property {string} [consistencyLevel]          -         Consistency level required by the client.\r\n * @property {string} [sessionToken]              -         Token for use with Session consistency.\r\n * @property {number} [resourceTokenExpirySeconds]-         Expiry time (in seconds) for resource token associated with permission (applicable only for requests on permissions).\r\n * @property {string} [offerType]                 -         Offer type when creating document collections.\r\n */\r\n\r\n/**\r\n * The feed options\r\n * @typedef {Object} FeedOptions                  -         The feed options and query methods.\r\n * @property {number} [maxItemCount]              -         Max number of items to be returned in the enumeration operation.\r\n * @property {string} [continuation]              -         Opaque token for continuing the enumeration.\r\n * @property {string} [sessionToken]              -         Token for use with Session consistency.\r\n * @property {boolean} [EnableScanInQuery]        -         Allow scan on the queries which couldn't be served as indexing was opted out on the requested paths.\r\n *\r\n */\r\n\r\n/**\r\n* The media options\r\n* @typedef {Object} MediaOptions                                          -         Options associated with upload media.\r\n* @property {string} [slug]                                               -         HTTP Slug header value.\r\n* @property {string} [contentType=application/octet-stream]               -         HTTP ContentType header value.\r\n*\r\n*/\r\n\r\n/**\r\n * The Sql query parameter.\r\n * @typedef {Object} SqlParameter\r\n * @property {string} name         -       The name of the parameter.\r\n * @property {string} value        -       The value of the parameter.\r\n */\r\n\r\n/**\r\n* The Sql query specification.\r\n* @typedef {Object} SqlQuerySpec\r\n* @property {string} query                       -       The body of the query.\r\n* @property {Array<SqlParameter>} parameters     -       The array of {@link SqlParameter}.\r\n*/\r\n\r\n/**\r\n* The callback to execute after the request execution.\r\n* @callback RequestCallback\r\n* @param {object} error            -       Will contain error information if an error occurs, undefined otherwise.\r\n* @param {number} error.code       -       The response code corresponding to the error.\r\n* @param {string} error.body       -       A string represents the error information.\r\n* @param {Object} resource         -       An object that represents the requested resource (Db, collection, document ... etc) if no error happens.\r\n* @param {object} responseHeaders  -       An object that contain the response headers.\r\n*/\r\n\r\n/**\r\n* The Indexing Policy represents the indexing policy configuration for a collection.\r\n* @typedef {Object} IndexingPolicy\r\n* @property {boolean} automatic                                           -         Specifies whether automatic indexing is enabled for a collection.\r\n                                                                                   <p>In automatic indexing, documents can be explicitly excluded from indexing using {@link RequestOptions}.\r\n                                                                                   In manual indexing, documents can be explicitly included. </p>\r\n* @property {string} indexingMode                                         -         The indexing mode (consistent or lazy) {@link IndexingMode}.\r\n* @property {Array} IncludedPaths                                         -         An array of {@link IncludedPath} represents the paths to be included for indexing.\r\n* @property {Array} ExcludedPaths                                         -         An array of {@link ExcludedPath} represents the paths to be excluded from indexing.\r\n*\r\n*/\r\n\r\n/**\r\n* <p> Included path. <br>\r\n* </p>\r\n* @typedef {Object} IncludedPath\r\n* @property {Array} Indexes                                               -         An array of {@link Indexes}.\r\n* @property {string} Path                                                 -         Path to be indexed.\r\n*\r\n*/\r\n\r\n/**\r\n* <p> Index specification. <br>\r\n* </p>\r\n* @typedef {Object} Indexes\r\n* @property {string} Kind                                                  -         The index kind {@link IndexKind}.\r\n* @property {string} DataType                                              -         The data type {@link DataType}.\r\n* @property {number} Precision                                             -         The precision.\r\n*\r\n*/\r\n\r\n/**\r\n* <p> Excluded path. <br>\r\n* </p>\r\n* @typedef {Object} ExcludedPath\r\n* @property {string} Path                                                  -         Path to be indexed.\r\n*\r\n*/\r\n\r\nif (typeof exports !== \"undefined\") {\r\n    exports.DocumentClient = DocumentClient;\r\n    exports.DocumentBase = AzureDocuments;\r\n    exports.RetryOptions = RetryOptions;\r\n    exports.Base = Base;\r\n    exports.Constants = Constants;\r\n}\r\n","/home/travis/build/npmtest/node-npmtest-documentdb/node_modules/documentdb/lib/base.js":"/*\r\nThe MIT License (MIT)\r\nCopyright (c) 2014 Microsoft Corporation\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy\r\nof this software and associated documentation files (the \"Software\"), to deal\r\nin the Software without restriction, including without limitation the rights\r\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\ncopies of the Software, and to permit persons to whom the Software is\r\nfurnished to do so, subject to the following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included in all\r\ncopies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\nSOFTWARE.\r\n*/\r\n\r\n\"use strict\";\r\n\r\nvar AuthHandler = require(\"./auth\");\r\nvar Constants = require(\"./constants\");\r\nvar Platform = require(\"./platform\");\r\n\r\n//SCRIPT START\r\nfunction initializeProperties(target, members, prefix) {\r\n    var keys = Object.keys(members);\r\n    var properties;\r\n    var i, len;\r\n    for (i = 0, len = keys.length; i < len; i++) {\r\n        var key = keys[i];\r\n        var enumerable = key.charCodeAt(0) !== /*_*/ 95;\r\n        var member = members[key];\r\n        if (member && typeof member === \"object\") {\r\n            if (member.value !== undefined || typeof member.get === \"function\" || typeof member.set === \"function\") {\r\n                if (member.enumerable === undefined) {\r\n                    member.enumerable = enumerable;\r\n                }\r\n                if (prefix && member.setName && typeof member.setName === \"function\") {\r\n                    member.setName(prefix + \".\" + key);\r\n                }\r\n                properties = properties || {};\r\n                properties[key] = member;\r\n                continue;\r\n            }\r\n        }\r\n        if (!enumerable) {\r\n            properties = properties || {};\r\n            properties[key] = { value: member, enumerable: enumerable, configurable: true, writable: true };\r\n            continue;\r\n        }\r\n        target[key] = member;\r\n    }\r\n    if (properties) {\r\n        Object.defineProperties(target, properties);\r\n    }\r\n}\r\n\r\n/**\r\n*  Defines a new namespace with the specified name under the specified parent namespace.\r\n* @param {Object} parentNamespace - The parent namespace.\r\n* @param {String} name - The name of the new namespace.\r\n* @param {Object} members - The members of the new namespace.\r\n* @returns {Function} - The newly-defined namespace.\r\n*/\r\nfunction defineWithParent(parentNamespace, name, members) {\r\n    var currentNamespace = parentNamespace || {};\r\n    \r\n    if (name) {\r\n        var namespaceFragments = name.split(\".\");\r\n        for (var i = 0, len = namespaceFragments.length; i < len; i++) {\r\n            var namespaceName = namespaceFragments[i];\r\n            if (!currentNamespace[namespaceName]) {\r\n                Object.defineProperty(currentNamespace, namespaceName,\r\n                    { value: {}, writable: false, enumerable: true, configurable: true }\r\n                );\r\n            }\r\n            currentNamespace = currentNamespace[namespaceName];\r\n        }\r\n    }\r\n    \r\n    if (members) {\r\n        initializeProperties(currentNamespace, members, name || \"<ANONYMOUS>\");\r\n    }\r\n    \r\n    return currentNamespace;\r\n}\r\n\r\n/**\r\n*  Defines a new namespace with the specified name.\r\n* @param {String} name - The name of the namespace. This could be a dot-separated name for nested namespaces.\r\n* @param {Object} members - The members of the new namespace.\r\n* @returns {Function} - The newly-defined namespace.\r\n*/\r\nfunction define(name, members) {\r\n    return defineWithParent(undefined, name, members);\r\n}\r\n\r\n/**\r\n*  Defines a class using the given constructor and the specified instance members.\r\n* @param {Function} constructor - A constructor function that is used to instantiate this class.\r\n* @param {Object} instanceMembers - The set of instance fields, properties, and methods to be made available on the class.\r\n* @param {Object} staticMembers - The set of static fields, properties, and methods to be made available on the class.\r\n* @returns {Function} - The newly-defined class.\r\n*/\r\nfunction defineClass(constructor, instanceMembers, staticMembers) {\r\n    constructor = constructor || function () { };\r\n    if (instanceMembers) {\r\n        initializeProperties(constructor.prototype, instanceMembers);\r\n    }\r\n    if (staticMembers) {\r\n        initializeProperties(constructor, staticMembers);\r\n    }\r\n    return constructor;\r\n}\r\n\r\n/**\r\n*  Creates a sub-class based on the supplied baseClass parameter, using prototypal inheritance.\r\n* @param {Function} baseClass - The class to inherit from.\r\n* @param {Function} constructor - A constructor function that is used to instantiate this class.\r\n* @param {Object} instanceMembers - The set of instance fields, properties, and methods to be made available on the class.\r\n* @param {Object} staticMembers - The set of static fields, properties, and methods to be made available on the class.\r\n* @returns {Function} - The newly-defined class.\r\n*/\r\nfunction derive(baseClass, constructor, instanceMembers, staticMembers) {\r\n    if (baseClass) {\r\n        constructor = constructor || function () { };\r\n        var basePrototype = baseClass.prototype;\r\n        constructor.prototype = Object.create(basePrototype);\r\n        Object.defineProperty(constructor.prototype, \"constructor\", { value: constructor, writable: true, configurable: true, enumerable: true });\r\n        if (instanceMembers) {\r\n            initializeProperties(constructor.prototype, instanceMembers);\r\n        }\r\n        if (staticMembers) {\r\n            initializeProperties(constructor, staticMembers);\r\n        }\r\n        return constructor;\r\n    } else {\r\n        return defineClass(constructor, instanceMembers, staticMembers);\r\n    }\r\n}\r\n\r\n/**\r\n*  Defines a class using the given constructor and the union of the set of instance members\r\n*   specified by all the mixin objects. The mixin parameter list is of variable length.\r\n* @param {object} constructor - A constructor function that is used to instantiate this class.\r\n* @returns {Function} - The newly-defined class.\r\n*/\r\nfunction mix(constructor) {\r\n    constructor = constructor || function () { };\r\n    var i, len;\r\n    for (i = 1, len = arguments.length; i < len; i++) {\r\n        initializeProperties(constructor.prototype, arguments[i]);\r\n    }\r\n    return constructor;\r\n}\r\n\r\nvar Base = {\r\n    NotImplementedException: \"NotImplementedException\",\r\n    \r\n    defineWithParent: defineWithParent,\r\n    \r\n    define: define,\r\n    \r\n    defineClass: defineClass,\r\n    \r\n    derive: derive,\r\n    \r\n    mix: mix,\r\n    \r\n    extend: function (obj, extent) {\r\n        for (var property in extent) {\r\n            if (typeof extent[property] !== \"function\") {\r\n                obj[property] = extent[property];\r\n            }\r\n        }\r\n        return obj;\r\n    },\r\n    \r\n    map: function (list, fn) {\r\n        var result = [];\r\n        for (var i = 0, n = list.length; i < n; i++) {\r\n            result.push(fn(list[i]));\r\n        }\r\n        \r\n        return result;\r\n    },\r\n    \r\n    getHeaders: function (documentClient, defaultHeaders, verb, path, resourceId, resourceType, options, partitionKeyRangeId) {\r\n        \r\n        var headers = Base.extend({}, defaultHeaders);\r\n        options = options || {};\r\n        \r\n        if (options.continuation) {\r\n            headers[Constants.HttpHeaders.Continuation] = options.continuation;\r\n        }\r\n        \r\n        if (options.preTriggerInclude) {\r\n            headers[Constants.HttpHeaders.PreTriggerInclude] = options.preTriggerInclude.constructor === Array ? options.preTriggerInclude.join(\",\") : options.preTriggerInclude;\r\n        }\r\n        \r\n        if (options.postTriggerInclude) {\r\n            headers[Constants.HttpHeaders.PostTriggerInclude] = options.postTriggerInclude.constructor === Array ? options.postTriggerInclude.join(\",\") : options.postTriggerInclude;\r\n        }\r\n        \r\n        if (options.offerType) {\r\n            headers[Constants.HttpHeaders.OfferType] = options.offerType;\r\n        }\r\n        \r\n        if (options.offerThroughput) {\r\n            headers[Constants.HttpHeaders.OfferThroughput] = options.offerThroughput;\r\n        }\r\n        \r\n        if (options.maxItemCount) {\r\n            headers[Constants.HttpHeaders.PageSize] = options.maxItemCount;\r\n        }\r\n        \r\n        if (options.accessCondition) {\r\n            if (options.accessCondition.type === \"IfMatch\") {\r\n                headers[Constants.HttpHeaders.IfMatch] = options.accessCondition.condition;\r\n            } else {\r\n                headers[Constants.HttpHeaders.IfNoneMatch] = options.accessCondition.condition;\r\n            }\r\n        }\r\n        \r\n        if (options.indexingDirective) {\r\n            headers[Constants.HttpHeaders.IndexingDirective] = options.indexingDirective;\r\n        }\r\n        \r\n        // TODO: add consistency level validation.\r\n        if (options.consistencyLevel) {\r\n            headers[Constants.HttpHeaders.ConsistencyLevel] = options.consistencyLevel;\r\n        }\r\n        \r\n        if (options.resourceTokenExpirySeconds) {\r\n            headers[Constants.HttpHeaders.ResourceTokenExpiry] = options.resourceTokenExpirySeconds;\r\n        }\r\n        \r\n        // TODO: add session token automatic handling in case of session consistency.\r\n        if (options.sessionToken) {\r\n            headers[Constants.HttpHeaders.SessionToken] = options.sessionToken;\r\n        }\r\n        \r\n        if (options.enableScanInQuery) {\r\n            headers[Constants.HttpHeaders.EnableScanInQuery] = options.enableScanInQuery;\r\n        }\r\n        \r\n        if (options.enableCrossPartitionQuery) {\r\n            headers[Constants.HttpHeaders.EnableCrossPartitionQuery] = options.enableCrossPartitionQuery;\r\n        }\r\n\r\n        if (options.maxDegreeOfParallelism) {\r\n            headers[Constants.HttpHeaders.ParallelizeCrossPartitionQuery] = true;\r\n        }\r\n\r\n        if (options.populateQuotaInfo) {\r\n            headers[Constants.HttpHeaders.PopulateQuotaInfo] = true;\r\n        }\r\n        \r\n        // If the user is not using partition resolver, we add options.partitonKey to the header for elastic collections\r\n        if (documentClient.partitionResolver === undefined || documentClient.partitionResolver === null) {\r\n            if (options.partitionKey !== undefined) {\r\n                var partitionKey = options.partitionKey;\r\n                if (partitionKey === null || partitionKey.constructor !== Array) {\r\n                    partitionKey = [partitionKey];\r\n                }\r\n                \r\n                headers[Constants.HttpHeaders.PartitionKey] = JSON.stringify(partitionKey);\r\n            }\r\n        }\r\n        \r\n        if (documentClient.masterKey) {\r\n            headers[Constants.HttpHeaders.XDate] = new Date().toUTCString();\r\n        }\r\n        \r\n        if (documentClient.masterKey || documentClient.resourceTokens) {\r\n            headers[Constants.HttpHeaders.Authorization] = encodeURIComponent(AuthHandler.getAuthorizationHeader(documentClient, verb, path, resourceId, resourceType, headers));\r\n        }\r\n        \r\n        if (verb === \"post\" || verb === \"put\") {\r\n            if (!headers[Constants.HttpHeaders.ContentType]) {\r\n                headers[Constants.HttpHeaders.ContentType] = Constants.MediaTypes.Json;\r\n            }\r\n        }\r\n        \r\n        if (!headers[Constants.HttpHeaders.Accept]) {\r\n            headers[Constants.HttpHeaders.Accept] = Constants.MediaTypes.Json;\r\n        }\r\n        \r\n        if (partitionKeyRangeId !== undefined) {\r\n            headers[Constants.HttpHeaders.PartitionKeyRangeID] = partitionKeyRangeId;\r\n        }\r\n\r\n        if (options.enableScriptLogging ) {\r\n            headers[Constants.HttpHeaders.EnableScriptLogging] = options.enableScriptLogging;\r\n        }\r\n\r\n        return headers;\r\n    },\r\n    \r\n    /** @ignore */\r\n    parseLink: function (resourcePath) {\r\n        if (resourcePath.length === 0) {\r\n            /* for DatabaseAccount case, both type and objectBody will be undefined. */\r\n            return {\r\n                type: undefined,\r\n                objectBody: undefined\r\n            };\r\n        }\r\n        \r\n        if (resourcePath[resourcePath.length - 1] !== \"/\") {\r\n            resourcePath = resourcePath + \"/\";\r\n        }\r\n        \r\n        if (resourcePath[0] !== \"/\") {\r\n            resourcePath = \"/\" + resourcePath;\r\n        }\r\n        \r\n        /*\r\n        / The path will be in the form of /[resourceType]/[resourceId]/ .... /[resourceType]//[resourceType]/[resourceId]/ .... /[resourceType]/[resourceId]/\r\n        / or /[resourceType]/[resourceId]/ .... /[resourceType]/[resourceId]/[resourceType]/[resourceId]/ .... /[resourceType]/[resourceId]/\r\n        / The result of split will be in the form of [[[resourceType], [resourceId] ... ,[resourceType], [resourceId], \"\"]\r\n        / In the first case, to extract the resourceId it will the element before last ( at length -2 ) and the the type will before it ( at length -3 )\r\n        / In the second case, to extract the resource type it will the element before last ( at length -2 )\r\n        */\r\n        var pathParts = resourcePath.split(\"/\");\r\n        var id, type;\r\n        if (pathParts.length % 2 === 0) {\r\n            // request in form /[resourceType]/[resourceId]/ .... /[resourceType]/[resourceId].\r\n            id = pathParts[pathParts.length - 2];\r\n            type = pathParts[pathParts.length - 3];\r\n        } else {\r\n            // request in form /[resourceType]/[resourceId]/ .... /[resourceType]/.\r\n            id = pathParts[pathParts.length - 3];\r\n            type = pathParts[pathParts.length - 2];\r\n        }\r\n        \r\n        var result = {\r\n            type: type,\r\n            objectBody: {\r\n                id: id,\r\n                self: resourcePath\r\n            }\r\n        };\r\n        \r\n        return result;\r\n    },\r\n    \r\n    /** @ignore */\r\n    parsePath: function (path) {\r\n        var pathParts = [];\r\n        var currentIndex = 0;\r\n        \r\n        var throwError = function () {\r\n            throw new Error(\"Path \" + path + \" is invalid at index \" + currentIndex);\r\n        };\r\n        \r\n        var getEscapedToken = function () {\r\n            var quote = path[currentIndex];\r\n            var newIndex = ++currentIndex;\r\n            \r\n            while (true) {\r\n                newIndex = path.indexOf(quote, newIndex);\r\n                if (newIndex == -1) {\r\n                    throwError();\r\n                }\r\n                \r\n                if (path[newIndex - 1] !== '\\\\') break;\r\n                \r\n                ++newIndex;\r\n            }\r\n            \r\n            var token = path.substr(currentIndex, newIndex - currentIndex);\r\n            currentIndex = newIndex + 1;\r\n            return token;\r\n        };\r\n        \r\n        var getToken = function () {\r\n            var newIndex = path.indexOf('/', currentIndex);\r\n            var token = null;\r\n            if (newIndex == -1) {\r\n                token = path.substr(currentIndex);\r\n                currentIndex = path.length;\r\n            }\r\n            else {\r\n                token = path.substr(currentIndex, newIndex - currentIndex);\r\n                currentIndex = newIndex;\r\n            }\r\n            \r\n            token = token.trim();\r\n            return token;\r\n        };\r\n        \r\n        while (currentIndex < path.length) {\r\n            if (path[currentIndex] !== '/') {\r\n                throwError();\r\n            }\r\n            \r\n            if (++currentIndex == path.length) break;\r\n            \r\n            if (path[currentIndex] === '\\\"' || path[currentIndex] === '\\'') {\r\n                pathParts.push(getEscapedToken());\r\n            }\r\n            else {\r\n                pathParts.push(getToken());\r\n            }\r\n        }\r\n        \r\n        return pathParts;\r\n    },\r\n    \r\n    /** @ignore */\r\n    getDatabaseLink: function (link) {\r\n        return link.split('/').slice(0, 2).join('/');\r\n    },\r\n    \r\n    /** @ignore */\r\n    getCollectionLink: function (link) {\r\n        return link.split('/').slice(0, 4).join('/');\r\n    },\r\n    \r\n    /** @ignore */\r\n    getAttachmentIdFromMediaId: function (mediaId) {\r\n        // Replace - with / on the incoming mediaId.  This will preserve the / so that we can revert it later.\r\n        var buffer = new Buffer(mediaId.replace(/-/g, \"/\"), \"base64\");\r\n        var ResoureIdLength = 20;\r\n        var attachmentId = \"\";\r\n        if (buffer.length > ResoureIdLength) {\r\n            // After the base64 conversion, change the / back to a - to get the proper attachmentId\r\n            attachmentId = buffer.toString(\"base64\", 0, ResoureIdLength).replace(/\\//g, \"-\");\r\n        } else {\r\n            attachmentId = mediaId;\r\n        }\r\n        \r\n        return attachmentId;\r\n    },\r\n    \r\n    /** @ignore */\r\n    getHexaDigit: function () {\r\n        return Math.floor(Math.random() * 16).toString(16);\r\n    },\r\n    \r\n    /** @ignore */\r\n    generateGuidId: function () {\r\n        var id = \"\";\r\n        \r\n        for (var i = 0; i < 8; i++) {\r\n            id += Base.getHexaDigit();\r\n        }\r\n        \r\n        id += \"-\";\r\n        \r\n        for (var i = 0; i < 4; i++) {\r\n            id += Base.getHexaDigit();\r\n        }\r\n        \r\n        id += \"-\";\r\n        \r\n        for (var i = 0; i < 4; i++) {\r\n            id += Base.getHexaDigit();\r\n        }\r\n        \r\n        id += \"-\";\r\n        \r\n        for (var i = 0; i < 4; i++) {\r\n            id += Base.getHexaDigit();\r\n        }\r\n        \r\n        id += \"-\";\r\n        \r\n        for (var i = 0; i < 12; i++) {\r\n            id += Base.getHexaDigit();\r\n        }\r\n        \r\n        return id;\r\n    },\r\n    \r\n    isLinkNameBased: function (link) {\r\n        var parts = link.split(\"/\");\r\n        var firstId = \"\";\r\n        var count = 0;\r\n        // Get the first id from path.\r\n        for (var i = 0; i < parts.length; ++i) {\r\n            if (!parts[i]) {\r\n                // Skip empty string.\r\n                continue;\r\n            }\r\n            ++count;\r\n            if (count === 1 && parts[i].toLowerCase() !== \"dbs\") {\r\n                return false;\r\n            }\r\n            if (count === 2) {\r\n                firstId = parts[i];\r\n                break;\r\n            }\r\n        }\r\n        if (!firstId) return false;\r\n        if (firstId.length !== 8) return true;\r\n        var buffer = new Buffer(firstId, \"base64\");\r\n        if (buffer.length !== 4) return true;\r\n        return false;\r\n    },\r\n    /** @ignore */\r\n    _trimSlashes: function (source) {\r\n        return source.replace(Constants.RegularExpressions.TrimLeftSlashes, \"\")\r\n                     .replace(Constants.RegularExpressions.TrimRightSlashes, \"\");\r\n    },\r\n    \r\n    /** @ignore */\r\n    _isValidCollectionLink: function (link) {\r\n        if (typeof link !== \"string\") {\r\n            return false;\r\n        }\r\n        \r\n        var parts = Base._trimSlashes(link).split(\"/\");\r\n        \r\n        if (parts && parts.length !== 4) {\r\n            return false;\r\n        }\r\n        \r\n        if (parts[0] !== \"dbs\") {\r\n            return false;\r\n        }\r\n        \r\n        if (parts[2] !== \"colls\") {\r\n            return false;\r\n        }\r\n        \r\n        return true;\r\n    },\r\n    /** @ignore */\r\n    _getUserAgent: function () {\r\n        return Platform.getUserAgent();\r\n    }\r\n};\r\n//SCRIPT END\r\n\r\nif (typeof exports !== \"undefined\") {\r\n    module.exports = Base;\r\n}\r\n","/home/travis/build/npmtest/node-npmtest-documentdb/node_modules/documentdb/lib/auth.js":"/*\r\nThe MIT License (MIT)\r\nCopyright (c) 2014 Microsoft Corporation\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy\r\nof this software and associated documentation files (the \"Software\"), to deal\r\nin the Software without restriction, including without limitation the rights\r\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\ncopies of the Software, and to permit persons to whom the Software is\r\nfurnished to do so, subject to the following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included in all\r\ncopies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\nSOFTWARE.\r\n*/\r\n\r\n\"use strict\";\r\n\r\nvar crypto = require(\"crypto\");\r\n\r\nvar AuthHandler = {\r\n    getAuthorizationHeader: function (documentClient, verb, path, resourceId, resourceType, headers) {\r\n        if (documentClient.masterKey) {\r\n            return this.getAuthorizationTokenUsingMasterKey(verb, resourceId, resourceType, headers, documentClient.masterKey);\r\n        } else if (documentClient.resourceTokens) {\r\n            return this.getAuthorizationTokenUsingResourceTokens(documentClient.resourceTokens, path, resourceId);\r\n        }\r\n    },\r\n\r\n    getAuthorizationTokenUsingMasterKey: function (verb, resourceId, resourceType, headers, masterKey) {\r\n        var key = new Buffer(masterKey, \"base64\");\r\n\r\n        var text = (verb || \"\").toLowerCase() + \"\\n\" +\r\n                   (resourceType || \"\").toLowerCase() + \"\\n\" +\r\n                   (resourceId || \"\") + \"\\n\" +\r\n                   (headers[\"x-ms-date\"] || \"\").toLowerCase() + \"\\n\" +\r\n                   (headers[\"date\"] || \"\").toLowerCase() + \"\\n\";\r\n\r\n        var body = new Buffer(text, \"utf8\");\r\n\r\n        var signature = crypto.createHmac(\"sha256\", key).update(body).digest(\"base64\");\r\n\r\n        var MasterToken = \"master\";\r\n\r\n        var TokenVersion = \"1.0\";\r\n\r\n        return \"type=\" + MasterToken + \"&ver=\" + TokenVersion + \"&sig=\" + signature;\r\n    },\r\n\r\n    getAuthorizationTokenUsingResourceTokens: function (resourceTokens, path, resourceId) {\r\n        if (resourceTokens && Object.keys(resourceTokens).length > 0) {\r\n            // For database account access(through getDatabaseAccount API), path and resourceId are \"\", \r\n            // so in this case we return the first token to be used for creating the auth header as the service will accept any token in this case\r\n            if (!path && !resourceId) {\r\n                return resourceTokens[Object.keys(resourceTokens)[0]];\r\n            }\r\n            if (resourceTokens[resourceId]) {\r\n                return resourceTokens[resourceId];\r\n            } else {\r\n\t\t\t\tvar pathParts = path && path.split(\"/\") || [];\r\n                var resourceTypes = [\"dbs\", \"colls\", \"docs\", \"sprocs\", \"udfs\", \"triggers\", \"users\", \"permissions\", \"attachments\", \"media\", \"conflicts\", \"offers\"];\r\n                // Get the last resource id from the path and get it's token from resourceTokens\r\n                for (var i = pathParts.length - 1; i >= 0; i--) {\r\n                    if (resourceTypes.indexOf(pathParts[i]) === -1) {\r\n                        if (resourceTokens[pathParts[i]]) {\r\n                            return resourceTokens[pathParts[i]];\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n};\r\n\r\nif (typeof exports !== \"undefined\") {\r\n    module.exports = AuthHandler;\r\n}","/home/travis/build/npmtest/node-npmtest-documentdb/node_modules/documentdb/lib/constants.js":"/*\r\nThe MIT License (MIT)\r\nCopyright (c) 2014 Microsoft Corporation\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy\r\nof this software and associated documentation files (the \"Software\"), to deal\r\nin the Software without restriction, including without limitation the rights\r\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\ncopies of the Software, and to permit persons to whom the Software is\r\nfurnished to do so, subject to the following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included in all\r\ncopies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\nSOFTWARE.\r\n*/\r\n\r\n\r\n//SCRIPT START\r\n\r\nvar Constants = {\r\n    MediaTypes: {\r\n        Any: \"*/*\",\r\n        ImageJpeg: \"image/jpeg\",\r\n        ImagePng: \"image/png\",\r\n        Javascript: \"application/x-javascript\",\r\n        Json: \"application/json\",\r\n        OctetStream: \"application/octet-stream\",\r\n        QueryJson: \"application/query+json\",\r\n        SQL: \"application/sql\",\r\n        TextHtml: \"text/html\",\r\n        TextPlain: \"text/plain\",\r\n        Xml: \"application/xml\"\r\n    },\r\n    \r\n    HttpMethods: {\r\n        Get: \"GET\",\r\n        Post: \"POST\",\r\n        Put: \"PUT\",\r\n        Delete: \"DELETE\",\r\n        Head: \"HEAD\",\r\n        Options: \"OPTIONS\"\r\n    },\r\n    \r\n    HttpHeaders: {\r\n        Authorization: \"authorization\",\r\n        ETag: \"etag\",\r\n        MethodOverride: \"X-HTTP-Method\",\r\n        Slug: \"Slug\",\r\n        ContentType: \"Content-Type\",\r\n        LastModified: \"Last-Modified\",\r\n        ContentEncoding: \"Content-Encoding\",\r\n        CharacterSet: \"CharacterSet\",\r\n        UserAgent: \"User-Agent\",\r\n        IfModifiedSince: \"If-Modified-Since\",\r\n        IfMatch: \"If-Match\",\r\n        IfNoneMatch: \"If-None-Match\",\r\n        ContentLength: \"Content-Length\",\r\n        AcceptEncoding: \"Accept-Encoding\",\r\n        KeepAlive: \"Keep-Alive\",\r\n        CacheControl: \"Cache-Control\",\r\n        TransferEncoding: \"Transfer-Encoding\",\r\n        ContentLanguage: \"Content-Language\",\r\n        ContentLocation: \"Content-Location\",\r\n        ContentMd5: \"Content-Md5\",\r\n        ContentRange: \"Content-Range\",\r\n        Accept: \"Accept\",\r\n        AcceptCharset: \"Accept-Charset\",\r\n        AcceptLanguage: \"Accept-Language\",\r\n        IfRange: \"If-Range\",\r\n        IfUnmodifiedSince: \"If-Unmodified-Since\",\r\n        MaxForwards: \"Max-Forwards\",\r\n        ProxyAuthorization: \"Proxy-Authorization\",\r\n        AcceptRanges: \"Accept-Ranges\",\r\n        ProxyAuthenticate: \"Proxy-Authenticate\",\r\n        RetryAfter: \"Retry-After\",\r\n        SetCookie: \"Set-Cookie\",\r\n        WwwAuthenticate: \"Www-Authenticate\",\r\n        Origin: \"Origin\",\r\n        Host: \"Host\",\r\n        AccessControlAllowOrigin: \"Access-Control-Allow-Origin\",\r\n        AccessControlAllowHeaders: \"Access-Control-Allow-Headers\",\r\n        KeyValueEncodingFormat: \"application/x-www-form-urlencoded\",\r\n        WrapAssertionFormat: \"wrap_assertion_format\",\r\n        WrapAssertion: \"wrap_assertion\",\r\n        WrapScope: \"wrap_scope\",\r\n        SimpleToken: \"SWT\",\r\n        HttpDate: \"date\",\r\n        Prefer: \"Prefer\",\r\n        Location: \"Location\",\r\n        Referer: \"referer\",\r\n        \r\n        // Query\r\n        Query: \"x-ms-documentdb-query\",\r\n        IsQuery: \"x-ms-documentdb-isquery\",\r\n        \r\n        // Our custom DocumentDB headers\r\n        Continuation: \"x-ms-continuation\",\r\n        PageSize: \"x-ms-max-item-count\",\r\n        \r\n        // Request sender generated. Simply echoed by backend.\r\n        ActivityId: \"x-ms-activity-id\",\r\n        PreTriggerInclude: \"x-ms-documentdb-pre-trigger-include\",\r\n        PreTriggerExclude: \"x-ms-documentdb-pre-trigger-exclude\",\r\n        PostTriggerInclude: \"x-ms-documentdb-post-trigger-include\",\r\n        PostTriggerExclude: \"x-ms-documentdb-post-trigger-exclude\",\r\n        IndexingDirective: \"x-ms-indexing-directive\",\r\n        SessionToken: \"x-ms-session-token\",\r\n        ConsistencyLevel: \"x-ms-consistency-level\",\r\n        XDate: \"x-ms-date\",\r\n        CollectionPartitionInfo: \"x-ms-collection-partition-info\",\r\n        CollectionServiceInfo: \"x-ms-collection-service-info\",\r\n        RetryAfterInMilliseconds: \"x-ms-retry-after-ms\",\r\n        IsFeedUnfiltered: \"x-ms-is-feed-unfiltered\",\r\n        ResourceTokenExpiry: \"x-ms-documentdb-expiry-seconds\",\r\n        EnableScanInQuery: \"x-ms-documentdb-query-enable-scan\",\r\n        EmitVerboseTracesInQuery: \"x-ms-documentdb-query-emit-traces\",\r\n        EnableCrossPartitionQuery: \"x-ms-documentdb-query-enablecrosspartition\",\r\n        ParallelizeCrossPartitionQuery: \"x-ms-documentdb-query-parallelizecrosspartitionquery\",\r\n\r\n        // Version headers and values\r\n        Version: \"x-ms-version\",\r\n        \r\n        // Partition Key\r\n        PartitionKey: \"x-ms-documentdb-partitionkey\",\r\n        PartitionKeyRangeID: 'x-ms-documentdb-partitionkeyrangeid',\r\n\r\n        //Quota Info\r\n        MaxEntityCount: \"x-ms-root-entity-max-count\",\r\n        CurrentEntityCount: \"x-ms-root-entity-current-count\",\r\n        CollectionQuotaInMb: \"x-ms-collection-quota-mb\",\r\n        CollectionCurrentUsageInMb: \"x-ms-collection-usage-mb\",\r\n        MaxMediaStorageUsageInMB: \"x-ms-max-media-storage-usage-mb\",\r\n        CurrentMediaStorageUsageInMB: \"x-ms-media-storage-usage-mb\",\r\n        RequestCharge: \"x-ms-request-charge\",\r\n        PopulateQuotaInfo: \"x-ms-documentdb-populatequotainfo\",\r\n        MaxResourceQuota: \"x-ms-resource-quota\",\r\n        \r\n        // Offer header\r\n        OfferType: \"x-ms-offer-type\",\r\n        OfferThroughput: \"x-ms-offer-throughput\",\r\n        \r\n        // Index progress headers\r\n        IndexTransformationProgress: \"x-ms-documentdb-collection-index-transformation-progress\",\r\n        LazyIndexingProgress: \"x-ms-documentdb-collection-lazy-indexing-progress\",\r\n        \r\n        // Upsert header\r\n        IsUpsert: \"x-ms-documentdb-is-upsert\",\r\n\r\n        // Sub status of the error\r\n        SubStatus: \"x-ms-substatus\",\r\n\r\n        // StoredProcedure related headers\r\n        EnableScriptLogging: \"x-ms-documentdb-script-enable-logging\",\r\n        ScriptLogResults: \"x-ms-documentdb-script-log-results\"\r\n    },\r\n    \r\n    // GlobalDB related constants\r\n    WritableLocations: 'writableLocations',\r\n    ReadableLocations: 'readableLocations',\r\n    Name: 'name',\r\n    DatabaseAccountEndpoint: 'databaseAccountEndpoint',\r\n    \r\n    // Client generated retry count response header\r\n    ThrottleRetryCount: \"x-ms-throttle-retry-count\",\r\n    ThrottleRetryWaitTimeInMs: \"x-ms-throttle-retry-wait-time-ms\",\r\n    \r\n    CurrentVersion: \"2017-01-19\",\r\n    \r\n    SDKName: \"documentdb-nodejs-sdk\",\r\n    SDKVersion: \"1.11.0\",\r\n\r\n    DefaultPrecisions: {\r\n        DefaultNumberHashPrecision: 3,\r\n        DefaultNumberRangePrecision: -1,\r\n        DefaultStringHashPrecision: 3,\r\n        DefaultStringRangePrecision: -1\r\n    },\r\n    \r\n    ConsistentHashRing: {\r\n        DefaultVirtualNodesPerCollection: 128\r\n    },\r\n    \r\n    RegularExpressions: {\r\n        TrimLeftSlashes: new RegExp(\"^[/]+\"),\r\n        TrimRightSlashes: new RegExp(\"[/]+$\")\r\n    },\r\n\r\n    Quota: {\r\n        CollectionSize: \"collectionSize\"\r\n    }\r\n};\r\n\r\n//SCRIPT END\r\n\r\nif (typeof exports !== \"undefined\") {\r\n    module.exports = Constants;\r\n}\r\n","/home/travis/build/npmtest/node-npmtest-documentdb/node_modules/documentdb/lib/platform.js":"/*\r\nThe MIT License (MIT)\r\nCopyright (c) 2014 Microsoft Corporation\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy\r\nof this software and associated documentation files (the \"Software\"), to deal\r\nin the Software without restriction, including without limitation the rights\r\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\ncopies of the Software, and to permit persons to whom the Software is\r\nfurnished to do so, subject to the following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included in all\r\ncopies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\nSOFTWARE.\r\n*/\r\n\r\n\"use strict\";\r\n\r\nvar Constants = require(\"./constants\");\r\nvar os = require(\"os\");\r\nvar util = require(\"util\");\r\n\r\nvar Platform = {\r\n\r\n    /** @ignore */\r\n    getUserAgent: function () {\r\n        // gets the user agent in the following format\r\n        // \"{OSName}/{OSVersion} Nodejs/{NodejsVersion} documentdb-nodejs-sdk/{SDKVersion}\"\r\n        // for example:\r\n        // \"linux/3.4.0+ Nodejs/v0.10.25 documentdb-nodejs-sdk/1.10.0\"\r\n        // \"win32/10.0.14393 Nodejs/v4.4.7 documentdb-nodejs-sdk/1.10.0\"\r\n        var osName = Platform._getSafeUserAgentSegmentInfo(os.platform());\r\n        var osVersion = Platform._getSafeUserAgentSegmentInfo(os.release());\r\n        var nodejsVersion = Platform._getSafeUserAgentSegmentInfo(process.version);\r\n\r\n        var userAgent = util.format(\"%s/%s Nodejs/%s %s/%s\", osName, osVersion,\r\n            nodejsVersion,\r\n            Constants.SDKName, Constants.SDKVersion);\r\n\r\n        return userAgent;\r\n    },\r\n    /** @ignore */\r\n    _getSafeUserAgentSegmentInfo: function (s) {\r\n        // catch null, undefined, etc\r\n        if (typeof (s) !== 'string') {\r\n            s = \"unknown\";\r\n        }\r\n        // remove all white spaces\r\n        s = s.replace(/\\s+/g, '');\r\n        if (!s) {\r\n            s = \"unknown\";\r\n        }\r\n        return s\r\n    }\r\n}\r\n\r\nif (typeof exports !== \"undefined\") {\r\n    module.exports = Platform;\r\n}","/home/travis/build/npmtest/node-npmtest-documentdb/node_modules/documentdb/lib/documents.js":"/*\r\nThe MIT License (MIT)\r\nCopyright (c) 2014 Microsoft Corporation\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy\r\nof this software and associated documentation files (the \"Software\"), to deal\r\nin the Software without restriction, including without limitation the rights\r\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\ncopies of the Software, and to permit persons to whom the Software is\r\nfurnished to do so, subject to the following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included in all\r\ncopies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\nSOFTWARE.\r\n*/\r\n\r\n\"use strict\";\r\n\r\nvar Base = require(\"./base\"),\r\n    RetryOptions = require(\"./retryOptions\");\r\n//SCRIPT START\r\n\r\nvar AzureDocuments = Base.defineClass(null, null,\r\n    {\r\n       /**\r\n         * Represents a DatabaseAccount in the Azure DocumentDB database service. A DatabaseAccount is the container for databases.\r\n         * @global\r\n         * @property {string} DatabasesLink                                     -  The self-link for Databases in the databaseAccount.\r\n         * @property {string} MediaLink                                         -  The self-link for Media in the databaseAccount.\r\n         * @property {number} MaxMediaStorageUsageInMB                          -  Attachment content (media) storage quota in MBs ( Retrieved from gateway ).\r\n         * @property {number} CurrentMediaStorageUsageInMB                      -  <p> Current attachment content (media) usage in MBs (Retrieved from gateway )<br>\r\n                                                                                    Value is returned from cached information updated periodically and is not guaranteed to be real time. </p>\r\n         * @property {object} ConsistencyPolicy                                 -  Gets the UserConsistencyPolicy settings.\r\n         * @property {string} ConsistencyPolicy.defaultConsistencyLevel         -  The default consistency level and it's of type {@link ConsistencyLevel}.\r\n         * @property {number} ConsistencyPolicy.maxStalenessPrefix              -  In bounded staleness consistency, the maximum allowed staleness in terms difference in sequence numbers (aka version).\r\n         * @property {number} ConsistencyPolicy.maxStalenessIntervalInSeconds   -  In bounded staleness consistency, the maximum allowed staleness in terms time interval.\r\n         \r\n         * @property {Array}  WritableLocations                                 -  The list of writable locations for a geo-replicated database account.\r\n         * @property {Array}  ReadableLocations                                 -  The list of readable locations for a geo-replicated database account.\r\n         */\r\n        DatabaseAccount: Base.defineClass(function () {\r\n            this._writableLocations = [];\r\n            this._readableLocations = [];\r\n\r\n            Object.defineProperty(this, \"DatabasesLink\", {\r\n                value: \"\",\r\n                writable: true,\r\n                configurable: true,\r\n                enumerable: true\r\n            });\r\n\r\n            Object.defineProperty(this, \"MediaLink\", {\r\n                value: \"\",\r\n                writable: true,\r\n                configurable: true,\r\n                enumerable: true\r\n            });\r\n\r\n            Object.defineProperty(this, \"MaxMediaStorageUsageInMB\", {\r\n                value: 0,\r\n                writable: true,\r\n                configurable: true,\r\n                enumerable: true\r\n            });\r\n\r\n            Object.defineProperty(this, \"CurrentMediaStorageUsageInMB\", {\r\n                value: 0,\r\n                writable: true,\r\n                configurable: true,\r\n                enumerable: true\r\n            });\r\n\r\n            Object.defineProperty(this, \"ConsumedDocumentStorageInMB\", {\r\n                value: 0,\r\n                writable: true,\r\n                configurable: true,\r\n                enumerable: true\r\n            });\r\n\r\n            Object.defineProperty(this, \"ReservedDocumentStorageInMB\", {\r\n                value: 0,\r\n                writable: true,\r\n                configurable: true,\r\n                enumerable: true\r\n            });\r\n\r\n            Object.defineProperty(this, \"ProvisionedDocumentStorageInMB\", {\r\n                value: 0,\r\n                writable: true,\r\n                configurable: true,\r\n                enumerable: true\r\n            });\r\n\r\n            Object.defineProperty(this, \"ConsistencyPolicy\", {\r\n                value: \"\",\r\n                writable: true,\r\n                configurable: true,\r\n                enumerable: true\r\n            });\r\n        \r\n            Object.defineProperty(this, \"WritableLocations\", {\r\n                get: function () {\r\n                    return this._writableLocations;\r\n                },\r\n                enumerable: true\r\n            });\r\n\r\n            Object.defineProperty(this, \"ReadableLocations\", {\r\n                get: function () {\r\n                    return this._readableLocations;\r\n                },\r\n                enumerable: true\r\n            });\r\n        }),\r\n\r\n        /**\r\n         * <p>Represents the consistency levels supported for DocumentDB client operations.<br>\r\n         * The requested ConsistencyLevel must match or be weaker than that provisioned for the database account. Consistency levels.<br>\r\n         * Consistency levels by order of strength are Strong, BoundedStaleness, Session and Eventual.</p>\r\n         * @readonly\r\n         * @enum {string}\r\n         * @property Strong           Strong Consistency guarantees that read operations always return the value that was last written.\r\n         * @property BoundedStaleness Bounded Staleness guarantees that reads are not too out-of-date. This can be configured based on number of operations (MaxStalenessPrefix) or time (MaxStalenessIntervalInSeconds).\r\n         * @property Session          Session Consistency guarantees monotonic reads (you never read old data, then new, then old again), monotonic writes (writes are ordered)\r\n                                      and read your writes (your writes are immediately visible to your reads) within any single session.\r\n         * @property Eventual         Eventual Consistency guarantees that reads will return a subset of writes. All writes\r\n                                      will be eventually be available for reads.\r\n         */\r\n        ConsistencyLevel: Object.freeze({\r\n            Strong: \"Strong\",\r\n            BoundedStaleness: \"BoundedStaleness\",\r\n            Session: \"Session\",\r\n            Eventual: \"Eventual\"\r\n        }),\r\n\r\n\r\n        /**\r\n         * Specifies the supported indexing modes.\r\n         * @readonly\r\n         * @enum {string}\r\n         * @property Consistent     <p>Index is updated synchronously with a create or update operation. <br>\r\n                                    With consistent indexing, query behavior is the same as the default consistency level for the collection. The index is\r\n                                    always kept up to date with the data. </p>\r\n         * @property Lazy           <p>Index is updated asynchronously with respect to a create or update operation. <br>\r\n                                    With lazy indexing, queries are eventually consistent. The index is updated when the collection is idle.</p>\r\n         */\r\n        IndexingMode: Object.freeze({\r\n            Consistent: \"consistent\",\r\n            Lazy: \"lazy\",\r\n            None: \"none\"\r\n        }),\r\n\r\n        /**\r\n         * Specifies the supported Index types.\r\n         * @readonly\r\n         * @enum {string}\r\n         * @property Hash     This is supplied for a path which has no sorting requirement.\r\n         *                    This kind of an index has better precision than corresponding range index.\r\n         * @property Range    This is supplied for a path which requires sorting.\r\n         * @property Spatial  This is supplied for a path which requires geospatial indexing.\r\n         */\r\n\r\n        IndexKind: Object.freeze({\r\n            Hash: \"Hash\",\r\n            Range: \"Range\",\r\n            Spatial: \"Spatial\"\r\n        }),\r\n\r\n        DataType: Object.freeze({\r\n            Number: \"Number\",\r\n            String: \"String\",\r\n            Point: \"Point\",\r\n            LineString: \"LineString\",\r\n            Polygon: \"Polygon\"\r\n        }),\r\n\r\n        PartitionKind: Object.freeze({\r\n            Hash: \"Hash\"\r\n        }),\r\n\r\n        ConnectionMode: Object.freeze({\r\n            Gateway: 0\r\n        }),\r\n\r\n        QueryCompatibilityMode: Object.freeze({\r\n            Default: 0,\r\n            Query: 1,\r\n            SqlQuery: 2\r\n        }),\r\n\r\n        /**\r\n         * Enum for media read mode values.\r\n         * @readonly\r\n         * @enum {sting}\r\n         * @property Buffered Content is buffered at the client and not directly streamed from the content store.\r\n                              <p>Use Buffered to reduce the time taken to read and write media files.</p>\r\n         * @property Streamed Content is directly streamed from the content store without any buffering at the client.\r\n                              <p>Use Streamed to reduce the client memory overhead of reading and writing media files. </p>\r\n         */\r\n        MediaReadMode: Object.freeze({\r\n            Buffered: \"Buffered\",\r\n            Streamed: \"Streamed\"\r\n        }),\r\n\r\n        /**\r\n         * Enum for permission mode values.\r\n         * @readonly\r\n         * @enum {string}\r\n         * @property None Permission not valid.\r\n         * @property Read Permission applicable for read operations only.\r\n         * @property All Permission applicable for all operations.\r\n         */\r\n        PermissionMode: Object.freeze({\r\n            None: \"none\",\r\n            Read: \"read\",\r\n            All: \"all\"\r\n        }),\r\n\r\n        /**\r\n         * Enum for trigger type values.\r\n         * Specifies the type of the trigger.\r\n         * @readonly\r\n         * @enum {string}\r\n         * @property Pre  Trigger should be executed before the associated operation(s).\r\n         * @property Post Trigger should be executed after the associated operation(s).\r\n         */\r\n        TriggerType: Object.freeze({\r\n            Pre: \"pre\",\r\n            Post: \"post\"\r\n        }),\r\n\r\n        /**\r\n         * Enum for trigger operation values.\r\n         * specifies the operations on which a trigger should be executed.\r\n         * @readonly\r\n         * @enum {string}\r\n         * @property All All operations.\r\n         * @property Create Create operations only.\r\n         * @property Update Update operations only.\r\n         * @property Delete Delete operations only.\r\n         * @property Replace Replace operations only.\r\n         */\r\n        TriggerOperation: Object.freeze({\r\n            All: \"all\",\r\n            Create: \"create\",\r\n            Update: \"update\",\r\n            Delete: \"delete\",\r\n            Replace: \"replace\"\r\n        }),\r\n\r\n        /**\r\n         * Enum for udf type values.\r\n         * Specifies the types of user defined functions.\r\n         * @readonly\r\n         * @enum {string}\r\n         * @property Javascript Javascript type.\r\n         */\r\n        UserDefinedFunctionType: Object.freeze({\r\n            Javascript: \"Javascript\"\r\n        }),\r\n\r\n        /**\r\n         * @global\r\n         * Represents the Connection policy associated with a DocumentClient in the Azure DocumentDB database service.\r\n         * @property {string} MediaReadMode                - Attachment content (aka media) download mode. Should be one of the values of {@link MediaReadMode}\r\n         * @property {number} MediaRequestTimeout          - Time to wait for response from network peer for attachment content (aka media) operations. Represented in milliseconds.\r\n         * @property {number} RequestTimeout               - Request timeout (time to wait for response from network peer). Represented in milliseconds.\r\n         * @property {bool} EnableEndpointDiscovery        - Flag to enable/disable automatic redirecting of requests based on read/write operations.\r\n         * @property {Array} PreferredLocations            - List of azure regions to be used as preferred locations for read requests.\r\n         * @property {RetryOptions} RetryOptions           - RetryOptions instance which defines several configurable properties used during retry.\r\n         * @property {bool} DisableSSLVerification         - Flag to disable SSL verification for the requests. SSL verification is enabled by default. Don't set this when targeting production endpoints.\r\n         *                                                   This is intended to be used only when targeting emulator endpoint to avoid failing your requests with SSL related error.\r\n        */\r\n        ConnectionPolicy: Base.defineClass(function() {\r\n            Object.defineProperty(this, \"_defaultRequestTimeout\", {\r\n                value: 60000,\r\n                writable: true,\r\n                configurable: true,\r\n                enumerable: false // this is the default value, so it could be excluded during JSON.stringify\r\n            });\r\n\r\n            // defaultMediaRequestTimeout is based upon the blob client timeout and the retry policy.\r\n            Object.defineProperty(this, \"_defaultMediaRequestTimeout\", {\r\n                value: 300000,\r\n                writable: true,\r\n                configurable: true,\r\n                enumerable: false // this is the default value, so it could be excluded during JSON.stringify\r\n            });\r\n\r\n            this.ConnectionMode = AzureDocuments.ConnectionMode.Gateway;\r\n            this.MediaReadMode = AzureDocuments.MediaReadMode.Buffered;\r\n            this.MediaRequestTimeout = this._defaultMediaRequestTimeout;\r\n            this.RequestTimeout = this._defaultRequestTimeout;\r\n            this.EnableEndpointDiscovery = true;\r\n            this.PreferredLocations = [];\r\n            this.RetryOptions = new RetryOptions();\r\n            this.DisableSSLVerification = false;\r\n        })\r\n    }\r\n);\r\n//SCRIPT END\r\n\r\nif (typeof exports !== \"undefined\") {\r\n    module.exports = AzureDocuments;\r\n}","/home/travis/build/npmtest/node-npmtest-documentdb/node_modules/documentdb/lib/retryOptions.js":"/*\r\nThe MIT License (MIT)\r\nCopyright (c) 2014 Microsoft Corporation\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy\r\nof this software and associated documentation files (the \"Software\"), to deal\r\nin the Software without restriction, including without limitation the rights\r\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\ncopies of the Software, and to permit persons to whom the Software is\r\nfurnished to do so, subject to the following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included in all\r\ncopies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\nSOFTWARE.\r\n*/\r\n\r\n\"use strict\";\r\n\r\nvar Base = require(\"./base\");\r\n\r\n//SCRIPT START\r\n    /**\r\n    * Represents the Retry policy assocated with throttled requests in the Azure DocumentDB database service.\r\n    * @property {int} [MaxRetryAttemptCount]               - Max number of retries to be performed for a request. Default value 9.\r\n    * @property {int} [FixedRetryIntervalInMilliseconds]   - Fixed retry interval in milliseconds to wait between each retry ignoring the retryAfter returned as part of the response.\r\n    * @property {int} [MaxWaitTimeInSeconds]               - Max wait time in seconds to wait for a request while the retries are happening. Default value 30 seconds.\r\n    */\r\n    var RetryOptions = Base.defineClass(\r\n        function RetryOptions(maxRetryAttemptCount, fixedRetryIntervalInMilliseconds, maxWaitTimeInSeconds) {\r\n            this._maxRetryAttemptCount = maxRetryAttemptCount || 9;\r\n            this._fixedRetryIntervalInMilliseconds = fixedRetryIntervalInMilliseconds;\r\n            this._maxWaitTimeInSeconds = maxWaitTimeInSeconds || 30;\r\n\r\n            Object.defineProperty(this, \"MaxRetryAttemptCount\", {\r\n                    get: function () {\r\n                        return this._maxRetryAttemptCount;\r\n                    },\r\n                    enumerable: true\r\n            });\r\n\r\n            Object.defineProperty(this, \"FixedRetryIntervalInMilliseconds\", {\r\n                get: function () {\r\n                    return this._fixedRetryIntervalInMilliseconds;\r\n                },\r\n                enumerable: true\r\n            });\r\n\r\n            Object.defineProperty(this, \"MaxWaitTimeInSeconds\", {\r\n                get: function () {\r\n                    return this._maxWaitTimeInSeconds;\r\n                },\r\n                enumerable: true\r\n            });\r\n        })\r\n//SCRIPT END\r\n\r\nif (typeof exports !== \"undefined\") {\r\n    module.exports = RetryOptions;\r\n}","/home/travis/build/npmtest/node-npmtest-documentdb/node_modules/documentdb/lib/queryIterator.js":"/*\r\nThe MIT License (MIT)\r\nCopyright (c) 2014 Microsoft Corporation\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy\r\nof this software and associated documentation files (the \"Software\"), to deal\r\nin the Software without restriction, including without limitation the rights\r\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\ncopies of the Software, and to permit persons to whom the Software is\r\nfurnished to do so, subject to the following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included in all\r\ncopies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\nSOFTWARE.\r\n*/\r\n\r\n\"use strict\";\r\n\r\nvar Base = require(\"./base\"),\r\n    Constants = require(\"./constants\"),\r\n    QueryExecutionContext = require(\"./queryExecutionContext/proxyQueryExecutionContext\");\r\n\r\n//SCRIPT START\r\nvar QueryIterator = Base.defineClass(\r\n    /**\r\n    * Represents a QueryIterator Object, an implmenetation of feed or query response that enables traversal and iterating over the response\r\n    * in the Azure DocumentDB database service.\r\n    * @class QueryIterator\r\n    * @param {object} documentclient                - The documentclient object.\r\n    * @param {SqlQuerySpec | string} query          - A SQL query.\r\n    * @param {FeedOptions} options                  - Represents the feed options.\r\n    * @param {callback | callback[]} fetchFunctions - A function to retrieve each page of data. An array of functions may be used to query more than one partition.\r\n    * @param {string} [resourceLink]                - An optional parameter that represents the resourceLink (will be used in orderby/top/parallel query)\r\n    */\r\n    function (documentclient, query, options, fetchFunctions, resourceLink) {\r\n\r\n        this.documentclient = documentclient;\r\n        this.query = query;\r\n        this.fetchFunctions = fetchFunctions;\r\n        this.options = options;\r\n        this.resourceLink = resourceLink;\r\n        this.queryExecutionContext = this._createQueryExecutionContext();\r\n\r\n    },\r\n    {\r\n        /**\r\n         * Execute a provided function once per feed element.\r\n         * @memberof QueryIterator\r\n         * @instance\r\n         * @param {callback} callback - Function to execute for each element. the function takes two parameters error, element.\r\n         * Note: the last element the callback will be called on will be undefined.\r\n         * If the callback explicitly returned false, the loop gets stopped.\r\n         */\r\n        forEach: function(callback) {\r\n            this.reset();\r\n            this._forEachImplementation(callback);\r\n        },\r\n\r\n         /**\r\n         * Execute a provided function on the next element in the QueryIterator.\r\n         * @memberof QueryIterator\r\n         * @instance\r\n         * @param {callback} callback - Function to execute for each element. the function takes two parameters error, element.\r\n         */\r\n        nextItem: function (callback) {\r\n            this.queryExecutionContext.nextItem(callback);\r\n        },\r\n\r\n        /**\r\n         * Retrieve the current element on the QueryIterator.\r\n         * @memberof QueryIterator\r\n         * @instance\r\n         * @param {callback} callback - Function to execute for the current element. the function takes two parameters error, element.\r\n         */\r\n        current: function(callback) {\r\n            this.queryExecutionContext.current(callback);\r\n        },\r\n\r\n        /**\r\n         * @deprecated Instead check if callback(undefined, undefined) is invoked by nextItem(callback) or current(callback)\r\n         *\r\n         * Determine if there are still remaining resources to processs based on the value of the continuation token or the elements remaining on the current batch in the QueryIterator.\r\n         * @memberof QueryIterator\r\n         * @instance\r\n         * @returns {Boolean} true if there is other elements to process in the QueryIterator.\r\n         */\r\n        hasMoreResults: function () {\r\n            return this.queryExecutionContext.hasMoreResults();\r\n        },\r\n\r\n        /**\r\n         * Retrieve all the elements of the feed and pass them as an array to a function\r\n         * @memberof QueryIterator\r\n         * @instance\r\n         * @param {callback} callback - Function execute on the feed response, takes two parameters error, resourcesList\r\n         */\r\n        toArray: function (callback) {\r\n            this.reset();\r\n            this.toArrayTempResources = [];\r\n            this._toArrayImplementation(callback);\r\n        },\r\n\r\n        /**\r\n         * Retrieve the next batch of the feed and pass them as an array to a function\r\n         * @memberof QueryIterator\r\n         * @instance\r\n         * @param {callback} callback - Function execute on the feed response, takes two parameters error, resourcesList\r\n         */\r\n        executeNext: function(callback) {\r\n            this.queryExecutionContext.fetchMore(function(err, resources, responseHeaders) {\r\n                if(err) {\r\n                    return callback(err, undefined, responseHeaders);\r\n                }\r\n\r\n                callback(undefined, resources, responseHeaders);\r\n            });\r\n        },\r\n\r\n        /**\r\n         * Reset the QueryIterator to the beginning and clear all the resources inside it\r\n         * @memberof QueryIterator\r\n         * @instance\r\n         */\r\n        reset: function() {\r\n            this.queryExecutionContext = this._createQueryExecutionContext();\r\n        },\r\n\r\n        /** @ignore */\r\n        _toArrayImplementation: function(callback){\r\n            var that = this;\r\n\r\n            this.queryExecutionContext.nextItem(function (err, resource, headers) {\r\n\r\n                if (err) {\r\n                    return callback(err, undefined, headers);\r\n                }\r\n                // concatinate the results and fetch more\r\n                that.toArrayLastResHeaders = headers;\r\n\r\n                if (resource === undefined) {\r\n                \r\n                    // no more results\r\n                    return callback(undefined, that.toArrayTempResources, that.toArrayLastResHeaders);\r\n                } \r\n\r\n                that.toArrayTempResources = that.toArrayTempResources.concat(resource);\r\n                that._toArrayImplementation(callback);\r\n            });\r\n        },\r\n\r\n        /** @ignore */\r\n        _forEachImplementation: function (callback) {\r\n            var that = this;\r\n            this.queryExecutionContext.nextItem(function (err, resource, headers) {\r\n                if (err) {\r\n                    return callback(err, undefined, headers);\r\n                }\r\n\r\n                if (resource === undefined) {\r\n                    // no more results. This is last iteration\r\n                    return callback(undefined, undefined, headers);\r\n                }\r\n\r\n                if (callback(undefined, resource, headers) === false) {\r\n                    // callback instructed to stop further iteration\r\n                    return;\r\n                }\r\n\r\n                // recursively call itself to iterate to the remaining elements\r\n                that._forEachImplementation(callback);\r\n            });\r\n        },\r\n\r\n        /** @ignore */\r\n        _createQueryExecutionContext: function () {\r\n            return new QueryExecutionContext(this.documentclient, this.query, this.options, this.fetchFunctions, this.resourceLink);\r\n        }\r\n    }\r\n);\r\n//SCRIPT END\r\n\r\nif (typeof exports !== \"undefined\") {\r\n    module.exports = QueryIterator;\r\n}","/home/travis/build/npmtest/node-npmtest-documentdb/node_modules/documentdb/lib/queryExecutionContext/proxyQueryExecutionContext.js":"/*\r\nThe MIT License (MIT)\r\nCopyright (c) 2014 Microsoft Corporation\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy\r\nof this software and associated documentation files (the \"Software\"), to deal\r\nin the Software without restriction, including without limitation the rights\r\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\ncopies of the Software, and to permit persons to whom the Software is\r\nfurnished to do so, subject to the following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included in all\r\ncopies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\nSOFTWARE.\r\n*/\r\n\r\n\"use strict\";\r\n\r\nvar Base = require(\"../base\")\r\n    , DefaultQueryExecutionContext = require(\"./defaultQueryExecutionContext\")\r\n    , ParallelQueryExecutionContext = require(\"./parallelQueryExecutionContext\")\r\n    , endpointComponent = require('./endpointComponent')\r\n    , assert = require(\"assert\")\r\n    , QueryExecutionInfoParser = require(\"./partitionedQueryExecutionContextInfoParser\")\r\n    , PipelinedQueryExecutionContext = require(\"./pipelinedQueryExecutionContext\");\r\n\r\n//SCRIPT START\r\nvar ProxyQueryExecutionContext = Base.defineClass(\r\n    /**\r\n     * Represents a ProxyQueryExecutionContext Object. If the query is a partitioned query which can be parallelized it switches the execution context.\r\n     * @constructor ProxyQueryExecutionContext\r\n     * @param {object} documentclient                - The documentclient object.\r\n     * @param {SqlQuerySpec | string} query          - A SQL query.\r\n     * @param {FeedOptions} options                  - Represents the feed options.\r\n     * @param {callback | callback[]} fetchFunctions - A function to retrieve each page of data. An array of functions may be used to query more than one partition.\r\n     * @param {string} [resourceLink]                - collectionLink for parallelized query execution.\r\n     * @ignore\r\n    */\r\n    function (documentclient, query, options, fetchFunctions, resourceLink) {\r\n        this.documentclient = documentclient;\r\n        this.query = query;\r\n        this.fetchFunctions = fetchFunctions;\r\n        this.options = options;\r\n        this.resourceLink = resourceLink;\r\n        this.queryExecutionContext = new DefaultQueryExecutionContext(this.documentclient, this.query, this.options, this.fetchFunctions);\r\n    },\r\n    {\r\n\r\n        /**\r\n         * Execute a provided function on the next element in the ProxyQueryExecutionContext.\r\n         * @memberof ProxyQueryExecutionContext\r\n         * @instance\r\n         * @param {callback} callback - Function to execute for each element. the function takes two parameters error, element.\r\n         */\r\n        nextItem: function (callback) {\r\n            var that = this;\r\n            this.queryExecutionContext.nextItem(function (err, resources, headers) {\r\n\r\n                if (err) {\r\n                    if (that._hasPartitionedExecutionInfo(err)) {\r\n                        // if that's a partitioned execution info switches the execution context\r\n                        var partitionedExecutionInfo = that._getParitionedExecutionInfo(err);\r\n                        that.queryExecutionContext = that._createPipelinedExecutionContext(partitionedExecutionInfo);\r\n                        return that.nextItem(callback);\r\n                    } else {\r\n                        return callback(err, undefined, headers);\r\n                    }\r\n                } else {\r\n                    callback(undefined, resources, headers);\r\n                }\r\n            });\r\n        },\r\n\r\n        _createPipelinedExecutionContext: function (partitionedExecutionInfo) {\r\n\r\n            assert.notStrictEqual(this.resourceLink, undefined, \"for top/orderby resourceLink is required.\");\r\n\r\n            assert(!Array.isArray(this.resourceLink) || this.resourceLink.length === 1,\r\n                \"for top/orderby exactly one collectionLink is required\");\r\n\r\n            var collectionLink = undefined;\r\n            if (Array.isArray(this.resourceLink)) {\r\n                collectionLink = this.resourceLink[0];\r\n            } else {\r\n                collectionLink = this.resourceLink;\r\n            }\r\n\r\n            var parallelQueryExecutionContext = new ParallelQueryExecutionContext(this.documentclient,\r\n                Array.isArray(this.resourceLink) ? this.resourceLink[0] : this.resourceLink, this.query,\r\n                this.options, partitionedExecutionInfo);\r\n            return new PipelinedQueryExecutionContext(this.client, this.options,\r\n                parallelQueryExecutionContext, partitionedExecutionInfo);\r\n        },\r\n\r\n        /**\r\n         * Retrieve the current element on the ProxyQueryExecutionContext.\r\n         * @memberof ProxyQueryExecutionContext\r\n         * @instance\r\n         * @param {callback} callback - Function to execute for the current element. the function takes two parameters error, element.\r\n         */\r\n        current: function (callback) {\r\n            var that = this;\r\n            this.queryExecutionContext.current(function (err, resources, headers) {\r\n\r\n                if (err) {\r\n                    if (that._hasPartitionedExecutionInfo(err)) {\r\n                        // if that's a partitioned execution info switches the execution context\r\n                        var partitionedExecutionInfo = that._getParitionedExecutionInfo(err);\r\n                        that.queryExecutionContext = that._createPipelinedExecutionContext(partitionedExecutionInfo);\r\n                        return that.current(callback);\r\n                    } else {\r\n                        return callback(err, undefined, headers);\r\n                    }\r\n                } else {\r\n                    callback(undefined, resources, headers);\r\n                }\r\n            });\r\n        },\r\n\r\n        /**\r\n         * Determine if there are still remaining resources to process.\r\n         * @memberof ProxyQueryExecutionContext\r\n         * @instance\r\n         * @returns {Boolean} true if there is other elements to process in the ProxyQueryExecutionContext.\r\n         */\r\n        hasMoreResults: function () {\r\n            return this.queryExecutionContext.hasMoreResults();\r\n        },\r\n\r\n        fetchMore: function (callback) {\r\n            var that = this;\r\n\r\n            this.queryExecutionContext.fetchMore(function (err, resources, headers) {\r\n                if (err) {\r\n                    if (that._hasPartitionedExecutionInfo(err)) {\r\n                        // if that's a partitioned execution info switches the execution context\r\n                        var partitionedExecutionInfo = that._getParitionedExecutionInfo(err);\r\n                        that.queryExecutionContext = that._createPipelinedExecutionContext(partitionedExecutionInfo);\r\n                        return that.queryExecutionContext.fetchMore(callback);\r\n                    } else {\r\n                        return callback(err, undefined, headers);\r\n                    }\r\n                } else {\r\n                    callback(undefined, resources, headers);\r\n                }\r\n            });\r\n        },\r\n\r\n        _hasPartitionedExecutionInfo: function (error) {\r\n            return (error.code === 400) && ('substatus' in error) && (error['substatus'] === 1004);\r\n        },\r\n\r\n        _getParitionedExecutionInfo: function (error) {\r\n\r\n            return JSON.parse(JSON.parse(error.body).additionalErrorInfo);\r\n        },\r\n    }\r\n);\r\n//SCRIPT END\r\n\r\nif (typeof exports !== \"undefined\") {\r\n    module.exports = ProxyQueryExecutionContext;\r\n}","/home/travis/build/npmtest/node-npmtest-documentdb/node_modules/documentdb/lib/queryExecutionContext/defaultQueryExecutionContext.js":"/*\r\nThe MIT License (MIT)\r\nCopyright (c) 2014 Microsoft Corporation\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy\r\nof this software and associated documentation files (the \"Software\"), to deal\r\nin the Software without restriction, including without limitation the rights\r\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\ncopies of the Software, and to permit persons to whom the Software is\r\nfurnished to do so, subject to the following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included in all\r\ncopies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\nSOFTWARE.\r\n*/\r\n\r\n\"use strict\";\r\n\r\nvar Base = require(\"../base\")\r\n  , Constants = require(\"../constants\");\r\n\r\n//SCRIPT START\r\nvar DefaultQueryExecutionContext = Base.defineClass(\r\n    /**\r\n     * Provides the basic Query Execution Context. This wraps the internal logic query execution using provided fetch functions\r\n     * @constructor DefaultQueryExecutionContext\r\n     * @param {DocumentClient} documentclient        - The service endpoint to use to create the client.\r\n     * @param {SqlQuerySpec | string} query          - A SQL query.\r\n     * @param {FeedOptions} [options]                - Represents the feed options.\r\n     * @param {callback | callback[]} fetchFunctions - A function to retrieve each page of data. An array of functions may be used to query more than one partition.\r\n     * @ignore\r\n     */\r\n    function(documentclient, query, options, fetchFunctions){\r\n        this.documentclient = documentclient;\r\n        this.query = query;\r\n        this.resources = [];\r\n        this.currentIndex = 0;\r\n        this.currentPartitionIndex = 0;\r\n        this.fetchFunctions = (Array.isArray(fetchFunctions)) ? fetchFunctions : [fetchFunctions];\r\n        this.options = options || {};\r\n        this.continuation = this.options.continuation || null;\r\n        this.state = DefaultQueryExecutionContext.STATES.start;\r\n    },\r\n    {\r\n        /**\r\n         * Execute a provided callback on the next element in the execution context.\r\n         * @memberof DefaultQueryExecutionContext\r\n         * @instance\r\n         * @param {callback} callback - Function to execute for each element. the function takes two parameters error, element.\r\n         */\r\n        nextItem: function (callback) {\r\n            var that = this;\r\n            this.current(function (err, resources, headers) {\r\n                ++that.currentIndex;\r\n                callback(err, resources, headers);\r\n            });\r\n        },\r\n\r\n        /**\r\n         * Retrieve the current element on the execution context.\r\n         * @memberof DefaultQueryExecutionContext\r\n         * @instance\r\n         * @param {callback} callback - Function to execute for the current element. the function takes two parameters error, element.\r\n         */\r\n        current: function(callback) {\r\n            var that = this;\r\n            if (this.currentIndex < this.resources.length) {\r\n                return callback(undefined, this.resources[this.currentIndex], undefined);\r\n            }\r\n\r\n            if (this._canFetchMore()) {\r\n                this.fetchMore(function (err, resources, headers) {\r\n                    if (err) {\r\n                        return callback(err, undefined, headers);\r\n                    }\r\n                    that.resources = resources;\r\n                    if (that.resources.length === 0) {\r\n                        if (!that.continuation && that.currentPartitionIndex >= that.fetchFunctions.length) {\r\n                            that.state = DefaultQueryExecutionContext.STATES.ended;\r\n                            callback(undefined, undefined, headers);\r\n                        } else {\r\n                            that.current(callback);\r\n                        }\r\n                        return undefined;\r\n                    }\r\n                    callback(undefined, that.resources[that.currentIndex], headers);\r\n                });\r\n            } else {\r\n                this.state = DefaultQueryExecutionContext.STATES.ended;\r\n                callback(undefined, undefined, undefined);\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Determine if there are still remaining resources to processs based on the value of the continuation token or the elements remaining on the current batch in the execution context.\r\n         * @memberof DefaultQueryExecutionContext\r\n         * @instance\r\n         * @returns {Boolean} true if there is other elements to process in the DefaultQueryExecutionContext.\r\n         */\r\n        hasMoreResults: function () {\r\n            return this.state === DefaultQueryExecutionContext.STATES.start || this.continuation !== undefined || this.currentIndex < this.resources.length || this.currentPartitionIndex < this.fetchFunctions.length;\r\n        },\r\n\r\n        /**\r\n         * Fetches the next batch of the feed and pass them as an array to a callback\r\n         * @memberof DefaultQueryExecutionContext\r\n         * @instance\r\n         * @param {callback} callback - Function execute on the feed response, takes two parameters error, resourcesList\r\n         */\r\n        fetchMore: function (callback) {\r\n            if (this.currentPartitionIndex >= this.fetchFunctions.length) {\r\n                return callback(undefined, undefined, undefined);\r\n            }\r\n            var that = this;\r\n            // Keep to the original continuation and to restore the value after fetchFunction call\r\n            var originalContinuation = this.options.continuation;\r\n            this.options.continuation = this.continuation;\r\n\r\n            // Return undefined if there is no more results\r\n            if (this.currentPartitionIndex >= that.fetchFunctions.length) {\r\n                return callback(undefined, undefined, undefined);\r\n            }\r\n\r\n            var fetchFunction = this.fetchFunctions[this.currentPartitionIndex];\r\n            fetchFunction(this.options, function(err, resources, responseHeaders){\r\n                if(err) {\r\n                    that.state = DefaultQueryExecutionContext.STATES.ended;\r\n                    return callback(err, undefined, responseHeaders);\r\n                }\r\n\r\n                that.continuation = responseHeaders[Constants.HttpHeaders.Continuation];\r\n                if (!that.continuation) {\r\n                    ++that.currentPartitionIndex;\r\n                }\r\n\r\n                that.state = DefaultQueryExecutionContext.STATES.inProgress;\r\n                that.currentIndex = 0;\r\n                that.options.continuation = originalContinuation;\r\n                callback(undefined, resources, responseHeaders);\r\n            });\r\n        },\r\n        \r\n        _canFetchMore: function () {\r\n            var res = (this.state === DefaultQueryExecutionContext.STATES.start\r\n                || (this.continuation && this.state === DefaultQueryExecutionContext.STATES.inProgress)\r\n                || (this.currentPartitionIndex < this.fetchFunctions.length\r\n                    && this.state === DefaultQueryExecutionContext.STATES.inProgress));\r\n            return res;\r\n        }\r\n    }, {\r\n\r\n        STATES:  Object.freeze({ start: \"start\", inProgress: \"inProgress\", ended: \"ended\" })\r\n    }\r\n);\r\n\r\n//SCRIPT END\r\n\r\nif (typeof exports !== \"undefined\") {\r\n    module.exports = DefaultQueryExecutionContext;\r\n}\r\n","/home/travis/build/npmtest/node-npmtest-documentdb/node_modules/documentdb/lib/queryExecutionContext/parallelQueryExecutionContext.js":"/*\r\nThe MIT License (MIT)\r\nCopyright (c) 2014 Microsoft Corporation\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy\r\nof this software and associated documentation files (the \"Software\"), to deal\r\nin the Software without restriction, including without limitation the rights\r\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\ncopies of the Software, and to permit persons to whom the Software is\r\nfurnished to do so, subject to the following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included in all\r\ncopies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\nSOFTWARE.\r\n*/\r\n\r\n\"use strict\";\r\n\r\nvar Base = require(\"../base\")\r\n    , DefaultQueryExecutionContext = require(\"./defaultQueryExecutionContext\")\r\n    , PriorityQueue = require(\"priorityqueuejs\")\r\n    , SmartRoutingMapProvider = require(\"../routing/smartRoutingMapProvider\")\r\n    , CollectionRoutingMap = require(\"../routing/inMemoryCollectionRoutingMap\")\r\n    , DocumentProducer = require(\"./documentProducer\")\r\n    , QueryExecutionInfoParser = require(\"./partitionedQueryExecutionContextInfoParser\")\r\n    , assert = require('assert');\r\n\r\nvar QueryRange = CollectionRoutingMap.QueryRange;\r\n\r\nvar FormatPlaceHolder = \"{documentdb-formattableorderbyquery-filter}\"; \r\n\r\n//SCRIPT START\r\nvar ParallelQueryExecutionContext = Base.defineClass(\r\n    /**\r\n     * Provides the ParallelQueryExecutionContext.\r\n     * This class is capable of handling parallelized queries.\r\n     *\r\n     * When handling a parallelized (e.g., orderby) query, it instantiates one instance of\r\n     * DocumentProcuder per target partition key range and aggregates the result of each.\r\n     *\r\n     * @constructor ParallelQueryExecutionContext\r\n     * @param {DocumentClient} documentclient        - The service endpoint to use to create the client.\r\n     * @param {string} collectionLink                - The Collection Link\r\n     * @param {FeedOptions} [options]                - Represents the feed options.\r\n     * @param {object} partitionedQueryExecutionInfo - PartitionedQueryExecutionInfo\r\n     * @ignore\r\n     */\r\n    function (documentclient, collectionLink, query, options, partitionedQueryExecutionInfo) {\r\n        this.documentclient = documentclient;\r\n        this.collectionLink = collectionLink;\r\n        this.query = query;\r\n        this.options = options;\r\n        this.paritionedQueryExecutionInfo = partitionedQueryExecutionInfo;\r\n        this.err = undefined;\r\n        this.state = ParallelQueryExecutionContext.STATES.start;\r\n        this.routingProvider = new SmartRoutingMapProvider(this.documentclient);\r\n        this.sortOrders = QueryExecutionInfoParser.parseOrderBy(this.paritionedQueryExecutionInfo);\r\n\r\n        if (Array.isArray(this.sortOrders) && this.sortOrders.length > 0) {\r\n            this.documentProducerComparator = DocumentProducer.createOrderByComparator(this.sortOrders);\r\n        } else {\r\n            this.documentProducerComparator = DocumentProducer.createTargetPartitionKeyRangeComparator();\r\n        }\r\n\r\n        // this is a max priority queue\r\n        this.orderByPQ = new PriorityQueue(function (a, b) { return that.documentProducerComparator(b, a); });\r\n\r\n        this.state = ParallelQueryExecutionContext.STATES.started;\r\n        this.sem = require('semaphore')(1);\r\n        var that = this;\r\n        var createDocumentProducersAndFillUpPriorityQueueFunc = function () {\r\n            // ensure the lock is released after finishing up\r\n            that._onTargetPartitionRanges(function (err, targetPartitionRanges) {\r\n                that.waitingForInternalExcecutionContexts = targetPartitionRanges.length;\r\n                if (err) {\r\n                    that.err = err;\r\n                     // relase the lock\r\n                    that.sem.leave();\r\n                    return;\r\n                }\r\n                var maxDegreeOfParallelism = options.maxDegreeOfParallelism || 1;\r\n\r\n                if (maxDegreeOfParallelism > 0) {\r\n                    maxDegreeOfParallelism = Math.min(maxDegreeOfParallelism, targetPartitionRanges.length);\r\n                } else {\r\n                    maxDegreeOfParallelism = targetPartitionRanges.length;\r\n                }\r\n                var parallelismSem = require('semaphore')(Math.max(maxDegreeOfParallelism, 1));\r\n                \r\n                var targetPartitionQueryExecutionContextList = [];\r\n\r\n                targetPartitionRanges.forEach(\r\n                    function (partitionTargetRange) {\r\n                        // no async callback\r\n                        targetPartitionQueryExecutionContextList.push(\r\n                            that._createTargetPartitionQueryExecutionContext(partitionTargetRange));\r\n                    }\r\n                );\r\n\r\n                targetPartitionQueryExecutionContextList.forEach(\r\n                    function (targetQueryExContext) {\r\n\r\n                        // has async callback\r\n                        var throttledFunc = function () {\r\n                            targetQueryExContext.current(function (err, document) {\r\n                                try {\r\n                                    if (err) {\r\n                                        that.err = err;\r\n                                        return;\r\n                                    }\r\n\r\n                                    if (document == undefined) {\r\n                                        // no results on this one\r\n                                        return;\r\n                                    }\r\n                                    // if there are matching results in the target ex range add it to the priority queue\r\n                                    try {\r\n                                        that.orderByPQ.enq(targetQueryExContext);\r\n                                    } catch (e) {\r\n                                        that.err = e;\r\n                                    }\r\n                                } finally {\r\n                                    parallelismSem.leave();\r\n                                    that._decrementInitiationLock();\r\n                                }\r\n                            });\r\n                        }\r\n                        parallelismSem.take(throttledFunc);\r\n                    });\r\n            });\r\n        };\r\n        this.sem.take(createDocumentProducersAndFillUpPriorityQueueFunc);\r\n    },\r\n    {\r\n        _decrementInitiationLock: function () {\r\n            // decrements waitingForInternalExcecutionContexts\r\n            // if waitingForInternalExcecutionContexts reaches 0 releases the semaphore and changes the state\r\n            this.waitingForInternalExcecutionContexts = this.waitingForInternalExcecutionContexts - 1;\r\n            if (this.waitingForInternalExcecutionContexts === 0) {\r\n                this.sem.leave();\r\n                if (this.orderByPQ.size() === 0) {\r\n                    this.state = ParallelQueryExecutionContext.STATES.inProgress;\r\n                }\r\n            }\r\n        },\r\n        /**\r\n        * Execute a provided function on the next element in the ParallelQueryExecutionContext.\r\n        * @memberof ParallelQueryExecutionContext\r\n        * @instance\r\n        * @param {callback} callback - Function to execute for each element. the function takes two parameters error, element.\r\n        */\r\n        nextItem: function (callback) {\r\n            if (this.err) {\r\n                // if there is a prior error return error\r\n                return callback(this.err, undefined);\r\n            }\r\n            var that = this;\r\n            this.sem.take(function () {\r\n                // NOTE: lock must be released before invoking quitting\r\n                if (that.err) {\r\n                    // release the lock before invoking callback\r\n                    that.sem.leave();\r\n                    // if there is a prior error return error\r\n                    return callback(that.err, undefined);\r\n                }\r\n\r\n                if (that.orderByPQ.size() === 0) {\r\n                    // there is no more results\r\n                    that.state = ParallelQueryExecutionContext.STATES.ended;\r\n                    // release the lock before invoking callback\r\n                    that.sem.leave();\r\n                    return callback(undefined, undefined);\r\n                }\r\n                try {\r\n                    var targetPartitionRangeDocumentProducer = that.orderByPQ.deq();\r\n                } catch (e) {\r\n                    // if comparing elements of the priority queue throws exception\r\n                    // set that error and return error\r\n                    that.err = e;\r\n                    // release the lock before invoking callback\r\n                    that.sem.leave();\r\n                    return callback(that.err, undefined);\r\n                }\r\n\r\n                targetPartitionRangeDocumentProducer.nextItem(function (err, item) {\r\n                    if (err) {\r\n                        // this should never happen\r\n                        // because the documentProducer already has buffered an item\r\n                        // assert err === undefined\r\n                        that.err =\r\n                            new Error(\r\n                                util.format(\r\n                                        \"Extracted DocumentProducer from the priority queue fails to get the buffered item. Due to %s\",\r\n                                    JSON.stringify(err)));\r\n                        // release the lock before invoking callback\r\n                        that.sem.leave();\r\n                        return callback(that.err, undefined);\r\n                    }\r\n                    if (item === undefined) {\r\n                        // this should never happen\r\n                        // because the documentProducer already has buffered an item\r\n                        // assert item !== undefined\r\n                        that.err =\r\n                            new Error(\r\n                                util.format(\r\n                                    \"Extracted DocumentProducer from the priority queue doesn't have any buffered item!\"));\r\n                        // release the lock before invoking callback\r\n                        that.sem.leave();\r\n                        return callback(that.err, undefined);\r\n                    }\r\n\r\n                    // we need to put back the document producer to the queue if it has more elements.\r\n                    // the lock will be released after we know document producer must be put back in the queue or not\r\n                    targetPartitionRangeDocumentProducer.current(function (err, afterItem) {\r\n                        try {\r\n                            if (err) {\r\n                                that.err = err;\r\n                                return;\r\n                            }\r\n                            if (afterItem === undefined) {\r\n                                // no more results is left in this document producer\r\n                                return;\r\n                            }\r\n                            try {\r\n                                var headItem = targetPartitionRangeDocumentProducer.peek();\r\n                                assert.notStrictEqual(headItem, undefined,\r\n                                    'Extracted DocumentProducer from PQ is invalid state with no result!');\r\n                                that.orderByPQ.enq(targetPartitionRangeDocumentProducer);\r\n                            } catch (e) {\r\n                                // if comparing elements in priority queue throws exception\r\n                                // set error\r\n                                that.err = e;\r\n                            }\r\n                            return;\r\n                        } finally {\r\n                            // release the lock before returning\r\n                            that.sem.leave();\r\n                        }\r\n                    });\r\n\r\n                    // invoke the callback on the item\r\n                    callback(undefined, item);\r\n                });\r\n            });\r\n        },\r\n\r\n        /**\r\n         * Retrieve the current element on the ParallelQueryExecutionContext.\r\n         * @memberof ParallelQueryExecutionContext\r\n         * @instance\r\n         * @param {callback} callback - Function to execute for the current element. the function takes two parameters error, element.\r\n         */\r\n        current: function (callback) {\r\n            if (this.err) {\r\n                return callback(this.err, undefined);\r\n            }\r\n            var that = this;\r\n            this.sem.take(function () {\r\n                try {\r\n                    if (that.err) {\r\n                        return callback(that.err, undefined);\r\n                    }\r\n\r\n                    if (that.orderByPQ.size() === 0) {\r\n                        return callback(undefined, undefined);\r\n                    }\r\n                    var targetPartitionRangeDocumentProducer = that.orderByPQ.peek();\r\n                    targetPartitionRangeDocumentProducer.current(callback);\r\n                } finally {\r\n                    that.sem.leave();\r\n                }\r\n            });\r\n        },\r\n\r\n        /**\r\n         * Determine if there are still remaining resources to processs based on the value of the continuation token or the elements remaining on the current batch in the QueryIterator.\r\n         * @memberof ParallelQueryExecutionContext\r\n         * @instance\r\n         * @returns {Boolean} true if there is other elements to process in the ParallelQueryExecutionContext.\r\n         */\r\n        hasMoreResults: function () {\r\n            return !(this.state === ParallelQueryExecutionContext.STATES.ended || this.err !== undefined);\r\n        },\r\n        \r\n        _createTargetPartitionQueryExecutionContext: function (partitionKeyTargetRange) {\r\n            // creates target partition range Query Execution Context\r\n            var rewrittenQuery = QueryExecutionInfoParser.parseRewrittenQuery(this.paritionedQueryExecutionInfo);\r\n            var query = this.query;\r\n            if (typeof (query) === 'string') {\r\n                query = { 'query': query };\r\n            }\r\n            if (rewrittenQuery) {\r\n                query = JSON.parse(JSON.stringify(query));\r\n                // We hardcode the formattable filter to true for now\r\n                rewrittenQuery = rewrittenQuery.replace(FormatPlaceHolder, \"true\");\r\n                query['query'] = rewrittenQuery;\r\n            }\r\n            return new DocumentProducer(this.documentclient, this.collectionLink, query, partitionKeyTargetRange);\r\n        },\r\n\r\n        _onTargetPartitionRanges: function (callback) {\r\n            // invokes the callback when the target partition ranges are ready\r\n            var parsedRanges = QueryExecutionInfoParser.parseQueryRanges(this.paritionedQueryExecutionInfo);\r\n            var queryRanges = parsedRanges.map(function (item) { return QueryRange.parseFromDict(item); });\r\n            return this.routingProvider.getOverlappingRanges(callback, this.collectionLink, queryRanges);\r\n        },\r\n    }, \r\n    {\r\n        STATES: Object.freeze({ started: \"started\", inProgress: \"inProgress\", ended: \"ended\" })\r\n    }\r\n);\r\n//SCRIPT END\r\n\r\nif (typeof exports !== \"undefined\") {\r\n    module.exports = ParallelQueryExecutionContext;\r\n}","/home/travis/build/npmtest/node-npmtest-documentdb/node_modules/documentdb/lib/routing/smartRoutingMapProvider.js":"/*\r\nThe MIT License (MIT)\r\nCopyright (c) 2014 Microsoft Corporation\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy\r\nof this software and associated documentation files (the \"Software\"), to deal\r\nin the Software without restriction, including without limitation the rights\r\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\ncopies of the Software, and to permit persons to whom the Software is\r\nfurnished to do so, subject to the following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included in all\r\ncopies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\nSOFTWARE.\r\n*/\r\n\r\n\"use strict\";\r\n\r\nvar Base = require(\"../base\")\r\n    , assert = require(\"assert\")\r\n    , CollectionRoutingMap = require(\"./inMemoryCollectionRoutingMap\")\r\n    , PartitionKeyRangeCache = require(\"./partitionKeyRangeCache\")\r\n    , util = require(\"util\");\r\n\r\nvar CollectionRoutingMapFactory = CollectionRoutingMap.CollectionRoutingMapFactory;\r\nvar QueryRange = CollectionRoutingMap.QueryRange;\r\nvar _PartitionKeyRange = CollectionRoutingMap._PartitionKeyRange;\r\n\r\n//SCRIPT START\r\nvar SmartRoutingMapProvider = Base.defineClass(\r\n    \r\n   /**\r\n   * Represents a SmartRoutingMapProvider Object,  Efficiently uses PartitionKeyRangeCache and minimizes the unnecessary\r\n   * invocation of PartitionKeyRangeCache.getOverlappingRanges()\r\n   * @constructor SmartRoutingMapProvider\r\n   * @param {object} documentclient                - The documentclient object.\r\n   * @ignore\r\n   */\r\n    function (documentclient) {\r\n        this._partitionKeyRangeCache = new PartitionKeyRangeCache(documentclient);\r\n    },\r\n    {\r\n        _secondRangeIsAfterFirstRange: function (range1, range2) {\r\n            assert.notEqual(range1.max, undefined, \"invalid arg\");\r\n            assert.notEqual(range2.min, undefined, \"invalid arg\");\r\n\r\n            if (range1.max > range2.min) {\r\n                // r.min < #previous_r.max\r\n                return false;\r\n            } else {\r\n                if (range1.max === range2.min && range1.isMaxInclusive && range2.isMinInclusive) {\r\n                    // the inclusive ending endpoint of previous_r is the same as the inclusive beginning endpoint of r\r\n                    // they share a point\r\n                    return false;\r\n                }\r\n                return true;\r\n            }\r\n        },\r\n\r\n        _isSortedAndNonOverlapping: function (ranges) {\r\n            for (var idx = 1; idx < ranges.length; idx++) {\r\n                var previousR = ranges[idx - 1];\r\n                var r = ranges[idx];\r\n                if (!this._secondRangeIsAfterFirstRange(previousR, r)) {\r\n                    return false;\r\n                }\r\n            }\r\n            return true;\r\n        },\r\n\r\n        _stringMax: function (a, b) {\r\n            return (a >= b ? a : b);\r\n        },\r\n\r\n        _stringCompare: function(a, b) {\r\n            return (a == b ? 0 : (a > b ? 1 : -1));\r\n        },\r\n\r\n        _subtractRange: function (r, partitionKeyRange) {\r\n            var left = this._stringMax(partitionKeyRange[_PartitionKeyRange.MaxExclusive], r.min);\r\n            var leftInclusive;\r\n            if (this._stringCompare(left, r.min) === 0) {\r\n                leftInclusive = r.isMinInclusive;\r\n            } else {\r\n                leftInclusive = false;\r\n            }\r\n            return new QueryRange(left, r.max, leftInclusive,\r\n                r.isMaxInclusive);\r\n        },\r\n\r\n        /**\r\n         * Given the sorted ranges and a collection, invokes the callback on the list of overlapping partition key ranges\r\n         * @param {callback} callback - Function execute on the overlapping partition key ranges result, takes two parameters error, partition key ranges\r\n         * @param collectionLink\r\n         * @param sortedRanges\r\n         * @ignore\r\n         */\r\n        getOverlappingRanges: function (callback, collectionLink, sortedRanges) {\r\n            // validate if the list is non- overlapping and sorted\r\n            if (!this._isSortedAndNonOverlapping(sortedRanges)) {\r\n                return callback(new Error(\"the list of ranges is not a non-overlapping sorted ranges\"), undefined);\r\n            }\r\n\r\n            var partitionKeyRanges = [];\r\n\r\n            if (sortedRanges.length === 0) {\r\n                return callback(undefined, partitionKeyRanges);\r\n            }\r\n\r\n            var that = this;\r\n            this._partitionKeyRangeCache._onCollectionRoutingMap(function (err, collectionRoutingMap) {\r\n                if (err) {\r\n                    return callback(err, undefined);\r\n                }\r\n\r\n                var index = 0;\r\n                var currentProvidedRange = sortedRanges[index];\r\n                while (true) {\r\n                    if (currentProvidedRange.isEmpty()) {\r\n                        // skip and go to the next item\r\n                        if (++index >= sortedRanges.length) {\r\n                            return callback(undefined, partitionKeyRanges);\r\n                        }\r\n                        currentProvidedRange = sortedRanges[index];\r\n                        continue;\r\n                    }\r\n\r\n                    var queryRange;\r\n                    if (partitionKeyRanges.length > 0) {\r\n                        queryRange = that._subtractRange(\r\n                            currentProvidedRange, partitionKeyRanges[partitionKeyRanges.length - 1]);\r\n                    } else {\r\n                        queryRange = currentProvidedRange;\r\n                    }\r\n\r\n                    var overlappingRanges = collectionRoutingMap.getOverlappingRanges(queryRange);\r\n                    assert(overlappingRanges.length > 0, util.format(\"error: returned overlapping ranges for queryRange %s is empty\", queryRange));\r\n                    partitionKeyRanges = partitionKeyRanges.concat(overlappingRanges);\r\n\r\n                    var lastKnownTargetRange = QueryRange.parsePartitionKeyRange(partitionKeyRanges[partitionKeyRanges.length - 1]);\r\n                    assert.notEqual(lastKnownTargetRange, undefined);\r\n                    // the overlapping ranges must contain the requested range\r\n                    assert(that._stringCompare(currentProvidedRange.max, lastKnownTargetRange.max) <= 0,\r\n                        util.format(\"error: returned overlapping ranges %s does not contain the requested range %s\", overlappingRanges, queryRange));\r\n\r\n                    // the current range is contained in partitionKeyRanges just move forward\r\n                    if (++index >= sortedRanges.length) {\r\n                        return callback(undefined, partitionKeyRanges);\r\n                    }\r\n                    currentProvidedRange = sortedRanges[index];\r\n\r\n                    while (that._stringCompare(currentProvidedRange.max, lastKnownTargetRange.max) <= 0) {\r\n                        // the current range is covered too.just move forward\r\n                        if (++index >= sortedRanges.length) {\r\n                            return callback(undefined, partitionKeyRanges);\r\n                        }\r\n                        currentProvidedRange = sortedRanges[index];\r\n                    }\r\n                }\r\n            }, collectionLink);\r\n        }\r\n    }\r\n);\r\n//SCRIPT END\r\n\r\nif (typeof exports !== \"undefined\") {\r\n    module.exports = SmartRoutingMapProvider;\r\n}","/home/travis/build/npmtest/node-npmtest-documentdb/node_modules/documentdb/lib/routing/inMemoryCollectionRoutingMap.js":"/*\r\nThe MIT License (MIT)\r\nCopyright (c) 2014 Microsoft Corporation\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy\r\nof this software and associated documentation files (the \"Software\"), to deal\r\nin the Software without restriction, including without limitation the rights\r\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\ncopies of the Software, and to permit persons to whom the Software is\r\nfurnished to do so, subject to the following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included in all\r\ncopies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\nSOFTWARE.\r\n*/\r\n\r\n\"use strict\";\r\n\r\nvar Base = require(\"../base\")\r\n    , _ = require(\"underscore\")\r\n    , bs = require(\"binary-search-bounds\")\r\n    , assert = require(\"assert\");\r\n\r\n//SCRIPT START\r\nvar _PartitionKeyRange = {\r\n    //Partition Key Range Constants\r\n    MinInclusive : \"minInclusive\",\r\n    MaxExclusive : \"maxExclusive\",\r\n    Id : \"id\"\r\n};\r\n\r\nvar _QueryRangeConstants = {\r\n    //Partition Key Range Constants\r\n    MinInclusive: \"minInclusive\",\r\n    MaxExclusive: \"maxExclusive\",\r\n    min: \"min\"\r\n};\r\n\r\nvar _Constants = {\r\n    MinimumInclusiveEffectivePartitionKey: \"\",\r\n    MaximumExclusiveEffectivePartitionKey: \"FF\",\r\n};\r\n\r\nvar QueryRange = Base.defineClass(\r\n    /**\r\n     * Represents a QueryRange. \r\n     * @constructor QueryRange\r\n     * @param {string} rangeMin                - min\r\n     * @param {string} rangeMin                - max\r\n     * @param {boolean} isMinInclusive         - isMinInclusive\r\n     * @param {boolean} isMaxInclusive         - isMaxInclusive\r\n     * @ignore\r\n     */\r\n    function (rangeMin, rangeMax, isMinInclusive, isMaxInclusive) {\r\n        this.min = rangeMin;\r\n        this.max = rangeMax;\r\n        this.isMinInclusive = isMinInclusive;\r\n        this.isMaxInclusive = isMaxInclusive;\r\n    }, \r\n    {\r\n        overlaps: function (other) {\r\n            var range1 = this;\r\n            var range2 = other;\r\n            if (range1 === undefined || range2 === undefined) return false;\r\n            if (range1.isEmpty() || range2.isEmpty()) return false;\r\n\r\n            if (range1.min <= range2.max || range2.min <= range1.max) {\r\n                if ((range1.min === range2.max && !(range1.isMinInclusive && range2.isMaxInclusive))\r\n                    || (range2.min === range1.max && !(range2.isMinInclusive && range1.isMaxInclusive))) {\r\n                    return false;\r\n                }\r\n                return true;\r\n            }\r\n            return false;\r\n        },\r\n\r\n        isEmpty: function () {\r\n            return (!(this.isMinInclusive && this.isMaxInclusive)) && this.min === this.max;\r\n        }\r\n    }, \r\n    {\r\n        /**\r\n         * Parse a QueryRange from a partitionKeyRange\r\n         * @returns QueryRange\r\n         * @ignore\r\n         */\r\n        parsePartitionKeyRange: function (partitionKeyRange) {\r\n            return new QueryRange(partitionKeyRange[_PartitionKeyRange.MinInclusive], partitionKeyRange[_PartitionKeyRange.MaxExclusive],\r\n                true, false);\r\n        },\r\n        /**\r\n         * Parse a QueryRange from a dictionary\r\n         * @returns QueryRange\r\n         * @ignore\r\n         */\r\n        parseFromDict: function (queryRangeDict) {\r\n            return new QueryRange(queryRangeDict.min, queryRangeDict.max, queryRangeDict.isMinInclusive, queryRangeDict.isMaxInclusive);\r\n        }\r\n    }\r\n);\r\n\r\nvar InMemoryCollectionRoutingMap = Base.defineClass(\r\n    /**\r\n     * Represents a InMemoryCollectionRoutingMap Object, Stores partition key ranges in an efficient way with some additional information and provides\r\n     * convenience methods for working with set of ranges.\r\n     */\r\n    function (rangeById, rangeByInfo, orderedPartitionKeyRanges, orderedPartitionInfo, collectionUniqueId) {\r\n        this._rangeById = rangeById;\r\n        this._rangeByInfo = rangeByInfo;\r\n        this._orderedPartitionKeyRanges = orderedPartitionKeyRanges;\r\n        this._orderedRanges = orderedPartitionKeyRanges.map(\r\n            function (pkr) {\r\n                return new QueryRange(\r\n                    pkr[_PartitionKeyRange.MinInclusive], pkr[_PartitionKeyRange.MaxExclusive], true, false);\r\n            });\r\n        this._orderedPartitionInfo = orderedPartitionInfo;\r\n        this._collectionUniqueId = collectionUniqueId;\r\n    },\r\n    {\r\n\r\n        getOrderedParitionKeyRanges: function () {\r\n            return this._orderedPartitionKeyRanges;\r\n        },\r\n\r\n        getRangeByEffectivePartitionKey: function (effectivePartitionKeyValue) {\r\n\r\n            if (_Constants.MinimumInclusiveEffectivePartitionKey === effectivePartitionKeyValue) {\r\n                return this._orderedPartitionKeyRanges[0];\r\n            }\r\n\r\n            if (_Constants.MaximumExclusiveEffectivePartitionKey === effectivePartitionKeyValue) {\r\n                return undefined;\r\n            }\r\n\r\n            var sortedLow = this._orderedRanges.map(\r\n                function (r) {\r\n                    return { v: r.min, b: !r.isMinInclusive };\r\n                });\r\n\r\n            var index = bs.le(sortedLow, { v: effectivePartitionKeyValue, b: true }, this._vbCompareFunction);\r\n            // that's an error\r\n            assert(index >=0, \"error in collection routing map, queried partition key is less than the start range.\");\r\n           \r\n            return this._orderedPartitionKeyRanges[index];\r\n        },\r\n\r\n        _vbCompareFunction: function (x, y) {\r\n            if (x.v > y.v) return 1;\r\n            if (x.v < y.v) return -1;\r\n            if (x.b > y.b) return 1;\r\n            if (x.b < y.b) return -1;\r\n            return 0;\r\n        },\r\n\r\n        getRangeByPartitionKeyRangeId: function (partitionKeyRangeId) {\r\n\r\n            var t = this._rangeById[partitionKeyRangeId];\r\n\r\n            if (t === undefined) {\r\n                return undefined;\r\n            }\r\n            return t[0];\r\n        },\r\n\r\n        getOverlappingRanges: function (providedQueryRanges) {\r\n\r\n            if (!_.isArray(providedQueryRanges)) {\r\n                return this.getOverlappingRanges([providedQueryRanges]);\r\n            }\r\n            \r\n            var minToPartitionRange = {};\r\n            var sortedLow = this._orderedRanges.map(\r\n                function (r) {\r\n                    return { v: r.min, b: !r.isMinInclusive };\r\n                });\r\n            var sortedHigh = this._orderedRanges.map(\r\n                function (r) {\r\n                    return { v: r.max, b: r.isMaxInclusive };\r\n                });\r\n\r\n            // this for loop doesn't invoke any async callback\r\n            for (var i = 0; i < providedQueryRanges.length; i++) {\r\n                var queryRange = providedQueryRanges[i];\r\n                if (queryRange.isEmpty()) {\r\n                    continue;\r\n                }\r\n                var minIndex = bs.le(sortedLow, { v: queryRange.min, b: !queryRange.isMinInclusive }, this._vbCompareFunction);\r\n                assert(minIndex >= 0, \"error in collection routing map, queried value is less than the start range.\");\r\n\r\n                var maxIndex = bs.ge(sortedHigh, { v: queryRange.max, b: queryRange.isMaxInclusive }, this._vbCompareFunction);\r\n                assert(maxIndex < sortedHigh.length, \"error in collection routing map, queried value is greater than the end range.\");\r\n\r\n                // the for loop doesn't invoke any async callback\r\n                for (var j = minIndex; j < maxIndex + 1; j++) {\r\n                    if (queryRange.overlaps(this._orderedRanges[j])) {\r\n                        minToPartitionRange[this._orderedPartitionKeyRanges[j][_PartitionKeyRange.MinInclusive]] = this._orderedPartitionKeyRanges[j];\r\n                    }\r\n                } \r\n            }\r\n\r\n            var overlappingPartitionKeyRanges = _.values(minToPartitionRange);\r\n\r\n            var getKey = function (r) {\r\n                return r[_PartitionKeyRange.MinInclusive];\r\n            };\r\n            return _.sortBy(overlappingPartitionKeyRanges, getKey);\r\n        }\r\n    }\r\n);\r\n\r\nvar CollectionRoutingMapFactory = Base.defineClass(undefined, undefined,\r\n    {\r\n        createCompleteRoutingMap: function (partitionKeyRangeInfoTuppleList, collectionUniqueId) {\r\n            var rangeById = {};\r\n            var rangeByInfo = {};\r\n\r\n            var sortedRanges = [];\r\n\r\n            // the for loop doesn't invoke any async callback\r\n            for (var index = 0; index < partitionKeyRangeInfoTuppleList.length; index++) {\r\n                var r = partitionKeyRangeInfoTuppleList[index];\r\n                rangeById[r[0][_PartitionKeyRange.Id]] = r;\r\n                rangeByInfo[r[1]] = r[0];\r\n                sortedRanges.push(r);\r\n            }\r\n\r\n            sortedRanges = _.sortBy(sortedRanges,\r\n                function (r) {\r\n                    return r[0][_PartitionKeyRange.MinInclusive];\r\n                });\r\n            var partitionKeyOrderedRange = sortedRanges.map(function (r) { return r[0]; });\r\n            var orderedPartitionInfo = sortedRanges.map(function (r) { return r[1]; });\r\n\r\n            if (!this._isCompleteSetOfRange(partitionKeyOrderedRange)) return undefined;\r\n            return new InMemoryCollectionRoutingMap(rangeById, rangeByInfo, partitionKeyOrderedRange, orderedPartitionInfo, collectionUniqueId);\r\n        },\r\n\r\n        _isCompleteSetOfRange: function (partitionKeyOrderedRange) {\r\n            var isComplete = false;\r\n            if (partitionKeyOrderedRange.length > 0) {\r\n                var firstRange = partitionKeyOrderedRange[0];\r\n                var lastRange = partitionKeyOrderedRange[partitionKeyOrderedRange.length - 1];\r\n                isComplete = (firstRange[_PartitionKeyRange.MinInclusive] === _Constants.MinimumInclusiveEffectivePartitionKey);\r\n                isComplete &= (lastRange[_PartitionKeyRange.MaxExclusive] === _Constants.MaximumExclusiveEffectivePartitionKey);\r\n\r\n                for (var i = 1; i < partitionKeyOrderedRange.length; i++) {\r\n                    var previousRange = partitionKeyOrderedRange[i - 1];\r\n                    var currentRange = partitionKeyOrderedRange[i];\r\n                    isComplete &= (previousRange[_PartitionKeyRange.MaxExclusive] == currentRange[_PartitionKeyRange.MinInclusive]);\r\n\r\n                    if (!isComplete) {\r\n                        if (previousRange[_PartitionKeyRange.MaxExclusive] > currentRange[_PartitionKeyRange.MinInclusive] ) {\r\n                            throw Error(\"Ranges overlap\");\r\n                        }\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            return isComplete;\r\n        }\r\n    }\r\n);\r\n//SCRIPT END\r\n\r\nif (typeof exports !== \"undefined\") {\r\n    exports.InMemoryCollectionRoutingMap = InMemoryCollectionRoutingMap;\r\n    exports.CollectionRoutingMapFactory = CollectionRoutingMapFactory;\r\n    exports.QueryRange = QueryRange;\r\n    exports._PartitionKeyRange = _PartitionKeyRange;\r\n}","/home/travis/build/npmtest/node-npmtest-documentdb/node_modules/documentdb/lib/routing/partitionKeyRangeCache.js":"/*\r\nThe MIT License (MIT)\r\nCopyright (c) 2014 Microsoft Corporation\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy\r\nof this software and associated documentation files (the \"Software\"), to deal\r\nin the Software without restriction, including without limitation the rights\r\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\ncopies of the Software, and to permit persons to whom the Software is\r\nfurnished to do so, subject to the following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included in all\r\ncopies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\nSOFTWARE.\r\n*/\r\n\r\n\"use strict\";\r\n\r\nvar Base = require(\"../base\")\r\n    , CollectionRoutingMap = require(\"./inMemoryCollectionRoutingMap\");\r\n\r\nvar CollectionRoutingMapFactory = CollectionRoutingMap.CollectionRoutingMapFactory;\r\n\r\n//SCRIPT START\r\nvar PartitionKeyRangeCache = Base.defineClass(\r\n    \r\n    /**\r\n     * Represents a PartitionKeyRangeCache. PartitionKeyRangeCache provides list of effective partition key ranges for a collection.\r\n     * This implementation loads and caches the collection routing map per collection on demand.\r\n     * @constructor PartitionKeyRangeCache\r\n     * @param {object} documentclient                - The documentclient object.\r\n     * @ignore\r\n     */\r\n    function (documentclient) {\r\n        this.documentclient = documentclient;\r\n        this.collectionRoutingMapByCollectionId = {};\r\n        this.sem = require(\"semaphore\")(1);\r\n    },\r\n    {\r\n        /**\r\n         * Finds or Instantiates the requested Collection Routing Map and invokes callback\r\n         * @param {callback} callback                - Function to execute for the collection routing map. the function takes two parameters error, collectionRoutingMap.\r\n         * @param {string} collectionLink            - Requested collectionLink\r\n         * @ignore\r\n         */\r\n        _onCollectionRoutingMap: function (callback, collectionLink) {\r\n            var isNameBased = Base.isLinkNameBased(collectionLink);\r\n            var collectionId = this.documentclient.getIdFromLink(collectionLink, isNameBased);\r\n\r\n            var collectionRoutingMap = this.collectionRoutingMapByCollectionId[collectionId];\r\n            if (collectionRoutingMap === undefined) {\r\n                // attempt to consturct collection routing map\r\n                var that = this;\r\n                var semaphorizedFuncCollectionMapInstantiator = function () {\r\n                    var collectionRoutingMap = that.collectionRoutingMapByCollectionId[collectionId];\r\n                    if (collectionRoutingMap === undefined) {\r\n                        var partitionKeyRangesIterator = that.documentclient.readPartitionKeyRanges(collectionLink);\r\n                        partitionKeyRangesIterator.toArray(function (err, resources) {\r\n                            if (err) {\r\n                                return callback(err, undefined);\r\n                            }\r\n\r\n                            collectionRoutingMap = CollectionRoutingMapFactory.createCompleteRoutingMap(\r\n                                resources.map(function (r) { return [r, true]; }),\r\n                                collectionId);\r\n\r\n                            that.collectionRoutingMapByCollectionId[collectionId] = collectionRoutingMap;\r\n                            that.sem.leave();\r\n                            return callback(undefined, collectionRoutingMap);\r\n                        });\r\n\r\n                    } else {\r\n                        // sanity gaurd \r\n                        that.sem.leave();\r\n                        return callback(undefined, collectionRoutingMap.getOverlappingRanges(partitionKeyRanges));\r\n                    }\r\n                };\r\n\r\n                // We want only one attempt to construct collectionRoutingMap so we pass the consturction in the semaphore take\r\n                this.sem.take(semaphorizedFuncCollectionMapInstantiator);\r\n\r\n            } else {\r\n                callback(undefined, collectionRoutingMap);\r\n            }\r\n        }, \r\n\r\n        /**\r\n         * Given the query ranges and a collection, invokes the callback on the list of overlapping partition key ranges\r\n         * @param {callback} callback - Function execute on the overlapping partition key ranges result, takes two parameters error, partition key ranges\r\n         * @param collectionLink\r\n         * @param queryRanges\r\n         * @ignore\r\n         */\r\n        getOverlappingRanges: function (callback, collectionLink, queryRanges) {\r\n            this._onCollectionRoutingMap(function (err, collectionRoutingMap) {\r\n                if (err) {\r\n                    return callback(err, undefined);\r\n                }\r\n                return callback(undefined, collectionRoutingMap.getOverlappingRanges(queryRanges));\r\n            }, collectionLink);\r\n        }\r\n    }\r\n);\r\n//SCRIPT END\r\n\r\nif (typeof exports !== \"undefined\") {\r\n    module.exports = PartitionKeyRangeCache;\r\n}","/home/travis/build/npmtest/node-npmtest-documentdb/node_modules/documentdb/lib/queryExecutionContext/documentProducer.js":"/*\r\nThe MIT License (MIT)\r\nCopyright (c) 2014 Microsoft Corporation\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy\r\nof this software and associated documentation files (the \"Software\"), to deal\r\nin the Software without restriction, including without limitation the rights\r\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\ncopies of the Software, and to permit persons to whom the Software is\r\nfurnished to do so, subject to the following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included in all\r\ncopies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\nSOFTWARE.\r\n*/\r\n\r\n\"use strict\";\r\n\r\nvar Base = require(\"../base\")\r\n    , DefaultQueryExecutionContext = require(\"./defaultQueryExecutionContext\")\r\n    , assert = require(\"assert\")\r\n    , util = require(\"util\");\r\n\r\n//SCRIPT START\r\nvar DocumentProducer = Base.defineClass(\r\n    /**\r\n     * Provides the Target Partition Range Query Execution Context.\r\n     * @constructor DocumentProducer\r\n     * @param {DocumentClient} documentclient        - The service endpoint to use to create the client.\r\n     * @param {String} collectionLink                - Represents collection link\r\n     * @param {SqlQuerySpec | string} query          - A SQL query.\r\n     * @param {object} targetPartitionKeyRange       - Query Target Partition key Range\r\n     * @ignore\r\n     */\r\n    function (documentclient, collectionLink, query, targetPartitionKeyRange) {\r\n        this.documentclient = documentclient;\r\n        this.collectionLink = collectionLink;\r\n        this.query = query;\r\n        this.targetPartitionKeyRange = targetPartitionKeyRange;\r\n        this.bufferedCurrentItem = undefined;\r\n\r\n        var isNameBased = Base.isLinkNameBased(collectionLink);\r\n        var path = this.documentclient.getPathFromLink(collectionLink, \"docs\", isNameBased);\r\n        var id = this.documentclient.getIdFromLink(collectionLink, isNameBased);\r\n        var options = {};\r\n\r\n        var that = this;\r\n        var fetchFunction =  function (options, callback) {\r\n            that.documentclient.queryFeed.call(documentclient,\r\n                documentclient,\r\n                    path,\r\n                    \"docs\",\r\n                    id,\r\n                    function (result) { return result.Documents; },\r\n                    function (parent, body) { return body; },\r\n                    query,\r\n                    options,\r\n                    callback,\r\n                    that.targetPartitionKeyRange[\"id\"]);\r\n        };\r\n        this.internalExecutionContext = new DefaultQueryExecutionContext(documentclient, query, options, fetchFunction);\r\n    },\r\n    {\r\n        /**\r\n         * Synchronously gives the bufferend current item if any\r\n         * @returns {Object}       - buffered current item if any\r\n         * @ignore\r\n         */\r\n        peek: function () {\r\n            return this.bufferedCurrentItem;\r\n        },\r\n\r\n        /**\r\n         * Synchronously gives the bufferend current item if any\r\n         * @returns {Object}       - buffered current item if any\r\n         * @ignore\r\n         */\r\n        getTargetParitionKeyRange: function () {\r\n            return this.targetPartitionKeyRange;\r\n        },\r\n\r\n        /**\r\n        * Execute a provided function on the next element in the DocumentProducer.\r\n        * @memberof DocumentProducer\r\n        * @instance\r\n        * @param {callback} callback - Function to execute for each element. the function takes two parameters error, element.\r\n        */\r\n        nextItem: function (callback) {\r\n            var that = this;\r\n            this.internalExecutionContext.nextItem(function (err, item) {\r\n                that.bufferedCurrentItem = undefined;\r\n                callback(err, item);\r\n            });\r\n        },\r\n\r\n        /**\r\n         * Retrieve the current element on the DocumentProducer.\r\n         * @memberof DocumentProducer\r\n         * @instance\r\n         * @param {callback} callback - Function to execute for the current element. the function takes two parameters error, element.\r\n         */\r\n        current: function (callback) {\r\n            var that = this;\r\n            this.internalExecutionContext.current(function (err, item) {\r\n                // sets the buffered current item for non async access\r\n                that.bufferedCurrentItem = item;\r\n                callback(err, item);\r\n            });\r\n        },\r\n    },\r\n\r\n    {\r\n\r\n        /**\r\n         * Provides a Comparator for document producers using the min value of the corresponding target partition.\r\n         * @returns {object}        - Comparator Function\r\n         * @ignore\r\n         */\r\n        createTargetPartitionKeyRangeComparator: function () {\r\n            return function (docProd1, docProd2) {\r\n                var a = docProd1.getTargetParitionKeyRange()['minInclusive'];\r\n                var b = docProd2.getTargetParitionKeyRange()['minInclusive'];\r\n                return (a == b ? 0 : (a > b ? 1 : -1));\r\n            };\r\n        },\r\n\r\n        /**\r\n         * Provides a Comparator for document producers which respects orderby sort order.\r\n         * @returns {object}        - Comparator Function\r\n         * @ignore\r\n         */\r\n        createOrderByComparator: function (sortOrder) {\r\n            var comparator = new OrderByDocumentProducerComparator(sortOrder);\r\n            return function (docProd1, docProd2) {\r\n                return comparator.compare(docProd1, docProd2);\r\n            };\r\n        }\r\n    }\r\n);\r\n\r\nvar OrderByDocumentProducerComparator = Base.defineClass(\r\n\r\n    function (sortOrder) {\r\n        this.sortOrder = sortOrder;\r\n        this.targetPartitionKeyRangeDocProdComparator = new DocumentProducer.createTargetPartitionKeyRangeComparator();\r\n\r\n        this._typeOrdComparator = Object.freeze({\r\n            NoValue: {\r\n                ord: 0\r\n            },\r\n            undefined: {\r\n                ord: 1\r\n            },\r\n            boolean: {\r\n                ord: 2,\r\n                compFunc: function (a, b) {\r\n                    return (a == b ? 0 : (a > b ? 1 : -1));\r\n                }\r\n            },\r\n            number: {\r\n                ord: 4,\r\n                compFunc: function (a, b) {\r\n                    return (a == b ? 0 : (a > b ? 1 : -1));\r\n                }\r\n            },\r\n            string: {\r\n                ord: 5,\r\n                compFunc: function (a, b) {\r\n                    return (a == b ? 0 : (a > b ? 1 : -1));\r\n                }\r\n            }\r\n        });\r\n    },\r\n    {\r\n        compare: function (docProd1, docProd2) {\r\n            var orderByItemsRes1 = this.getOrderByItems(docProd1.peek());\r\n            var orderByItemsRes2 = this.getOrderByItems(docProd2.peek());\r\n\r\n            // validate order by items and types\r\n            // TODO: once V1 order by on different types is fixed this need to change\r\n            this.validateOrderByItems(orderByItemsRes1, orderByItemsRes2);\r\n\r\n            // no async call in the for loop\r\n            for (var i = 0; i < orderByItemsRes1.length; i++) {\r\n                // compares the orderby items one by one\r\n                var compRes = this.compareOrderByItem(orderByItemsRes1[i], orderByItemsRes2[i]);\r\n                if (compRes !== 0) {\r\n                    if (this.sortOrder[i] === 'Ascending') {\r\n                        return compRes;\r\n                    } else if (this.sortOrder[i] === 'Descending') {\r\n                        return -compRes;\r\n                    }\r\n                }\r\n            }\r\n\r\n            return this.targetPartitionKeyRangeDocProdComparator(docProd1, docProd2);\r\n        },\r\n\r\n        compareValue: function (item1, type1, item2, type2) {\r\n            var type1Ord = this._typeOrdComparator[type1].ord;\r\n            var type2Ord = this._typeOrdComparator[type2].ord;\r\n            var typeCmp = type1Ord - type2Ord;\r\n\r\n            if (typeCmp !== 0) {\r\n                // if the types are different, use type ordinal\r\n                return typeCmp;\r\n            }\r\n\r\n            // both are of the same type \r\n            if ((type1Ord === this._typeOrdComparator['undefined'].ord) || (type1Ord === this._typeOrdComparator['NoValue'].ord)) {\r\n                // if both types are undefined or Null they are equal\r\n                return 0;\r\n            }\r\n\r\n            var compFunc = this._typeOrdComparator[type1].compFunc;\r\n            assert.notEqual(compFunc, undefined, \"cannot find the comparison function\");\r\n            // same type and type is defined compare the items\r\n            return compFunc(item1, item2);\r\n        },\r\n\r\n        compareOrderByItem: function (orderByItem1, orderByItem2) {\r\n            var type1 = this.getType(orderByItem1);\r\n            var type2 = this.getType(orderByItem2);\r\n            return this.compareValue(orderByItem1['item'], type1, orderByItem2['item'], type2);\r\n        },\r\n\r\n        validateOrderByItems: function (res1, res2) {\r\n            this._throwIf(res1.length != res2.length, util.format(\"Expected %s, but got %s.\", type1, type2));\r\n            this._throwIf(res1.length != this.sortOrder.length, 'orderByItems cannot have a different size than sort orders.');\r\n\r\n            for (var i = 0; i < this.sortOrder.length; i++) {\r\n                var type1 = this.getType(res1[i]);\r\n                var type2 = this.getType(res2[i]);\r\n                this._throwIf(type1 !== type2, util.format(\"Expected %s, but got %s.\", type1, type2));\r\n            }\r\n        },\r\n\r\n        getType: function (orderByItem) {\r\n            if (!'item' in orderByItem) {\r\n                return 'NoValue';\r\n            }\r\n            var type = typeof (orderByItem['item']);\r\n            this._throwIf(! type in this._typeOrdComparator, util.format(\"unrecognizable type %s\", type));\r\n            return type;\r\n        },\r\n\r\n        getOrderByItems: function (res) {\r\n            return res['orderByItems'];\r\n        },\r\n\r\n        _throwIf: function(condition, msg) {\r\n            if (condition) {\r\n                throw Error(msg);\r\n            }\r\n        }\r\n    }\r\n);\r\n//SCRIPT END\r\n\r\nif (typeof exports !== \"undefined\") {\r\n    module.exports = DocumentProducer;\r\n    module.exports.OrderByDocumentProducerComparator = OrderByDocumentProducerComparator;\r\n}","/home/travis/build/npmtest/node-npmtest-documentdb/node_modules/documentdb/lib/queryExecutionContext/partitionedQueryExecutionContextInfoParser.js":"/*\r\nThe MIT License (MIT)\r\nCopyright (c) 2014 Microsoft Corporation\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy\r\nof this software and associated documentation files (the \"Software\"), to deal\r\nin the Software without restriction, including without limitation the rights\r\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\ncopies of the Software, and to permit persons to whom the Software is\r\nfurnished to do so, subject to the following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included in all\r\ncopies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\nSOFTWARE.\r\n*/\r\n\r\n\"use strict\";\r\n\r\nvar Base = require(\"../base\")\r\n    , assert = require(\"assert\")\r\n    , util = require(\"util\");\r\n\r\n//SCRIPT START\r\nvar PartitionedQueryContants = {\r\n    QueryInfoPath : 'queryInfo',\r\n    TopPath: ['queryInfo', 'top'],\r\n    OrderByPath: ['queryInfo', 'orderBy'],\r\n    AggregatePath: ['queryInfo', 'aggregates'],\r\n    QueryRangesPath : 'queryRanges',\r\n    RewrittenQueryPath: ['queryInfo', 'rewrittenQuery']\r\n};\r\n\r\nvar PartitionedQueryExecutionContextInfoParser = Base.defineClass(\r\n    undefined, undefined,\r\n    {\r\n        parseRewrittenQuery: function (partitionedQueryExecutionInfo) {\r\n            return this._extract(partitionedQueryExecutionInfo, PartitionedQueryContants.RewrittenQueryPath);\r\n        },\r\n        parseQueryRanges: function (partitionedQueryExecutionInfo) {\r\n            return this._extract(partitionedQueryExecutionInfo, PartitionedQueryContants.QueryRangesPath);\r\n        },\r\n        parseOrderBy: function (partitionedQueryExecutionInfo) {\r\n            return this._extract(partitionedQueryExecutionInfo, PartitionedQueryContants.OrderByPath);\r\n        },\r\n        parseAggregates: function (partitionedQueryExecutionInfo) {\r\n            return this._extract(partitionedQueryExecutionInfo, PartitionedQueryContants.AggregatePath);\r\n        },\r\n        parseTop: function (partitionedQueryExecutionInfo) {\r\n            return this._extract(partitionedQueryExecutionInfo, PartitionedQueryContants.TopPath);\r\n        },\r\n        _extract: function (partitionedQueryExecutionInfo, path) {\r\n            var item = partitionedQueryExecutionInfo;\r\n            if (typeof (path) === 'string') {\r\n                return item[path];\r\n            }\r\n            assert(Array.isArray(path),\r\n                util.format(\"%s is expected to be an array\", JSON.stringify(path)));\r\n            for (var index = 0; index < path.length; index++) {\r\n                item = item[path[index]];\r\n                if (item === undefined) {\r\n                    return undefined;\r\n                }\r\n            }\r\n            return item;\r\n        }\r\n    }\r\n);\r\n//SCRIPT END\r\n\r\nif (typeof exports !== \"undefined\") {\r\n    module.exports = PartitionedQueryExecutionContextInfoParser;\r\n}","/home/travis/build/npmtest/node-npmtest-documentdb/node_modules/documentdb/lib/queryExecutionContext/endpointComponent.js":"/*\r\nThe MIT License (MIT)\r\nCopyright (c) 2014 Microsoft Corporation\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy\r\nof this software and associated documentation files (the \"Software\"), to deal\r\nin the Software without restriction, including without limitation the rights\r\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\ncopies of the Software, and to permit persons to whom the Software is\r\nfurnished to do so, subject to the following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included in all\r\ncopies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\nSOFTWARE.\r\n*/\r\n\r\n\"use strict\";\r\n\r\nvar Base = require(\"../base\")\r\n    , aggregators = require('./aggregators');\r\n\r\n//SCRIPT START\r\nvar OrderByEndpointComponent = Base.defineClass(\r\n\r\n    /**\r\n     * Represents an endpoint in handling an order by query. For each processed orderby result it returns 'payload' item of the result\r\n     * @constructor OrderByEndpointComponent\r\n     * @param {object} executionContext              - Underlying Execution Context\r\n     * @ignore\r\n     */\r\n    function (executionContext) {\r\n        this.executionContext = executionContext;\r\n    },\r\n    {\r\n         /**\r\n         * Execute a provided function on the next element in the OrderByEndpointComponent.\r\n         * @memberof OrderByEndpointComponent\r\n         * @instance\r\n         * @param {callback} callback - Function to execute for each element. the function takes two parameters error, element.\r\n         */\r\n        nextItem: function (callback) {\r\n            this.executionContext.nextItem(function (err, item) {\r\n                if (err) {\r\n                    return callback(err, undefined);\r\n                }\r\n                if (item === undefined) {\r\n                    return callback(undefined, undefined);\r\n                }\r\n                callback(undefined, item[\"payload\"]);\r\n            });\r\n        },\r\n\r\n        /**\r\n         * Retrieve the current element on the OrderByEndpointComponent.\r\n         * @memberof OrderByEndpointComponent\r\n         * @instance\r\n         * @param {callback} callback - Function to execute for the current element. the function takes two parameters error, element.\r\n         */\r\n        current: function(callback) {\r\n            this.executionContext.current(function (err, item) {\r\n                if (err) {\r\n                    return callback(err, undefined);\r\n                }\r\n                if (item === undefined) {\r\n                    return callback(undefined, undefined);\r\n                }\r\n                callback(undefined, item[\"payload\"]);\r\n            });\r\n        },\r\n\r\n        /**\r\n         * Determine if there are still remaining resources to processs.\r\n         * @memberof OrderByEndpointComponent\r\n         * @instance\r\n         * @returns {Boolean} true if there is other elements to process in the OrderByEndpointComponent.\r\n         */\r\n        hasMoreResults: function () {\r\n            return this.executionContext.hasMoreResults();\r\n        },\r\n    }\r\n);\r\n\r\nvar TopEndpointComponent = Base.defineClass(\r\n    /**\r\n     * Represents an endpoint in handling top query. It only returns as many results as top arg specified.\r\n     * @constructor TopEndpointComponent\r\n     * @param { object } executionContext - Underlying Execution Context\r\n     * @ignore\r\n     */\r\n    function (executionContext, topCount) {\r\n        this.executionContext = executionContext;\r\n        this.topCount = topCount;\r\n    },\r\n    {\r\n\r\n        /**\r\n        * Execute a provided function on the next element in the TopEndpointComponent.\r\n        * @memberof TopEndpointComponent\r\n        * @instance\r\n        * @param {callback} callback - Function to execute for each element. the function takes two parameters error, element.\r\n        */\r\n        nextItem: function (callback) {\r\n            if (this.topCount <= 0) {\r\n                return callback(undefined, undefined);\r\n            }\r\n            this.topCount--;\r\n            this.executionContext.nextItem(function (err, item) {\r\n                callback(err, item);\r\n            });\r\n        },\r\n\r\n        /**\r\n         * Retrieve the current element on the TopEndpointComponent.\r\n         * @memberof TopEndpointComponent\r\n         * @instance\r\n         * @param {callback} callback - Function to execute for the current element. the function takes two parameters error, element.\r\n         */\r\n        current: function (callback) {\r\n            if (this.topCount <= 0) {\r\n                return callback(undefined, undefined);\r\n            }\r\n            this.executionContext.current(function (err, item) {\r\n                return callback(err, item);\r\n            });\r\n        },\r\n\r\n        /**\r\n         * Determine if there are still remaining resources to processs.\r\n         * @memberof TopEndpointComponent\r\n         * @instance\r\n         * @returns {Boolean} true if there is other elements to process in the TopEndpointComponent.\r\n         */\r\n        hasMoreResults: function () {\r\n            return (this.topCount > 0 && this.executionContext.hasMoreResults());\r\n        },\r\n    }\r\n);\r\n\r\nvar AggregateEndpointComponent = Base.defineClass(\r\n    /**\r\n     * Represents an endpoint in handling aggregate queries.\r\n     * @constructor AggregateEndpointComponent\r\n     * @param { object } executionContext - Underlying Execution Context\r\n     * @ignore\r\n     */\r\n    function (executionContext, aggregateOperators) {\r\n        this.executionContext = executionContext;\r\n        this.localAggregators = [];\r\n        var that = this;\r\n        aggregateOperators.forEach(function (aggregateOperator) {\r\n            switch (aggregateOperator) {\r\n                case 'Average':\r\n                    that.localAggregators.push(new aggregators.AverageAggregator());\r\n                    break;\r\n                case 'Count':\r\n                    that.localAggregators.push(new aggregators.CountAggregator());\r\n                    break;\r\n                case 'Max':\r\n                    that.localAggregators.push(new aggregators.MaxAggregator());\r\n                    break;\r\n                case 'Min':\r\n                    that.localAggregators.push(new aggregators.MinAggregator());\r\n                    break;\r\n                case 'Sum':\r\n                    that.localAggregators.push(new aggregators.SumAggregator());\r\n                    break;\r\n            }\r\n        });\r\n    },\r\n    {\r\n        /**\r\n        * Populate the aggregated values\r\n        * @ignore \r\n        */\r\n        _getAggregateResult: function (callback) {\r\n            this.toArrayTempResources = [];\r\n            this.aggregateValues = [];\r\n            this.aggregateValuesIndex = -1;\r\n            var that = this;\r\n\r\n            this._getQueryResults(function (err, resources) {\r\n                if (err) {\r\n                    return callback(err, undefined);\r\n                }\r\n\r\n                resources.forEach(function (resource) {\r\n                    that.localAggregators.forEach(function (aggregator) {\r\n                        var itemValue = undefined;\r\n                        // Get the value of the first property if it exists\r\n                        if (resource && Object.keys(resource).length > 0) {\r\n                            var key = Object.keys(resource)[0];\r\n                            itemValue = resource[key];\r\n                        }\r\n                        aggregator.aggregate(itemValue);\r\n                    });\r\n                });\r\n\r\n                // Get the aggregated results\r\n                that.localAggregators.forEach(function (aggregator) {\r\n                    that.aggregateValues.push(aggregator.getResult());\r\n                });\r\n\r\n                return callback(undefined, that.aggregateValues);\r\n            });\r\n        },\r\n\r\n        /**\r\n        * Get the results of queries from all partitions\r\n        * @ignore \r\n        */\r\n        _getQueryResults: function (callback) {\r\n            var that = this;\r\n\r\n            this.executionContext.nextItem(function (err, item) {\r\n                if (err) {\r\n                    return callback(err, undefined);\r\n                }\r\n                \r\n                if (item === undefined) {\r\n                    // no more results\r\n                    return callback(undefined, that.toArrayTempResources);\r\n                }\r\n\r\n                that.toArrayTempResources = that.toArrayTempResources.concat(item);\r\n                return that._getQueryResults(callback);\r\n            });\r\n\r\n        },\r\n\r\n        /**\r\n        * Execute a provided function on the next element in the AggregateEndpointComponent.\r\n        * @memberof AggregateEndpointComponent\r\n        * @instance\r\n        * @param {callback} callback - Function to execute for each element. the function takes two parameters error, element.\r\n        */\r\n        nextItem: function (callback) {\r\n            var that = this;\r\n            var _nextItem = function (err, resources) {\r\n                if (err || that.aggregateValues.length <= 0) {\r\n                    return callback(undefined, undefined);\r\n                }\r\n\r\n                var resource = that.aggregateValuesIndex < that.aggregateValues.length\r\n                    ? that.aggregateValues[++that.aggregateValuesIndex]\r\n                    : undefined;\r\n\r\n                return callback(undefined, resource);\r\n            };\r\n\r\n            if (that.aggregateValues == undefined) {\r\n                that._getAggregateResult(function (err, resources) {\r\n                    return _nextItem(err, resources);\r\n                });\r\n            }\r\n            else {\r\n                return _nextItem(undefined, that.aggregateValues);\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Retrieve the current element on the AggregateEndpointComponent.\r\n         * @memberof AggregateEndpointComponent\r\n         * @instance\r\n         * @param {callback} callback - Function to execute for the current element. the function takes two parameters error, element.\r\n         */\r\n        current: function (callback) {\r\n            var that = this;\r\n            if (that.aggregateValues == undefined) {\r\n                that._getAggregateResult(function (err, resources) {\r\n                    return callback(undefined, that.aggregateValues[that.aggregateValuesIndex]);\r\n                });\r\n            }\r\n            else {\r\n                return callback(undefined, that.aggregateValues[that.aggregateValuesIndex]);\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Determine if there are still remaining resources to processs.\r\n         * @memberof AggregateEndpointComponent\r\n         * @instance\r\n         * @returns {Boolean} true if there is other elements to process in the AggregateEndpointComponent.\r\n         */\r\n        hasMoreResults: function () {\r\n            return this.aggregateValues != null && this.aggregateValuesIndex < this.aggregateValues.length - 1;\r\n        }\r\n    }\r\n);\r\n//SCRIPT END\r\n\r\nif (typeof exports !== \"undefined\") {\r\n    exports.OrderByEndpointComponent = OrderByEndpointComponent;\r\n    exports.TopEndpointComponent = TopEndpointComponent;\r\n    exports.AggregateEndpointComponent = AggregateEndpointComponent;\r\n}","/home/travis/build/npmtest/node-npmtest-documentdb/node_modules/documentdb/lib/queryExecutionContext/aggregators.js":"/*\r\nThe MIT License (MIT)\r\nCopyright (c) 2014 Microsoft Corporation\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy\r\nof this software and associated documentation files (the \"Software\"), to deal\r\nin the Software without restriction, including without limitation the rights\r\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\ncopies of the Software, and to permit persons to whom the Software is\r\nfurnished to do so, subject to the following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included in all\r\ncopies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\nSOFTWARE.\r\n*/\r\n\r\n\"use strict\";\r\n\r\nvar Base = require(\"../base\")\r\n    , DocumentProducer = require(\"./documentProducer\")\r\n\r\n//SCRIPT START\r\nvar AverageAggregator = Base.defineClass(\r\n\r\n    /**\r\n     * Represents an aggregator for AVG operator.\r\n     * @constructor AverageAggregator\r\n     * @ignore\r\n     */\r\n    function () {\r\n    },\r\n    {\r\n        /**\r\n        * Add the provided item to aggregation result.\r\n        * @memberof AverageAggregator\r\n        * @instance\r\n        * @param other\r\n        */\r\n        aggregate: function (other) {\r\n            if (other == null || other.sum == null) {\r\n                return;\r\n            }\r\n            if (this.sum == null) {\r\n                this.sum = 0.0;\r\n                this.count = 0;\r\n            }\r\n            this.sum += other.sum;\r\n            this.count += other.count;\r\n        },\r\n\r\n        /**\r\n        * Get the aggregation result.\r\n        * @memberof AverageAggregator\r\n        * @instance\r\n        */\r\n        getResult: function () {\r\n            if (this.sum == null || this.count <= 0) {\r\n                return undefined;\r\n            }\r\n            return this.sum / this.count;\r\n        }\r\n\r\n    }\r\n);\r\n\r\nvar CountAggregator = Base.defineClass(\r\n\r\n    /**\r\n     * Represents an aggregator for COUNT operator.\r\n     * @constructor CountAggregator\r\n     * @ignore\r\n     */\r\n    function () {\r\n        this.value = 0;\r\n    },\r\n    {\r\n        /**\r\n        * Add the provided item to aggregation result.\r\n        * @memberof CountAggregator\r\n        * @instance\r\n        * @param other\r\n        */\r\n        aggregate: function (other) {\r\n            this.value += other;\r\n        },\r\n\r\n        /**\r\n        * Get the aggregation result.\r\n        * @memberof CountAggregator\r\n        * @instance\r\n        */\r\n        getResult: function () {\r\n            return this.value;\r\n        }\r\n\r\n    }\r\n);\r\n\r\nvar MinAggregator = Base.defineClass(\r\n\r\n    /**\r\n     * Represents an aggregator for MIN operator.\r\n     * @constructor MinAggregator\r\n     * @ignore\r\n     */\r\n    function () {\r\n        this.value = undefined;\r\n        this.comparer = new DocumentProducer.OrderByDocumentProducerComparator(\"Ascending\");\r\n    },\r\n    {\r\n        /**\r\n        * Add the provided item to aggregation result.\r\n        * @memberof MinAggregator\r\n        * @instance\r\n        * @param other\r\n        */\r\n        aggregate: function (other) {\r\n            if (this.value == undefined) {\r\n                this.value = other;\r\n            }\r\n            else {\r\n                var otherType = other == null ? 'NoValue' : typeof (other);\r\n                if (this.comparer.compareValue(other, otherType, this.value, typeof (this.value)) < 0) {\r\n                    this.value = other;\r\n                }\r\n            }\r\n        },\r\n\r\n        /**\r\n        * Get the aggregation result.\r\n        * @memberof MinAggregator\r\n        * @instance\r\n        */\r\n        getResult: function () {\r\n            return this.value;\r\n        }\r\n\r\n    }\r\n);\r\n\r\nvar MaxAggregator = Base.defineClass(\r\n\r\n    /**\r\n     * Represents an aggregator for MAX operator.\r\n     * @constructor MaxAggregator\r\n     * @ignore\r\n     */\r\n    function () {\r\n        this.value = undefined;\r\n        this.comparer = new DocumentProducer.OrderByDocumentProducerComparator(\"Ascending\");\r\n    },\r\n    {\r\n        /**\r\n        * Add the provided item to aggregation result.\r\n        * @memberof MaxAggregator\r\n        * @instance\r\n        * @param other\r\n        */\r\n        aggregate: function (other) {\r\n            if (this.value == undefined) {\r\n                this.value = other;\r\n            }\r\n            else if (this.comparer.compareValue(other, typeof (other), this.value, typeof (this.value)) > 0) {\r\n                this.value = other;\r\n            }\r\n        },\r\n\r\n        /**\r\n        * Get the aggregation result.\r\n        * @memberof MaxAggregator\r\n        * @instance\r\n        */\r\n        getResult: function () {\r\n            return this.value;\r\n        }\r\n\r\n    }\r\n);\r\n\r\nvar SumAggregator = Base.defineClass(\r\n\r\n    /**\r\n     * Represents an aggregator for SUM operator.\r\n     * @constructor SumAggregator\r\n     * @ignore\r\n     */\r\n    function () {\r\n    },\r\n    {\r\n        /**\r\n        * Add the provided item to aggregation result.\r\n        * @memberof SumAggregator\r\n        * @instance\r\n        * @param other\r\n        */\r\n        aggregate: function (other) {\r\n            if (other == undefined) {\r\n                return;\r\n            }\r\n            if (this.sum == undefined) {\r\n                this.sum = other;\r\n            }\r\n            else {\r\n                this.sum += other;\r\n            }\r\n        },\r\n\r\n        /**\r\n        * Get the aggregation result.\r\n        * @memberof SumAggregator\r\n        * @instance\r\n        */\r\n        getResult: function () {\r\n            return this.sum;\r\n        }\r\n\r\n    }\r\n);\r\n //SCRIPT END\r\n\r\nif (typeof exports !== \"undefined\") {\r\n    exports.AverageAggregator = AverageAggregator;\r\n    exports.CountAggregator = CountAggregator;\r\n    exports.MinAggregator = MinAggregator;\r\n    exports.MaxAggregator = MaxAggregator;\r\n    exports.SumAggregator = SumAggregator;\r\n}\r\n","/home/travis/build/npmtest/node-npmtest-documentdb/node_modules/documentdb/lib/queryExecutionContext/pipelinedQueryExecutionContext.js":"/*\r\nThe MIT License (MIT)\r\nCopyright (c) 2014 Microsoft Corporation\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy\r\nof this software and associated documentation files (the \"Software\"), to deal\r\nin the Software without restriction, including without limitation the rights\r\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\ncopies of the Software, and to permit persons to whom the Software is\r\nfurnished to do so, subject to the following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included in all\r\ncopies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\nSOFTWARE.\r\n*/\r\n\r\n\"use strict\";\r\n\r\nvar Base = require(\"../base\")\r\n    , DefaultQueryExecutionContext = require(\"./defaultQueryExecutionContext\")\r\n    , endpointComponent = require('./endpointComponent')\r\n    , assert = require(\"assert\")\r\n    , QueryExecutionInfoParser = require(\"./partitionedQueryExecutionContextInfoParser\");\r\n\r\n//SCRIPT START\r\nvar PipelinedQueryExecutionContext = Base.defineClass(\r\n    /**\r\n     * Provides the PipelinedQueryExecutionContext. It piplelines top and orderby execution context if necessary\r\n     * @constructor PipelinedQueryExecutionContext\r\n     * @param {DocumentClient} documentclient        - The service endpoint to use to create the client.\r\n     * @param {FeedOptions} [options]                - Represents the feed options.\r\n     * @param {object} partitionedQueryExecutionInfo  - PartitionedQueryExecutionInfo\r\n     * @ignore\r\n     */\r\n    function (documentclient, options, executionContext, partitionedQueryExecutionInfo) {\r\n        this.documentclient = documentclient;\r\n        this.options = options;\r\n        this.partitionedQueryExecutionInfo = partitionedQueryExecutionInfo;\r\n        this.endpoint = executionContext;\r\n        this.pageSize = options[\"maxItemCount\"];\r\n        if (this.pageSize === undefined) {\r\n            this.pageSize = PipelinedQueryExecutionContext.DEFAULT_PAGE_SIZE;\r\n        }\r\n        var orderBy = QueryExecutionInfoParser.parseOrderBy(partitionedQueryExecutionInfo);\r\n        if (Array.isArray(orderBy) && orderBy.length > 0) {\r\n            this.endpoint = new endpointComponent.OrderByEndpointComponent(this.endpoint);\r\n        }\r\n\r\n        var aggregates = QueryExecutionInfoParser.parseAggregates(partitionedQueryExecutionInfo);\r\n        if (Array.isArray(aggregates) && aggregates.length > 0) {\r\n            this.endpoint = new endpointComponent.AggregateEndpointComponent(this.endpoint, aggregates);\r\n        }\r\n\r\n        var top = QueryExecutionInfoParser.parseTop(partitionedQueryExecutionInfo);\r\n        if (typeof (top) === 'number') {\r\n            this.endpoint = new endpointComponent.TopEndpointComponent(this.endpoint, top);\r\n        }\r\n    },\r\n    {\r\n        nextItem: function (callback) {\r\n            return this.endpoint.nextItem(callback);\r\n        },\r\n\r\n        current: function (callback) {\r\n            return this.endpoint.current(callback);\r\n        },\r\n\r\n        hasMoreResults: function (callback) {\r\n            return this.endpoint.hasMoreResults(callback);\r\n        },\r\n\r\n        fetchMore: function (callback) {\r\n            this._fetchMoreTempBufferedResults = [];\r\n            this._fetchMoreLastResHeaders = undefined;\r\n            this._fetchMoreImplementation(callback);\r\n        },\r\n\r\n        _fetchMoreImplementation: function (callback) {\r\n            var that = this;\r\n            var counter = 0;\r\n\r\n            this.endpoint.nextItem(function (err, resources, headers) {\r\n                if (err) {\r\n                    return callback(err, undefined, headers);\r\n                }\r\n                // concatinate the results and fetch more\r\n                that._fetchMoreLastResHeaders = headers;\r\n                if (resources === undefined) {\r\n                    // no more results\r\n                    if (that._fetchMoreTempBufferedResults.length === 0) {\r\n                        return callback(undefined, undefined, that._fetchMoreLastResHeaders);\r\n                    }\r\n\r\n                    var temp = that._fetchMoreTempBufferedResults;\r\n                    that._fetchMoreTempBufferedResults = [];\r\n                    return callback(undefined, temp, that._fetchMoreLastResHeaders);\r\n                }\r\n\r\n                that._fetchMoreTempBufferedResults = that._fetchMoreTempBufferedResults.concat(resources);\r\n\r\n                if (that.pageSize <= that._fetchMoreTempBufferedResults.length) {\r\n                    // fetched enough results\r\n                    var temp = that._fetchMoreTempBufferedResults;\r\n                    that._fetchMoreTempBufferedResults = [];\r\n\r\n                    return callback(undefined, temp, that._fetchMoreLastResHeaders);\r\n                }\r\n\r\n                that._fetchMoreImplementation(callback);\r\n            });\r\n        },\r\n    },\r\n    {\r\n        DEFAULT_PAGE_SIZE: 1000\r\n    }\r\n);\r\n//SCRIPT END\r\n\r\nif (typeof exports !== \"undefined\") {\r\n    module.exports = PipelinedQueryExecutionContext;\r\n}\r\n","/home/travis/build/npmtest/node-npmtest-documentdb/node_modules/documentdb/lib/request.js":"/*\r\nThe MIT License (MIT)\r\nCopyright (c) 2014 Microsoft Corporation\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy\r\nof this software and associated documentation files (the \"Software\"), to deal\r\nin the Software without restriction, including without limitation the rights\r\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\ncopies of the Software, and to permit persons to whom the Software is\r\nfurnished to do so, subject to the following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included in all\r\ncopies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\nSOFTWARE.\r\n*/\r\n\r\n\"use strict\";\r\n\r\nvar Documents = require(\"./documents\")\r\n  , Constants = require(\"./constants\")\r\n  , https = require(\"https\")\r\n  , url = require(\"url\")\r\n  , querystring = require(\"querystring\")\r\n  , RetryUtility = require(\"./retryUtility\")\r\n  // Dedicated Agent for socket pooling\r\n  , keepAliveAgent = new https.Agent({ keepAlive: true, maxSockets: Infinity });\r\n\r\n//----------------------------------------------------------------------------\r\n// Utility methods\r\n//\r\n\r\nfunction bodyFromData(data) {\r\n    if (data.pipe) return data;\r\n    if (Buffer.isBuffer(data)) return data;\r\n    if (typeof data === \"string\") return data;\r\n    if (typeof data === \"object\") return JSON.stringify(data);\r\n    return undefined;\r\n}\r\n\r\nfunction parse(urlString) { return url.parse(urlString); }\r\n\r\nfunction createRequestObject(connectionPolicy, requestOptions, callback){\r\n    function onTimeout() {\r\n        httpsRequest.abort();\r\n    }\r\n\r\n    var isMedia = ( requestOptions.path.indexOf(\"media\") > -1 );\r\n\r\n    var httpsRequest = https.request(requestOptions, function(response) {\r\n        // In case of media response, return the stream to the user and the user will need to handle reading the stream.\r\n        if (isMedia && connectionPolicy.MediaReadMode === Documents.MediaReadMode.Streamed) {\r\n            return callback(undefined, response, response.headers);\r\n        }\r\n\r\n        var data = \"\";\r\n        response.on(\"data\", function(chunk) {\r\n            data += chunk;\r\n        });\r\n        response.on(\"end\", function() {\r\n            if (response.statusCode >= 400) {\r\n                return callback(getErrorBody(response, data), undefined, response.headers);\r\n                }\r\n\r\n            var result;\r\n            try {\r\n                if (isMedia) {\r\n                    result = data;\r\n                } else {\r\n                    result = data.length > 0 ? JSON.parse(data) : undefined;\r\n                }\r\n            } catch (exception) {\r\n                return callback(exception);\r\n            }\r\n\r\n            callback(undefined, result, response.headers);\r\n        });\r\n    });\r\n\r\n    httpsRequest.once(\"socket\", function(socket) {\r\n        if (isMedia) {\r\n            socket.setTimeout(connectionPolicy.MediaRequestTimeout);\r\n        } else {\r\n            socket.setTimeout(connectionPolicy.RequestTimeout);\r\n        }\r\n\r\n        socket.once(\"timeout\", onTimeout);\r\n\r\n        httpsRequest.once(\"response\", function () {\r\n            socket.removeListener(\"timeout\", onTimeout);\r\n        });\r\n    });\r\n\r\n    httpsRequest.once(\"error\", callback);\r\n    return httpsRequest;\r\n}\r\n\r\n/**\r\n*  Constructs the error body from the response and the data returned from the request.\r\n* @param {object} response - response object returned from the executon of a request.\r\n* @param {object} data - the data body returned from the executon of a request.\r\n*/\r\nfunction getErrorBody(response, data) {\r\n\tvar errorBody = { code: response.statusCode, body: data };\r\n\t\r\n\tif (Constants.HttpHeaders.ActivityId in response.headers) {\r\n\t\terrorBody.activityId = response.headers[Constants.HttpHeaders.ActivityId];\r\n\t}\r\n    \r\n    if (Constants.HttpHeaders.SubStatus in response.headers) {\r\n        errorBody.substatus = parseInt(response.headers[Constants.HttpHeaders.SubStatus]);\r\n    }\r\n    \r\n    if (Constants.HttpHeaders.RetryAfterInMilliseconds in response.headers) {\r\n        errorBody.retryAfterInMilliseconds = parseInt(response.headers[Constants.HttpHeaders.RetryAfterInMilliseconds]);\r\n    }\r\n\r\n    return errorBody;\r\n}\r\n\r\nvar RequestHandler = {\r\n    _createRequestObjectStub: function (connectionPolicy, requestOptions, callback) {\r\n        return createRequestObject(connectionPolicy, requestOptions, callback);\r\n    },\r\n\r\n    /**\r\n     *  Creates the request object, call the passed callback when the response is retrieved.\r\n     * @param {object} globalEndpointManager - an instance of GlobalEndpointManager class.\r\n     * @param {object} connectionPolicy - an instance of ConnectionPolicy that has the connection configs.\r\n     * @param {string} method - the http request method ( 'get', 'post', 'put', .. etc ).\r\n     * @param {String} url - The base url for the endpoint.\r\n     * @param {string} path - the path of the requesed resource.\r\n     * @param {Object} data - the request body. It can be either string, buffer, stream or undefined.\r\n     * @param {Object} queryParams - query parameters for the request.\r\n     * @param {Object} headers - specific headers for the request.\r\n     * @param {function} callback - the callback that will be called when the response is retrieved and processed.\r\n    */\r\n    request: function (globalEndpointManager, connectionPolicy, method, url, path, data, queryParams, headers, callback) {\r\n        var body;\r\n        \r\n        if (data) {\r\n            body = bodyFromData(data);\r\n            if (!body) return callback({ message: \"parameter data must be a javascript object, string, Buffer, or stream\" });\r\n        }\r\n        \r\n        var buffer;\r\n        var stream;\r\n        if (body) {\r\n            if (Buffer.isBuffer(body)) {\r\n                buffer = body;\r\n            } else if (body.pipe) {\r\n                // it is a stream\r\n                stream = body;\r\n            } else if (typeof body === \"string\") {\r\n                buffer = new Buffer(body, \"utf8\");\r\n            } else {\r\n                callback({ message: \"body must be string, Buffer, or stream\" });\r\n            }\r\n        }\r\n        \r\n        var requestOptions = parse(url);\r\n        requestOptions.method = method;\r\n        requestOptions.path = path;\r\n        requestOptions.headers = headers;\r\n        requestOptions.agent = keepAliveAgent;\r\n        requestOptions.secureProtocol = \"TLSv1_client_method\";\r\n\r\n        if (connectionPolicy.DisableSSLVerification === true) {\r\n            requestOptions.rejectUnauthorized = false;\r\n        }\r\n\r\n        if (queryParams) {\r\n            requestOptions.path += \"?\" + querystring.stringify(queryParams);\r\n        }\r\n        \r\n        if (buffer) {\r\n            requestOptions.headers[Constants.HttpHeaders.ContentLength] = buffer.length;\r\n            RetryUtility.execute(globalEndpointManager, { buffer: buffer, stream: null }, this._createRequestObjectStub, connectionPolicy, requestOptions, callback);\r\n        } else if (stream) {\r\n            RetryUtility.execute(globalEndpointManager, { buffer: null, stream: stream }, this._createRequestObjectStub, connectionPolicy, requestOptions, callback);\r\n        } else {\r\n            RetryUtility.execute(globalEndpointManager, { buffer: null, stream: null }, this._createRequestObjectStub, connectionPolicy, requestOptions, callback);\r\n        }\r\n    }\r\n}\r\n\r\nif (typeof exports !== \"undefined\") {\r\n    module.exports = RequestHandler;\r\n}\r\n","/home/travis/build/npmtest/node-npmtest-documentdb/node_modules/documentdb/lib/retryUtility.js":"/*\r\nThe MIT License (MIT)\r\nCopyright (c) 2014 Microsoft Corporation\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy\r\nof this software and associated documentation files (the \"Software\"), to deal\r\nin the Software without restriction, including without limitation the rights\r\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\ncopies of the Software, and to permit persons to whom the Software is\r\nfurnished to do so, subject to the following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included in all\r\ncopies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\nSOFTWARE.\r\n*/\r\n\r\n\"use strict\";\r\n\r\nvar Base = require(\"./base\"),\r\n    Constants = require(\"./constants\"),\r\n    EndpointDiscoveryRetryPolicy = require(\"./endpointDiscoveryRetryPolicy\"),\r\n    ResourceThrottleRetryPolicy = require(\"./resourceThrottleRetryPolicy\");\r\n\r\n//SCRIPT START\r\nvar RetryUtility = {\r\n    /**\r\n    * Executes the retry policy for the created request object.\r\n    * @param {object} globalEndpointManager - an instance of GlobalEndpointManager class.\r\n    * @param {object} body - a dictionary containing 'buffer' and 'stream' keys to hold corresponding buffer or stream body, null otherwise.\r\n    * @param {function} createRequestObjectStub - stub function that creates the request object.\r\n    * @param {object} connectionPolicy - an instance of ConnectionPolicy that has the connection configs.\r\n    * @param {RequestOptions} requestOptions - The request options.\r\n    * @param {function} callback - the callback that will be called when the request is finished executing.\r\n    */\r\n    execute: function (globalEndpointManager, body, createRequestObjectFunc, connectionPolicy, requestOptions, callback) {\r\n        var endpointDiscoveryRetryPolicy = new EndpointDiscoveryRetryPolicy(globalEndpointManager);\r\n        var resourceThrottleRetryPolicy = new ResourceThrottleRetryPolicy(connectionPolicy.RetryOptions.MaxRetryAttemptCount, \r\n                                                connectionPolicy.RetryOptions.FixedRetryIntervalInMilliseconds,\r\n                                                connectionPolicy.RetryOptions.MaxWaitTimeInSeconds);\r\n\r\n        this.apply(body, createRequestObjectFunc, connectionPolicy, requestOptions, endpointDiscoveryRetryPolicy, resourceThrottleRetryPolicy, callback);\r\n    },\r\n    \r\n    /**\r\n    * Applies the retry policy for the created request object.\r\n    * @param {object} body - a dictionary containing 'buffer' and 'stream' keys to hold corresponding buffer or stream body, null otherwise.\r\n    * @param {function} createRequestObjectFunc - function that creates the request object.\r\n    * @param {object} connectionPolicy - an instance of ConnectionPolicy that has the connection configs.\r\n    * @param {RequestOptions} requestOptions - The request options.\r\n    * @param {EndpointDiscoveryRetryPolicy} endpointDiscoveryRetryPolicy - The endpoint discovery retry policy instance.\r\n    * @param {ResourceThrottleRetryPolicy} resourceThrottleRetryPolicy - The resource throttle retry policy instance.\r\n    * @param {function} callback - the callback that will be called when the response is retrieved and processed.\r\n    */\r\n    apply: function (body, createRequestObjectFunc, connectionPolicy, requestOptions, endpointDiscoveryRetryPolicy, resourceThrottleRetryPolicy, callback) {\r\n        var that = this;\r\n        var httpsRequest = createRequestObjectFunc(connectionPolicy, requestOptions, function (err, response, headers) {\r\n            if (err) {\r\n                var retryPolicy = null;\r\n                headers = headers || {};\r\n                if (err.code === EndpointDiscoveryRetryPolicy.FORBIDDEN_STATUS_CODE && err.substatus === EndpointDiscoveryRetryPolicy.WRITE_FORBIDDEN_SUB_STATUS_CODE) {\r\n                    retryPolicy = endpointDiscoveryRetryPolicy;\r\n                } else if (err.code === ResourceThrottleRetryPolicy.THROTTLE_STATUS_CODE) {\r\n                    retryPolicy = resourceThrottleRetryPolicy;\r\n                }\r\n                if (retryPolicy) {\r\n                    retryPolicy.shouldRetry(err, function (shouldRetry) {\r\n                        if (!shouldRetry) {\r\n                            headers[Constants.ThrottleRetryCount] = resourceThrottleRetryPolicy.currentRetryAttemptCount;\r\n                            headers[Constants.ThrottleRetryWaitTimeInMs] = resourceThrottleRetryPolicy.cummulativeWaitTimeinMilliseconds;\r\n                            return callback(err, response, headers);\r\n                        } else {\r\n                            setTimeout(function () {\r\n                                that.apply(body, createRequestObjectFunc, connectionPolicy, requestOptions, endpointDiscoveryRetryPolicy, resourceThrottleRetryPolicy, callback);\r\n                            }, retryPolicy.retryAfterInMilliseconds);\r\n                            return;\r\n                        }\r\n                    });\r\n                    return;\r\n                }\r\n            }\r\n            headers[Constants.ThrottleRetryCount] = resourceThrottleRetryPolicy.currentRetryAttemptCount;\r\n            headers[Constants.ThrottleRetryWaitTimeInMs] = resourceThrottleRetryPolicy.cummulativeWaitTimeinMilliseconds;\r\n            return callback(err, response, headers);\r\n        });\r\n        \r\n        if (httpsRequest) {\r\n            if (body[\"stream\"] !== null) {\r\n                body[\"stream\"].pipe(httpsRequest);\r\n            } else if (body[\"buffer\"] !== null) {\r\n                httpsRequest.write(body[\"buffer\"]);\r\n                httpsRequest.end();\r\n            } else {\r\n                httpsRequest.end();\r\n            }\r\n        }\r\n    }\r\n}\r\n//SCRIPT END\r\n\r\nif (typeof exports !== \"undefined\") {\r\n    module.exports = RetryUtility;\r\n}","/home/travis/build/npmtest/node-npmtest-documentdb/node_modules/documentdb/lib/endpointDiscoveryRetryPolicy.js":"/*\r\nThe MIT License (MIT)\r\nCopyright (c) 2014 Microsoft Corporation\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy\r\nof this software and associated documentation files (the \"Software\"), to deal\r\nin the Software without restriction, including without limitation the rights\r\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\ncopies of the Software, and to permit persons to whom the Software is\r\nfurnished to do so, subject to the following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included in all\r\ncopies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\nSOFTWARE.\r\n*/\r\n\r\n\"use strict\";\r\n\r\nvar Base = require(\"./base\");\r\n\r\n//SCRIPT START\r\n/**\r\n     * This class implements the retry policy for endpoint discovery.\r\n     * @property {int} _maxRetryAttemptCount                           - Max number of retry attempts to perform.\r\n     * @property {int} currentRetryAttemptCount                        - Current retry attempt count.\r\n     * @property {object} globalEndpointManager                        - The GlobalEndpointManager instance.\r\n     * @property {int} retryAfterInMilliseconds                        - Retry interval in milliseconds.\r\n*/\r\nvar EndpointDiscoveryRetryPolicy = Base.defineClass(\r\n    /**\r\n     * @constructor EndpointDiscoveryRetryPolicy\r\n     * @param {object} globalEndpointManager                           - The GlobalEndpointManager instance.\r\n    */\r\n    function (globalEndpointManager) {\r\n        this._maxRetryAttemptCount = EndpointDiscoveryRetryPolicy.maxRetryAttemptCount;\r\n        this.currentRetryAttemptCount = 0;\r\n        this.globalEndpointManager = globalEndpointManager;\r\n        this.retryAfterInMilliseconds = EndpointDiscoveryRetryPolicy.retryAfterInMilliseconds;\r\n    }, \r\n    {\r\n        /**\r\n         * Determines whether the request should be retried or not.\r\n         * @param {object} err - Error returned by the request.\r\n         * @param {function} callback - The callback function which takes bool argument which specifies whether the request will be retried or not.\r\n        */\r\n        shouldRetry: function (err, callback) {\r\n            if (err) {\r\n                if (this.currentRetryAttemptCount < this._maxRetryAttemptCount && this.globalEndpointManager.enableEndpointDiscovery) {\r\n                    this.currentRetryAttemptCount++;\r\n                    console.log(\"Write region was changed, refreshing the regions list from database account and will retry the request.\");\r\n                    var that = this;\r\n                    this.globalEndpointManager.refreshEndpointList(function (writeEndpoint, readEndpoint) {\r\n                        that.globalEndpointManager.setWriteEndpoint(writeEndpoint);\r\n                        that.globalEndpointManager.setReadEndpoint(readEndpoint);\r\n                        callback(true);\r\n                    });\r\n                    return;\r\n                }\r\n            }\r\n            return callback(false);\r\n        }\r\n    },\r\n    {\r\n        maxRetryAttemptCount : 120,\r\n        retryAfterInMilliseconds : 1000,\r\n        FORBIDDEN_STATUS_CODE : 403,\r\n        WRITE_FORBIDDEN_SUB_STATUS_CODE : 3\r\n    }\r\n);\r\n//SCRIPT END\r\n\r\nif (typeof exports !== \"undefined\") {\r\n    module.exports = EndpointDiscoveryRetryPolicy;\r\n}","/home/travis/build/npmtest/node-npmtest-documentdb/node_modules/documentdb/lib/resourceThrottleRetryPolicy.js":"/*\r\nThe MIT License (MIT)\r\nCopyright (c) 2014 Microsoft Corporation\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy\r\nof this software and associated documentation files (the \"Software\"), to deal\r\nin the Software without restriction, including without limitation the rights\r\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\ncopies of the Software, and to permit persons to whom the Software is\r\nfurnished to do so, subject to the following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included in all\r\ncopies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\nSOFTWARE.\r\n*/\r\n\r\n\"use strict\";\r\n\r\nvar Base = require(\"./base\");\r\n\r\n//SCRIPT START\r\n/**\r\n     * This class implements the resource throttle retry policy for requests.\r\n     * @property {int} _maxRetryAttemptCount              - Max number of retries to be performed for a request.\r\n     * @property {int} _fixedRetryIntervalInMilliseconds  - Fixed retry interval in milliseconds to wait between each retry ignoring the retryAfter returned as part of the response. \r\n     * @property {int} _maxWaitTimeInMilliseconds         - Max wait time in milliseconds to wait for a request while the retries are happening.\r\n     * @property {int} currentRetryAttemptCount           - Current retry attempt count.\r\n     * @property {int} cummulativeWaitTimeinMilliseconds  - Cummulative wait time in milliseconds for a request while the retries are happening.\r\n*/\r\nvar ResourceThrottleRetryPolicy = Base.defineClass(\r\n    /**\r\n     * @constructor ResourceThrottleRetryPolicy\r\n     * @param {int} maxRetryAttemptCount               - Max number of retries to be performed for a request.\r\n     * @param {int} fixedRetryIntervalInMilliseconds   - Fixed retry interval in milliseconds to wait between each retry ignoring the retryAfter returned as part of the response.\r\n     * @param {int} maxWaitTimeInSeconds               - Max wait time in seconds to wait for a request while the retries are happening.\r\n    */\r\n    function (maxRetryAttemptCount, fixedRetryIntervalInMilliseconds, maxWaitTimeInSeconds) {\r\n        this._maxRetryAttemptCount = maxRetryAttemptCount;\r\n        this._fixedRetryIntervalInMilliseconds = fixedRetryIntervalInMilliseconds;\r\n        this._maxWaitTimeInMilliseconds = maxWaitTimeInSeconds * 1000;\r\n        this.currentRetryAttemptCount = 0;\r\n        this.cummulativeWaitTimeinMilliseconds = 0;\r\n    }, \r\n    {\r\n        /**\r\n         * Determines whether the request should be retried or not.\r\n         * @param {object} err - Error returned by the request.\r\n         * @param {function} callback - The callback function which takes bool argument which specifies whether the request will be retried or not.\r\n        */\r\n        shouldRetry: function (err, callback) {\r\n            if (err) {\r\n                if (this.currentRetryAttemptCount < this._maxRetryAttemptCount) {\r\n                    this.currentRetryAttemptCount++;\r\n                    this.retryAfterInMilliseconds = 0;\r\n\r\n                    if (this._fixedRetryIntervalInMilliseconds) {\r\n                        this.retryAfterInMilliseconds = this._fixedRetryIntervalInMilliseconds;\r\n                    } else if (err.retryAfterInMilliseconds) {\r\n                        this.retryAfterInMilliseconds = err.retryAfterInMilliseconds;\r\n                    }\r\n    \r\n                    if (this.cummulativeWaitTimeinMilliseconds < this._maxWaitTimeInMilliseconds) {\r\n                        this.cummulativeWaitTimeinMilliseconds += this.retryAfterInMilliseconds;\r\n                        return callback(true);\r\n                    }\r\n                }\r\n            }\r\n            return callback(false);\r\n        }\r\n    },\r\n    {\r\n        THROTTLE_STATUS_CODE: 429\r\n    }\r\n);\r\n//SCRIPT END\r\n\r\nif (typeof exports !== \"undefined\") {\r\n    module.exports = ResourceThrottleRetryPolicy;\r\n}","/home/travis/build/npmtest/node-npmtest-documentdb/node_modules/documentdb/lib/globalEndpointManager.js":"/*\r\nThe MIT License (MIT)\r\nCopyright (c) 2014 Microsoft Corporation\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy\r\nof this software and associated documentation files (the \"Software\"), to deal\r\nin the Software without restriction, including without limitation the rights\r\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\ncopies of the Software, and to permit persons to whom the Software is\r\nfurnished to do so, subject to the following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included in all\r\ncopies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\nSOFTWARE.\r\n*/\r\n\r\n\"use strict\";\r\n\r\nvar Base = require(\"./base\")\r\n    , Constants = require(\"./constants\")\r\n    , url = require(\"url\");\r\n\r\n//SCRIPT START\r\n/**\r\n     * This internal class implements the logic for endpoint management for geo-replicated\r\n       database accounts.\r\n     * @property {object} client                       - The document client instance.\r\n     * @property {string} defaultEndpoint              - The endpoint used to create the client instance.\r\n     * @property {bool} enableEndpointDiscovery        - Flag to enable/disable automatic redirecting of requests based on read/write operations.\r\n     * @property {Array} preferredLocations            - List of azure regions to be used as preferred locations for read requests.\r\n     * @property {bool} isEndpointCacheInitialized     - Flag to determine whether the endpoint cache is initialized or not.\r\n*/\r\nvar GlobalEndpointManager = Base.defineClass(\r\n    /**\r\n     * @constructor GlobalEndpointManager\r\n     * @param {object} client                          - The document client instance.\r\n    */\r\n    function (client) {\r\n        this.client = client;\r\n        this.defaultEndpoint = client.urlConnection;\r\n        this._readEndpoint = client.urlConnection;\r\n        this._writeEndpoint = client.urlConnection;\r\n        this.enableEndpointDiscovery = client.connectionPolicy.EnableEndpointDiscovery;\r\n        this.preferredLocations = client.connectionPolicy.PreferredLocations;\r\n        this.isEndpointCacheInitialized = false;\r\n    }, \r\n    {\r\n        /** Gets the current read endpoint from the endpoint cache.\r\n         * @memberof GlobalEndpointManager\r\n         * @instance\r\n         * @param {function} callback        - The callback function which takes readEndpoint(string) as an argument.\r\n        */\r\n        getReadEndpoint: function (callback) {\r\n            if (!this.isEndpointCacheInitialized) {\r\n                this.refreshEndpointList(function (writeEndpoint, readEndpoint) {\r\n                    callback(readEndpoint);\r\n                });\r\n            } else {\r\n                callback(this._readEndpoint);\r\n            }\r\n        },\r\n        \r\n        /** Sets the current read endpoint.\r\n         * @memberof GlobalEndpointManager\r\n         * @instance\r\n         * @param {string} readEndpoint        - The endpoint to be set as readEndpoint.\r\n        */\r\n        setReadEndpoint: function (readEndpoint) {\r\n            this._readEndpoint = readEndpoint;\r\n        },\r\n        \r\n        /** Gets the current write endpoint from the endpoint cache.\r\n         * @memberof GlobalEndpointManager\r\n         * @instance\r\n         * @param {function} callback        - The callback function which takes writeEndpoint(string) as an argument.\r\n        */\r\n        getWriteEndpoint: function (callback) {\r\n            if (!this.isEndpointCacheInitialized) {\r\n                this.refreshEndpointList(function (writeEndpoint, readEndpoint) {\r\n                    callback(writeEndpoint);\r\n                });\r\n            } else {\r\n                callback(this._writeEndpoint);\r\n            }\r\n        },\r\n        \r\n        /** Sets the current write endpoint.\r\n         * @memberof GlobalEndpointManager\r\n         * @instance\r\n         * @param {string} writeEndpoint        - The endpoint to be set as writeEndpoint.\r\n        */\r\n        setWriteEndpoint: function (writeEndpoint) {\r\n            this._writeEndpoint = writeEndpoint;\r\n        },\r\n        \r\n        /** Refreshes the endpoint list by retrieving the writable and readable locations\r\n            from the geo-replicated database account and then updating the locations cache.\r\n            We skip the refreshing if EnableEndpointDiscovery is set to False\r\n         * @memberof GlobalEndpointManager\r\n         * @instance\r\n         * @param {function} callback        - The callback function which takes writeEndpoint(string) and readEndpoint(string) as arguments.\r\n        */\r\n        refreshEndpointList: function (callback) {\r\n            var writableLocations = [];\r\n            var readableLocations = [];\r\n            var databaseAccount;\r\n            \r\n            var that = this;\r\n            if (this.enableEndpointDiscovery) {\r\n                this._getDatabaseAccount(function (databaseAccount) {\r\n                    if (databaseAccount) {\r\n                        writableLocations = databaseAccount.WritableLocations;\r\n                        readableLocations = databaseAccount.ReadableLocations;\r\n                    }\r\n                    \r\n                    // Read and Write endpoints will be initialized to default endpoint if we were not able to get the database account info\r\n                    that._updateLocationsCache(writableLocations, readableLocations, function (endpoints) {\r\n                        that._writeEndpoint = endpoints[0];\r\n                        that._readEndpoint = endpoints[1];\r\n                        that.isEndpointCacheInitialized = true;\r\n                        callback(that._writeEndpoint, that._readEndpoint);\r\n                    });\r\n                });\r\n            } else {\r\n                callback(that._writeEndpoint, that._readEndpoint);\r\n            }\r\n        },\r\n        \r\n        /** Gets the database account first by using the default endpoint, and if that doesn't returns\r\n           use the endpoints for the preferred locations in the order they are specified to get \r\n           the database account.\r\n         * @memberof GlobalEndpointManager\r\n         * @instance\r\n         * @param {function} callback        - The callback function which takes databaseAccount(object) as an argument.\r\n        */\r\n        _getDatabaseAccount: function (callback) {\r\n            var that = this;\r\n            var options = { urlConnection: this.defaultEndpoint };\r\n            this.client.getDatabaseAccount(options, function (err, databaseAccount) {\r\n                // If for any reason(non - globaldb related), we are not able to get the database account from the above call to getDatabaseAccount,\r\n                // we would try to get this information from any of the preferred locations that the user might have specified(by creating a locational endpoint)\r\n                // and keeping eating the exception until we get the database account and return None at the end, if we are not able to get that info from any endpoints\r\n                if (err) {\r\n                    var func = function (defaultEndpoint, preferredLocations, index) {\r\n                        if (index < preferredLocations.length) {\r\n                            var locationalEndpoint = that._getLocationalEndpoint(defaultEndpoint, preferredLocations[index]);\r\n                            var options = { urlConnection: locationalEndpoint };\r\n                            that.client.getDatabaseAccount(options, function (err, databaseAccount) {\r\n                                if (err) {\r\n                                    func(defaultEndpoint, preferredLocations, index + 1);\r\n                                } else {\r\n                                    return callback(databaseAccount);\r\n                                }\r\n                            });\r\n                        } else {\r\n                            return callback(null);\r\n                        }\r\n                    }\r\n                    func(that.defaultEndpoint, that.preferredLocations, 0);\r\n\r\n                } else {\r\n                    return callback(databaseAccount);\r\n                }\r\n            });\r\n        },\r\n\r\n        /** Gets the locational endpoint using the location name passed to it using the default endpoint.\r\n         * @memberof GlobalEndpointManager\r\n         * @instance\r\n         * @param {string} defaultEndpoint - The default endpoint to use for teh endpoint.\r\n         * @param {string} locationName    - The location name for the azure region like \"East US\".\r\n        */\r\n        _getLocationalEndpoint: function (defaultEndpoint, locationName) {\r\n            // For defaultEndpoint like 'https://contoso.documents.azure.com:443/' parse it to generate URL format\r\n            // This defaultEndpoint should be global endpoint(and cannot be a locational endpoint) and we agreed to document that\r\n            var endpointUrl = url.parse(defaultEndpoint, true, true);\r\n            \r\n            // hostname attribute in endpointUrl will return 'contoso.documents.azure.com'\r\n            if (endpointUrl.hostname) {\r\n                var hostnameParts = (endpointUrl.hostname).toString().toLowerCase().split(\".\");\r\n                if (hostnameParts) {\r\n                    // globalDatabaseAccountName will return 'contoso'\r\n                    var globalDatabaseAccountName = hostnameParts[0];\r\n                    \r\n                    // Prepare the locationalDatabaseAccountName as contoso-EastUS for location_name 'East US'\r\n                    var locationalDatabaseAccountName = globalDatabaseAccountName + \"-\" + locationName.replace(\" \", \"\");\r\n                    \r\n                    // Replace 'contoso' with 'contoso-EastUS' and return locationalEndpoint as https://contoso-EastUS.documents.azure.com:443/\r\n                    var locationalEndpoint = defaultEndpoint.toLowerCase().replace(globalDatabaseAccountName, locationalDatabaseAccountName);\r\n                    return locationalEndpoint;\r\n                }\r\n            }\r\n            \r\n            return null;\r\n        },\r\n        \r\n        /** Updates the read and write endpoints from the passed-in readable and writable locations.\r\n         * @memberof GlobalEndpointManager\r\n         * @instance\r\n         * @param {Array} writableLocations     - The list of writable locations for the geo-enabled database account.\r\n         * @param {Array} readableLocations     - The list of readable locations for the geo-enabled database account.\r\n         * @param {function} callback           - The function to be called as callback after executing this method.\r\n        */\r\n        _updateLocationsCache: function (writableLocations, readableLocations, callback) {\r\n            var writeEndpoint;\r\n            var readEndpoint;\r\n            // Use the default endpoint as Read and Write endpoints if EnableEndpointDiscovery\r\n            // is set to False.\r\n            if (!this.enableEndpointDiscovery) {\r\n                writeEndpoint = this.defaultEndpoint;\r\n                readEndpoint = this.defaultEndpoint;\r\n                return callback([writeEndpoint, readEndpoint]);\r\n            }\r\n            \r\n            // Use the default endpoint as Write endpoint if there are no writable locations, or\r\n            // first writable location as Write endpoint if there are writable locations\r\n            if (writableLocations.length === 0) {\r\n                writeEndpoint = this.defaultEndpoint;\r\n            } else {\r\n                writeEndpoint = writableLocations[0][Constants.DatabaseAccountEndpoint];\r\n            }\r\n            \r\n            // Use the Write endpoint as Read endpoint if there are no readable locations\r\n            if (readableLocations.length === 0) {\r\n                readEndpoint = writeEndpoint;\r\n                return callback([writeEndpoint, readEndpoint]);\r\n            } else {\r\n                // Use the writable location as Read endpoint if there are no preferred locations or\r\n                // none of the preferred locations are in read or write locations\r\n                readEndpoint = writeEndpoint;\r\n\r\n                if (!this.preferredLocations) {\r\n                    return callback([writeEndpoint, readEndpoint]);\r\n                }\r\n\r\n                for (var i= 0; i < this.preferredLocations.length; i++) {\r\n                    var preferredLocation = this.preferredLocations[i];\r\n                    // Use the first readable location as Read endpoint from the preferred locations\r\n                    for (var j = 0; j < readableLocations.length; j++) {\r\n                        var readLocation = readableLocations[j];\r\n                        if (readLocation[Constants.Name] === preferredLocation) {\r\n                            readEndpoint = readLocation[Constants.DatabaseAccountEndpoint];\r\n                            return callback([writeEndpoint, readEndpoint]);\r\n                        }\r\n                    }\r\n                    // Else, use the first writable location as Read endpoint from the preferred locations\r\n                    for (var k = 0; k < writableLocations.length; k++) {\r\n                        var writeLocation = writableLocations[k];\r\n                        if (writeLocation[Constants.Name] === preferredLocation) {\r\n                            readEndpoint = writeLocation[Constants.DatabaseAccountEndpoint];\r\n                            return callback([writeEndpoint, readEndpoint]);\r\n                        }\r\n                    }\r\n                }\r\n\r\n                return callback([writeEndpoint, readEndpoint]);\r\n            }\r\n        }\r\n    });\r\n//SCRIPT END\r\n\r\n    if (typeof exports !== \"undefined\") {\r\n        module.exports = GlobalEndpointManager;\r\n    }","/home/travis/build/npmtest/node-npmtest-documentdb/node_modules/documentdb/lib/hash/hashPartitionResolver.js":"/*\r\nThe MIT License (MIT)\r\nCopyright (c) 2014 Microsoft Corporation\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy\r\nof this software and associated documentation files (the \"Software\"), to deal\r\nin the Software without restriction, including without limitation the rights\r\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\ncopies of the Software, and to permit persons to whom the Software is\r\nfurnished to do so, subject to the following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included in all\r\ncopies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\nSOFTWARE.\r\n*/\r\n\r\n\"use strict\";\r\n\r\nvar Base = require('../base');\r\nvar ConsistentHashRing = require('./consistentHashRing.js').ConsistentHashRing;\r\n\r\nvar HashPartitionResolver = Base.defineClass(\r\n    /**\r\n     * HashPartitionResolver implements partitioning based on the value of a hash function, \r\n     * allowing you to evenly distribute requests and data across a number of partitions for\r\n     * the Azure DocumentDB database service.\r\n     * @class HashPartitionResolver\r\n     * @param {string | function} partitionKeyExtractor   - If partitionKeyExtractor is a string, it should be the name of the property in the document to execute the hashing on.\r\n     *                                                      If partitionKeyExtractor is a function, it should be a function to extract the partition key from an object.\r\n     **/\r\n    function (partitionKeyExtractor, collectionLinks, options) {\r\n        HashPartitionResolver._throwIfInvalidPartitionKeyExtractor(partitionKeyExtractor);\r\n        HashPartitionResolver._throwIfInvalidCollectionLinks(collectionLinks);\r\n        this.partitionKeyExtractor = partitionKeyExtractor;\r\n        \r\n        options = options || {};\r\n        this.consistentHashRing = new ConsistentHashRing(collectionLinks, options);\r\n        this.collectionLinks = collectionLinks;\r\n    }, {\r\n        /**\r\n         * Extracts the partition key from the specified document using the partitionKeyExtractor\r\n         * @memberof HashPartitionResolver\r\n         * @instance\r\n         * @param {object} document - The document from which to extract the partition key.\r\n         * @returns {object} \r\n         **/\r\n        getPartitionKey: function (document) {\r\n            return (typeof this.partitionKeyExtractor === \"string\")\r\n                ? document[this.partitionKeyExtractor]\r\n                : this.partitionKeyExtractor(document);\r\n        },\r\n        /**\r\n         * Given a partition key, returns a list of collection links to read from.\r\n         * @memberof HashPartitionResolver\r\n         * @instance\r\n         * @param {any} partitionKey - The partition key used to determine the target collection for query\r\n         **/\r\n        resolveForRead: function (partitionKey) {\r\n            if (partitionKey === undefined || partitionKey === null) {\r\n                return this.collectionLinks;\r\n            }\r\n\r\n            return [this._resolve(partitionKey)];            \r\n        },\r\n        /**\r\n         * Given a partition key, returns the correct collection link for creating a document.\r\n         * @memberof HashPartitionResolver\r\n         * @instance\r\n         * @param {any} partitionKey - The partition key used to determine the target collection for create\r\n         * @returns {string}         - The target collection link that will be used for document creation.\r\n         **/\r\n        resolveForCreate: function (partitionKey) {\r\n            return this._resolve(partitionKey);\r\n        },\r\n        /** @ignore */\r\n        _resolve: function (partitionKey) {\r\n            HashPartitionResolver._throwIfInvalidPartitionKey(partitionKey);\r\n            return this.consistentHashRing.getNode(partitionKey);\r\n        }\r\n    }, {\r\n        /** @ignore */\r\n        _throwIfInvalidPartitionKeyExtractor: function (partitionKeyExtractor) {\r\n            if (partitionKeyExtractor === undefined || partitionKeyExtractor === null) {\r\n                throw new Error(\"partitionKeyExtractor cannot be null or undefined\");\r\n            }\r\n            \r\n            if (typeof partitionKeyExtractor !== \"string\" && typeof partitionKeyExtractor !== \"function\") {\r\n                throw new Error(\"partitionKeyExtractor must be either a 'string' or a 'function'\");\r\n            }\r\n        },\r\n        /** @ignore */\r\n        _throwIfInvalidPartitionKey: function (partitionKey) {\r\n            var partitionKeyType = typeof partitionKey;\r\n            if (partitionKeyType !== \"string\") {\r\n                throw new Error(\"partitionKey must be a 'string'\");\r\n            }\r\n        },\r\n        /** @ignore */\r\n        _throwIfInvalidCollectionLinks: function (collectionLinks) {\r\n            if (!Array.isArray(collectionLinks)) {\r\n                throw new Error(\"collectionLinks must be an array.\");\r\n            }\r\n            \r\n            if (collectionLinks.some(function (collectionLink) { return !Base._isValidCollectionLink(collectionLink); })) {\r\n                throw new Error(\"All elements of collectionLinks must be collection links.\");\r\n            }\r\n        }\r\n    });\r\n\r\n//SCRIPT END\r\n\r\nif (typeof exports !== \"undefined\") {\r\n    exports.HashPartitionResolver = HashPartitionResolver;\r\n}","/home/travis/build/npmtest/node-npmtest-documentdb/node_modules/documentdb/lib/hash/consistentHashRing.js":"/*\r\nThe MIT License (MIT)\r\nCopyright (c) 2014 Microsoft Corporation\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy\r\nof this software and associated documentation files (the \"Software\"), to deal\r\nin the Software without restriction, including without limitation the rights\r\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\ncopies of the Software, and to permit persons to whom the Software is\r\nfurnished to do so, subject to the following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included in all\r\ncopies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\nSOFTWARE.\r\n*/\r\n\r\n\"use strict\";\r\n\r\nvar Base = require(\"../base\");\r\nvar MurmurHash = require('./murmurHash.js').MurmurHash;\r\n\r\nvar ConsistentHashRing = Base.defineClass(\r\n    /**\r\n     * Initializes a new instance of the ConsistentHashRing\r\n     * @param {string[]} nodes - Array of collection links\r\n     * @param {object} options - Options to initialize the ConsistentHashRing\r\n     * @param {function} options.computeHash - Function to compute the hash for a given link or partition key\r\n     * @param {function} options.numberOfVirtualNodesPerCollection - Number of points in the ring to assign to each collection link\r\n     */\r\n    function (nodes, options) {\r\n        ConsistentHashRing._throwIfInvalidNodes(nodes);\r\n        \r\n        options = options || {};\r\n        options.numberOfVirtualNodesPerCollection = options.numberOfVirtualNodesPerCollection || 128;\r\n        options.computeHash = options.computeHash || MurmurHash.hash;\r\n        \r\n        this._computeHash = options.computeHash;\r\n        this._partitions = ConsistentHashRing._constructPartitions(nodes, options.numberOfVirtualNodesPerCollection, options.computeHash);\r\n    }, {\r\n        getNode: function (key) {\r\n            var hash = this._computeHash(key);\r\n            var partition = ConsistentHashRing._search(this._partitions, hash);            \r\n            return this._partitions[partition].node;\r\n        }\r\n    },{\r\n        /** @ignore */\r\n        _constructPartitions: function (nodes, partitionsPerNode, computeHashFunction) {\r\n            var partitions = new Array();\r\n            nodes.forEach(function (node) {\r\n                var hashValue = computeHashFunction(node);\r\n                for (var j = 0; j < partitionsPerNode; j++) {\r\n                    partitions.push({\r\n                        hashValue: hashValue, \r\n                        node: node\r\n                    });\r\n                    \r\n                    hashValue = computeHashFunction(hashValue);\r\n                }\r\n            });\r\n            \r\n            partitions.sort(function (x, y) {\r\n                return ConsistentHashRing._compareHashes(x.hashValue, y.hashValue);\r\n            });\r\n            return partitions;\r\n        },\r\n        /** @ignore */\r\n        _compareHashes: function (x, y) {\r\n            if (x < y) return -1;\r\n            if (x > y) return 1;\r\n            return 0;\r\n        },\r\n        /** @ignore */\r\n        _search: function (partitions, hashValue) {\r\n            for (var i = 0; i < partitions.length - 1; i++) {\r\n                if (hashValue >= partitions[i].hashValue && hashValue < partitions[i + 1].hashValue) {\r\n                    return i;\r\n                }\r\n            }\r\n            \r\n            return partitions.length - 1;\r\n        },\r\n        /** @ignore */\r\n        _throwIfInvalidNodes: function (nodes) {\r\n            if (Array.isArray(nodes)) {\r\n                return;\r\n            }\r\n            \r\n            throw new Error(\"Invalid argument: 'nodes' has to be an array.\");\r\n        }\r\n    }\r\n        \r\n);\r\n\r\n//SCRIPT END\r\n\r\nif (typeof exports !== \"undefined\") {\r\n    exports.ConsistentHashRing = ConsistentHashRing;\r\n}","/home/travis/build/npmtest/node-npmtest-documentdb/node_modules/documentdb/lib/hash/murmurHash.js":"/*\r\nThe MIT License (MIT)\r\nCopyright (c) 2014 Microsoft Corporation\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy\r\nof this software and associated documentation files (the \"Software\"), to deal\r\nin the Software without restriction, including without limitation the rights\r\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\ncopies of the Software, and to permit persons to whom the Software is\r\nfurnished to do so, subject to the following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included in all\r\ncopies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\nSOFTWARE.\r\n*/\r\n\r\n\"use strict\";\r\n\r\nvar Base = require(\"../base\");\r\n\r\nvar MurmurHash = Base.defineClass(\r\n    undefined, \r\n    undefined,\r\n    {\r\n        /**\r\n         * Hashes a string, a unsigned 32-bit integer, or a Buffer into a new unsigned 32-bit integer that represents the output hash.\r\n         * @param {string, number of Buffer} key  - The preimage of the hash\r\n         * @param {number} seed                   - Optional value used to initialize the hash generator\r\n         * @returns {} \r\n         */\r\n        hash: function (key, seed) {\r\n            key = key || '';\r\n            seed = seed || 0;\r\n            \r\n            MurmurHash._throwIfInvalidKey(key);\r\n            MurmurHash._throwIfInvalidSeed(seed);\r\n            \r\n            var buffer;\r\n            if (typeof key === \"string\") {\r\n                buffer = MurmurHash._getBufferFromString(key);\r\n            }\r\n            else if (typeof key === \"number\") {\r\n                buffer = MurmurHash._getBufferFromNumber(key);\r\n            }\r\n            else {\r\n                buffer = key;\r\n            }\r\n            \r\n            return MurmurHash._hashBytes(buffer, seed);\r\n        },\r\n        /** @ignore */\r\n        _throwIfInvalidKey: function (key) {\r\n            if (key instanceof Buffer) {\r\n                return;\r\n            }\r\n            \r\n            if (typeof key === \"string\") {\r\n                return;\r\n            }\r\n            \r\n            if (typeof key === \"number\") {\r\n                return;\r\n            }\r\n            \r\n            throw new Error(\"Invalid argument: 'key' has to be a Buffer, string, or number.\");\r\n        },\r\n        /** @ignore */\r\n        _throwIfInvalidSeed: function (seed) {\r\n            if (isNaN(seed)) {\r\n                throw new Error(\"Invalid argument: 'seed' is not and cannot be converted to a number.\");\r\n            }\r\n        },\r\n        /** @ignore */\r\n        _getBufferFromString: function (key) {\r\n            var buffer = new Buffer(key);\r\n            return buffer;\r\n        },\r\n        /** @ignore */\r\n        _getBufferFromNumber: function (i) {\r\n            i = i >>> 0;\r\n            \r\n            var buffer = new Uint8Array([\r\n                i >>> 0,\r\n                i >>> 8,\r\n                i >>> 16,\r\n                i >>> 24\r\n            ]);\r\n\r\n            return buffer;\r\n        },\r\n        /** @ignore */\r\n        _hashBytes: function (bytes, seed) {\r\n            var c1 = 0xcc9e2d51;\r\n            var c2 = 0x1b873593;\r\n            \r\n            var h1 = seed;\r\n            var reader = new Uint32Array(bytes);\r\n            {\r\n                for (var i = 0; i < bytes.length - 3; i += 4) {\r\n                    var k1 = MurmurHash._readUInt32(reader, i);\r\n                    \r\n                    k1 = MurmurHash._multiply(k1, c1);\r\n                    k1 = MurmurHash._rotateLeft(k1, 15);\r\n                    k1 = MurmurHash._multiply(k1, c2);\r\n                    \r\n                    h1 ^= k1;\r\n                    h1 = MurmurHash._rotateLeft(h1, 13);\r\n                    h1 = MurmurHash._multiply(h1, 5) + 0xe6546b64;\r\n                }\r\n            }\r\n            \r\n            var k = 0;\r\n            switch (bytes.length & 3) {\r\n                case 3:\r\n                    k ^= reader[i + 2] << 16;\r\n                    k ^= reader[i + 1] << 8;\r\n                    k ^= reader[i];\r\n                    break;\r\n\r\n                case 2:\r\n                    k ^= reader[i + 1] << 8;\r\n                    k ^= reader[i];\r\n                    break;\r\n\r\n                case 1:\r\n                    k ^= reader[i];\r\n                    break;\r\n            }\r\n            \r\n            k = MurmurHash._multiply(k, c1);\r\n            k = MurmurHash._rotateLeft(k, 15);\r\n            k = MurmurHash._multiply(k, c2);\r\n            \r\n            h1 ^= k;\r\n            h1 ^= bytes.length;\r\n            h1 ^= h1 >>> 16;\r\n            h1 = MurmurHash._multiply(h1, 0x85ebca6b);\r\n            h1 ^= h1 >>> 13;\r\n            h1 = MurmurHash._multiply(h1, 0xc2b2ae35);\r\n            h1 ^= h1 >>> 16;\r\n            \r\n            return h1 >>> 0;\r\n        },\r\n        /** @ignore */\r\n        _rotateLeft: function (n, numBits) {\r\n            return (n << numBits) | (n >>> (32 - numBits));\r\n        },\r\n        /** @ignore */\r\n        _multiply: function (m, n) {\r\n            return ((m & 0xffff) * n) + ((((m >>> 16) * n) & 0xffff) << 16);\r\n        },\r\n        /** @ignore */\r\n        _readUInt32: function (uintArray, i) {\r\n            return (uintArray[i]) | (uintArray[i + 1] << 8) | (uintArray[i + 2] << 16) | (uintArray[i + 3] << 24) >>> 0;\r\n        }\r\n    });\r\n\r\n//SCRIPT END\r\n\r\nif (typeof exports !== \"undefined\") {\r\n    exports.MurmurHash = MurmurHash;\r\n}","/home/travis/build/npmtest/node-npmtest-documentdb/node_modules/documentdb/lib/range.js":"/*\r\nThe MIT License (MIT)\r\nCopyright (c) 2014 Microsoft Corporation\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy\r\nof this software and associated documentation files (the \"Software\"), to deal\r\nin the Software without restriction, including without limitation the rights\r\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\ncopies of the Software, and to permit persons to whom the Software is\r\nfurnished to do so, subject to the following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included in all\r\ncopies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\nSOFTWARE.\r\n*/\r\n\r\n\"use strict\";\r\n\r\nvar Base = require(\"./base\");\r\n\r\n//SCRIPT START\r\nvar Range = Base.defineClass(\r\n    /**\r\n     * Represents a range object used by the RangePartitionResolver in the Azure DocumentDB database service.\r\n     * @class Range\r\n     * @param {object} options                   - The Range constructor options.\r\n     * @param {any} options.low                  - The low value in the range.\r\n     * @param {any} options.high                 - The high value in the range.\r\n     **/\r\n    function(options) {\r\n        if (options === undefined) {\r\n            options = {};\r\n        }\r\n        if (options === null) {\r\n            throw new Error(\"Invalid argument: 'options' is null\");\r\n        }\r\n        if (typeof options !== \"object\") {\r\n            throw new Error(\"Invalid argument: 'options' is not an object\");\r\n        }\r\n        if (options.high === undefined) {\r\n            options.high = options.low;\r\n        }\r\n        this.low = options.low;\r\n        this.high = options.high;\r\n        Object.freeze(this);\r\n    },\r\n    {\r\n        /** @ignore */\r\n        _compare: function (x, y, compareFunction) {\r\n            // Same semantics as Array.sort\r\n            // http://www.ecma-international.org/ecma-262/6.0/#sec-sortcompare\r\n            if (x === undefined && y === undefined)\r\n                return 0;\r\n            if (x === undefined)\r\n                return 1;\r\n            if (y === undefined)\r\n                return -1;\r\n            if (compareFunction !== undefined) {\r\n                var v = Number(compareFunction(x, y));\r\n                if (v === NaN)\r\n                    return 0;\r\n                return v;\r\n            }\r\n            var xString = String(x);\r\n            var yString = String(y);\r\n            if (xString < yString)\r\n                return -1;\r\n            if (xString > yString)\r\n                return 1;\r\n            return 0;\r\n        },\r\n\r\n        /** @ignore */\r\n        _contains: function (other, compareFunction) {\r\n            if (Range._isRange(other)) {\r\n                return this._containsRange(other, compareFunction);\r\n            }\r\n            else {\r\n                return this._containsPoint(other, compareFunction);\r\n            }\r\n        },\r\n\r\n        /** @ignore */\r\n        _containsPoint: function (point, compareFunction) {\r\n            if (this._compare(point, this.low, compareFunction) >= 0 && this._compare(point, this.high, compareFunction) <= 0) {\r\n                return true;\r\n            }\r\n            return false;\r\n        },\r\n\r\n        /** @ignore */\r\n        _containsRange: function (other, compareFunction) {\r\n            if (this._compare(other.low, this.low, compareFunction) >= 0 && this._compare(other.high, this.high, compareFunction) <= 0) {\r\n                return true;\r\n            }\r\n            return false;\r\n        },\r\n\r\n        /** @ignore */\r\n        _intersect: function (other, compareFunction) {\r\n            if (other === undefined || other === null) {\r\n                throw new Error(\"Invalid Argument: 'other' is undefined or null\");\r\n            }\r\n            var maxLow = this._compare(this.low, other.low, compareFunction) >= 0 ? this.low : other.low;\r\n            var minHigh = this._compare(this.high, other.high, compareFunction) <= 0 ? this.high : other.high;\r\n            if (this._compare(maxLow, minHigh, compareFunction) <= 0) {\r\n                return true;\r\n            }\r\n            return false;\r\n        },\r\n\r\n         /** @ignore */\r\n        _toArrayImplementation: function(callback){\r\n            var that = this;\r\n            if (this._canFetchMore()) {\r\n                this._fetchMore(function(err, resources, headers){\r\n                    if(err) {\r\n                        return callback(err, undefined, headers);\r\n                    }\r\n\r\n                    that.resHeaders = headers;\r\n                    that.resources = that.resources.concat(resources);\r\n                    that._toArrayImplementation(callback);\r\n                });\r\n            } else {\r\n                this._state = this._states.ended;\r\n                callback(undefined, this.resources, this.resHeaders);\r\n            }\r\n        },\r\n\r\n        /** @ignore */\r\n        _toString: function () {\r\n            return String(this.low) + \",\" + String(this.high);\r\n        }\r\n    },\r\n    {\r\n        /** @ignore */\r\n        _isRange: function (pointOrRange) {\r\n            if (pointOrRange === undefined) {\r\n                return false;\r\n            }\r\n            if (pointOrRange === null) {\r\n                return false;\r\n            }\r\n            if (typeof pointOrRange !== \"object\") {\r\n                return false;\r\n            }\r\n            return (\"low\" in pointOrRange && \"high\" in pointOrRange);\r\n        }\r\n    }\r\n);\r\n\r\nvar RangePartitionResolver = Base.defineClass(\r\n    /**\r\n     * RangePartitionResolver implements partitioning using a partition map of ranges of values to a collection link in the Azure DocumentDB database service.\r\n     * @class RangePartitionResolver\r\n     * @param {string | function} partitionKeyExtractor   - If partitionKeyExtractor is a string, it should be the name of the property in the document to execute the hashing on.\r\n     *                                                      If partitionKeyExtractor is a function, it should be a function to extract the partition key from an object.\r\n     * @param {Array} partitionKeyMap                     - The map from Range to collection link that is used for partitioning requests.\r\n     * @param {function} compareFunction                  - Optional function that accepts two arguments x and y and returns a negative value if x < y, zero if x = y, or a positive value if x > y.\r\n     **/\r\n    function(partitionKeyExtractor, partitionKeyMap, compareFunction) {\r\n        if (partitionKeyExtractor === undefined || partitionKeyExtractor === null) {\r\n            throw new Error(\"partitionKeyExtractor cannot be null or undefined\");\r\n        }\r\n        if (typeof partitionKeyExtractor !== \"string\" && typeof partitionKeyExtractor !== \"function\") {\r\n            throw new Error(\"partitionKeyExtractor must be either a 'string' or a 'function'\");\r\n        }\r\n        if (partitionKeyMap === undefined || partitionKeyMap === null) {\r\n            throw new Error(\"partitionKeyMap cannot be null or undefined\");\r\n        }\r\n        if (!(Array.isArray(partitionKeyMap))) {\r\n            throw new Error(\"partitionKeyMap has to be an Array\");\r\n        }\r\n        var allMapEntriesAreValid = partitionKeyMap.every(function (mapEntry) {\r\n            if ((mapEntry === undefined) || mapEntry === null) {\r\n                return false;\r\n            }\r\n            if (mapEntry.range === undefined) {\r\n                return false;\r\n            }\r\n            if (!(mapEntry.range instanceof Range)) {\r\n                return false;\r\n            }\r\n            if (mapEntry.link === undefined) {\r\n                return false;\r\n            }\r\n            if (typeof mapEntry.link !== \"string\") {\r\n                return false;\r\n            }\r\n            return true;\r\n        });\r\n        if (!allMapEntriesAreValid) {\r\n            throw new Error(\"All partitionKeyMap entries have to be a tuple {range: Range, link: string }\");\r\n        }\r\n        if (compareFunction !== undefined && typeof compareFunction !== \"function\") {\r\n            throw new Error(\"Invalid argument: 'compareFunction' is not a function\");\r\n        }\r\n\r\n        this.partitionKeyExtractor = partitionKeyExtractor;\r\n        this.partitionKeyMap = partitionKeyMap;\r\n        this.compareFunction = compareFunction;\r\n    }, {\r\n        /**\r\n         * Extracts the partition key from the specified document using the partitionKeyExtractor\r\n         * @memberof RangePartitionResolver\r\n         * @instance\r\n         * @param {object} document - The document from which to extract the partition key.\r\n         * @returns {}\r\n         **/\r\n        getPartitionKey: function (document) {\r\n            if (typeof this.partitionKeyExtractor === \"string\") {\r\n                return document[this.partitionKeyExtractor];\r\n            }\r\n            if (typeof this.partitionKeyExtractor === \"function\") {\r\n                return this.partitionKeyExtractor(document);\r\n            }\r\n            throw new Error(\"Unable to extract partition key from document. Ensure PartitionKeyExtractor is a valid function or property name.\");\r\n        },\r\n\r\n        /**\r\n         * Given a partition key, returns the correct collection link for creating a document using the range partition map.\r\n         * @memberof RangePartitionResolver\r\n         * @instance\r\n         * @param {any} partitionKey - The partition key used to determine the target collection for create\r\n         * @returns {string}         - The target collection link that will be used for document creation.\r\n         **/\r\n        resolveForCreate: function (partitionKey) {\r\n            var range = new Range({ low: partitionKey });\r\n            var mapEntry = this._getFirstContainingMapEntryOrNull(range);\r\n            if (mapEntry !== undefined && mapEntry !== null) {\r\n                return mapEntry.link;\r\n            }\r\n            throw new Error(\"Invalid operation: A containing range for '\" + range._toString() + \"' doesn't exist in the partition map.\");\r\n        },\r\n\r\n        /**\r\n         * Given a partition key, returns a list of collection links to read from using the range partition map.\r\n         * @memberof RangePartitionResolver\r\n         * @instance\r\n         * @param {any} partitionKey - The partition key used to determine the target collection for query\r\n         * @returns {string[]}         - The list of target collection links.\r\n         **/\r\n        resolveForRead: function (partitionKey) {\r\n            if (partitionKey === undefined || partitionKey === null) {\r\n                return this.partitionKeyMap.map(function (i) { return i.link; });\r\n            }\r\n            else {\r\n                return this._getIntersectingMapEntries(partitionKey).map(function (i) { return i.link; });\r\n            }\r\n        },\r\n\r\n        /** @ignore */\r\n        _getFirstContainingMapEntryOrNull: function (point) {\r\n            var _this = this;\r\n            var containingMapEntries = this.partitionKeyMap.filter(function (p) { return p.range !== undefined && p.range._contains(point, _this.compareFunction); });\r\n            if (containingMapEntries && containingMapEntries.length > 0) {\r\n                return containingMapEntries[0];\r\n            }\r\n            return null;\r\n        },\r\n\r\n        /** @ignore */\r\n        _getIntersectingMapEntries: function (partitionKey) {\r\n            var _this = this;\r\n            var partitionKeys = (partitionKey instanceof Array) ? partitionKey : [partitionKey];\r\n            var ranges = partitionKeys.map(function (p) { return Range._isRange(p) ? p : new Range({ low: p }); });\r\n            var result = new Array();\r\n            ranges.forEach(function (range) {\r\n                result = result.concat(_this.partitionKeyMap.filter(function (entry) {\r\n                    return entry.range._intersect(range, _this.compareFunction);\r\n                }));\r\n            });\r\n            return result;\r\n        }\r\n    }\r\n);\r\n//SCRIPT END\r\n\r\nif (typeof exports !== \"undefined\") {\r\n    exports.Range = Range;\r\n    exports.RangePartitionResolver = RangePartitionResolver;\r\n}","/home/travis/build/npmtest/node-npmtest-documentdb/node_modules/documentdb/Gruntfile.js":"/*\r\nThe MIT License (MIT)\r\nCopyright (c) 2014 Microsoft Corporation\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy\r\nof this software and associated documentation files (the \"Software\"), to deal\r\nin the Software without restriction, including without limitation the rights\r\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\ncopies of the Software, and to permit persons to whom the Software is\r\nfurnished to do so, subject to the following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included in all\r\ncopies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\nSOFTWARE.\r\n*/\r\n\r\n\"use strict\";\r\n\r\nmodule.exports = function (grunt) {\r\n    require(\"time-grunt\")(grunt);\r\n    // Load grunt tasks automatically\r\n    require(\"load-grunt-tasks\")(grunt);\r\n\r\n    grunt.initConfig({\r\n        eslint: {\r\n            src: [\r\n                \"lib/*.js\",\r\n                \"lib/hash/*.js\",\r\n                \"lib/queryExecutionContext/*.js\",\r\n                \"lib/routing/*.js\",\r\n                \"test/*.js\"],\r\n            options: {\r\n                configFile: \".eslintrc\"\r\n            }\r\n        }\r\n    });\r\n\r\n    grunt.registerTask(\"lint\", [\"eslint\"]);\r\n    grunt.registerTask(\"default\", \"lint\");\r\n};"}